[{"content":"kafka主题与分区 主题和分区是Kafka 的两个核心概念，前面章节中讲述的生产者和消费者的设计理念所针对的都是主题和分区层面的操作。主题作为消息的归类，可以再细分为一个或多个分区，分区也可以看作对消息的二次归类。分区的划分不仅为Kafka提供了可伸缩性、水平扩展的功能，还通过多副本机制来为Kafka提供数据冗余以提高数据可靠性。\n从Kafka的底层实现来说，主题和分区都是逻辑上的概念，分区可以有一至多个副本，每个副本对应一个日志文件，每个日志文件对应一至多个日志分段（LogSegment），每个日志分段还可以细分为索引文件、日志存储文件和快照文件等。不过对于使用Kafka进行消息收发的普通用户而言，了解到分区这一层面足以应对大部分的使用场景。\n1 主题的管理 如果broker端配置参数auto.create.topics.enable设置为true（默认值就是true），那么当生产者向一个尚未创建的主题发送消息时，会自动创建一个分区数为num.partitions （默认值为1）、副本因子为default.replication.factor（默认值为1）的主题。除此之外，当一个消费者开始从未知主题中读取消息时，或者当任意一个客户端向未知主题发送元数据请求时，都会按照配置参数num.partitions和default.replication.factor的值来创建一个相应的主题。很多时候，这种自动创建主题的行为都是非预期的。除非有特殊应用需求，否则不建议将auto.create.topics.enable参数设置为true，这个参数会增加主题的管理与维护的难度。\n","date":"2022-08-31T16:47:00Z","permalink":"https://lyoshur.github.io/stack/p/kafka%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%88%86%E5%8C%BA/","title":"kafka主题与分区"},{"content":"kafka生产者与消费者 1 实用的脚本工具 Kafka提供了许多实用的脚本工具，存放在$KAFKA_HOME的bin目录下\nkafka-topics.sh\n1 kafka-topics.sh --zookeeper localhost:2181/kafka --create --topic topic-demo --replication-factor 3 --partitions 4 创建一个分区数为4，副本因子为3的主题 topic-demo\nkafka-console-consumer.sh\n1 kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic-demo 创建一个订阅主题topic-demo的消费者\nkafka-console-producer.sh\n1 kafka-console-producer.sh --broker-list localhost:9092 --topic topic-demo 创建一个发布主题为topic-demo的生产者\n2 Java客户端 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.kafka\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;kafka-clients\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3 生产客户端 一个正常的生产逻辑需要具备以下几个步骤：\n配置生产者客户端参数及创建相应的生产者实例。\n构建待发送的消息。\n发送消息。\n关闭生产者实例\n要往Kafka中写入消息，首先要创建一个生产者客户端实例并设置一些配置参数，然后构建消息的ProducerRecord对象，其中必须包含所要发往的主题及消息的消息体，进而再通过生产者客户端实例将消息发出，最后可以通过 close（）方法来关闭生产者客户端实例并回收相应的资源。\n这里有必要单独说明的是构建的消息对象ProducerRecord，它并不是单纯意义上的消息，它包含了多个属性，原本需要发送的与业务相关的消息体只是其中的一个 value 属性，比如“Hello，Kafka！”只是ProducerRecord对象中的一个属性。ProducerRecord类的定义如下：\ntopic 主题\npartition 分区号\nheaders 消息头部\nkey 键\n同一个key的消息会被划分到同一个分区中\nvalue 值\nvalue是指消息体，一般不为空，如果为空则表示特定的消息—墓碑消息\ntimestamp 消息的时间戳\n3.1 生产者实例的必要参数 bootstrap.servers：该参数用来指定生产者客户端连接Kafka集群所需的broker地址清单，具体的内容格式为host1：port1，host2：port2，可以设置一个或多个地址，中间以逗号隔开，此参数的默认值为“”。注意这里并非需要所有的broker地址，因为生产者会从给定的broker里查找到其他broker的信息。不过建议至少要设置两个以上的broker 地址信息，当其中任意一个宕机时，生产者仍然可以连接到 Kafka集群上。 key.serializer 和 value.serializer：broker 端接收的消息必须以字节数组（byte[]）的形式存在。代码清单2-1中生产者使用的KafkaProducer＜String，String＞和ProducerRecord＜String，String＞中的泛型＜String，String＞对应的就是消息中key和value的类型，生产者客户端使用这种方式可以让代码具有良好的可读性，不过在发往broker之前需要将消息中对应的key和value做相应的序列化操作来转换成字节数组。key.serializer和value.serializer这两个参数分别用来指定key和value序列化操作的序列化器，这两个参数无默认值。注意这里必须填写序列化器的全限定名 client.id：这个参数用来设定KafkaProducer对应的客户端id，默认值为“”。如果客户端不设置，则KafkaProducer会自动生成一个非空字符串，内容形式如“producer-1”“producer-2”，即字符串“producer-”与数字的拼接。 一般情况下，普通开发人员无法记住所有的参数名称，只能有个大致的印象。在实际使用过程中，诸如“key.serializer”“max.request.size”“interceptor.classes”之类的字符串经常由于人为因素而书写错误。为此，我们可以直接使用客户端中的org.apache.kafka.clients.producer.ProducerConfig类来做一定程度上的预防措施，每个参数在ProducerConfig 类中都有对应的名称\n3.2 消息的发送 在创建完生产者实例之后，接下来的工作就是构建消息，即创建ProducerRecord对象。\n针对不同的消息，需要构建不同的ProducerRecord对象，在实际应用中创建ProducerRecord对象是一个非常频繁的动作。\n发送消息主要有三种模式：\n发后即忘（fire-and-forget）\n1 producer.send(record) 同步（sync）\n1 producer.send(record).get() 异步（async）\n1 producer.send(record, new Callback(){}) KafkaProducer 的 send（）方法并非是 void 类型，而是 Future＜RecordMetadata＞类型。\n消息发送完成后需要调用close，关闭生产者。\n3.3 序列化 生产者需要用序列化器（Serializer）把对象转换成字节数组才能通过网络发送给Kafka。而在对侧，消费者需要用反序列化器（Deserializer）把从 Kafka 中收到的字节数组转换成相应的对象。\norg.apache.kafka.common.serialization.Serializer接口，此接口有3个方法：\npublic void configure(Map\u0026lt;String, ?\u0026gt; configs, boolean isKey) public byte[] serialize(String topic, T data) public void close() 如果 Kafka 客户端提供的几种序列化器都无法满足应用需求，则可以选择使用如 Avro、JSON、Thrift、ProtoBuf和Protostuff等通用的序列化工具来实现，或者使用自定义类型的序列化器来实现。\n3.4 分区器 消息在通过send（）方法发往broker的过程中，有可能需要经过拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）的一系列作用之后才能被真正地发往 broker。拦截器一般不是必需的，而序列化器是必需的。消息经过序列化之后就需要确定它发往的分区，如果消息ProducerRecord中指定了partition字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。\n如果消息ProducerRecord中没有指定partition字段，那么就需要依赖分区器，根据key这个字段来计算partition的值。分区器的作用就是为消息分配分区。\nKafka中提供的默认分区器是org.apache.kafka.clients.producer.internals.DefaultPartitioner，它实现了org.apache.kafka.clients.producer.Partitioner接口，这个接口中定义了2个方法，具体如下所示。\npublic int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) public void close() 其中partition（）方法用来计算分区号，返回值为int类型。partition（）方法中的参数分别表示主题、键、序列化后的键、值、序列化后的值，以及集群的元数据信息，通过这些信息可以实现功能丰富的分区器。close（）方法在关闭分区器的时候用来回收一些资源。\nPartitioner 接口还有一个父接口org.apache.kafka.common.Configurable，这个接口中只有一个方法,Configurable接口中的configure（）方法主要用来获取配置信息及初始化数据。\n3.5 拦截器 4 重要的生产者参数 4.1 acks 这个参数用来指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的。acks 是生产者客户端中一个非常重要的参数，它涉及消息的可靠性和吞吐量之间的权衡。acks参数有3种类型的值（都是字符串类型）。\nacks=1。默认值即为1。生产者发送消息之后，只要分区的leader副本成功写入消息，那么它就会收到来自服务端的成功响应。\nacks=0。生产者发送消息之后不需要等待任何服务端的响应。如果在消息从发送到写入Kafka的过程中出现某些异常，导致Kafka并没有收到这条消息，那么生产者也无从得知，消息也就丢失了。在其他配置环境相同的情况下，acks 设置为 0 可以达到最大的吞吐量。\nacks=-1或acks=all。生产者在消息发送之后，需要等待ISR中的所有副本都成功写入消息之后才能够收到来自服务端的成功响应。在其他配置环境相同的情况下，acks 设置为-1（all）可以达到最强的可靠性。但这并不意味着消息就一定可靠，因为ISR中可能只有leader副本，这样就退化成了acks=1的情况。要获得更高的消息可靠性需要配合 min.insync.replicas 等参数的联动，\n4.2 max.request.size 这个参数用来限制生产者客户端能发送的消息的最大值，默认值为 1048576B，即 1MB。一般情况下，这个默认值就可以满足大多数的应用场景了。笔者并不建议读者盲目地增大这个参数的配置值，尤其是在对Kafka整体脉络没有足够把控的时候。因为这个参数还涉及一些其他参数的联动，比如broker端的message.max.bytes参数，如果配置错误可能会引起一些不必要的异常。\n4.3 retries和retry.backoff.ms retries参数用来配置生产者重试的次数，默认值为0，即在发生异常的时候不进行任何重试动作。消息在从生产者发出到成功写入服务器之前可能发生一些临时性的异常，比如网络抖动、leader副本的选举等，这种异常往往是可以自行恢复的，生产者可以通过配置retries大于0的值，以此通过内部重试来恢复而不是一味地将异常抛给生产者的应用程序。\nretry.backoff.ms，这个参数的默认值为100，它用来设定两次重试之间的时间间隔，避免无效的频繁重试。\n4.4 compression.type 这个参数用来指定消息的压缩方式，默认值为“none”，即默认情况下，消息不会被压缩。该参数还可以配置为“gzip”“snappy”和“lz4”。对消息进行压缩可以极大地减少网络传输量、降低网络I/O，从而提高整体的性能。消息压缩是一种使用时间换空间的优化方式，如果对时延有一定的要求，则不推荐对消息进行压缩。\n4.5 connections.max.idle.ms 这个参数用来指定在多久之后关闭限制的连接，默认值是540000（ms），即9分钟。\n4.6 linger.ms 这个参数用来指定生产者发送 ProducerBatch 之前等待更多消息（ProducerRecord）加入ProducerBatch 的时间，默认值为 0。生产者客户端会在 ProducerBatch 被填满或等待时间超过linger.ms 值时发送出去。增大这个参数的值会增加消息的延迟，但是同时能提升一定的吞吐量。这个linger.ms参数与TCP协议中的Nagle算法有异曲同工之妙。\n4.7 receive.buffer.bytes 这个参数用来设置Socket接收消息缓冲区（SO_RECBUF）的大小，默认值为32768（B），即32KB。如果设置为-1，则使用操作系统的默认值。如果Producer与Kafka处于不同的机房，则可以适地调大这个参数值。\n4.8 send.buffer.bytes 这个参数用来设置Socket发送消息缓冲区（SO_SNDBUF）的大小，默认值为131072（B），即128KB。与receive.buffer.bytes参数一样，如果设置为-1，则使用操作系统的默认值。\n4.9 request.timeout.ms 这个参数用来配置Producer等待请求响应的最长时间，默认值为30000（ms）。请求超时之后可以选择进行重试。注意这个参数需要比broker端参数replica.lag.time.max.ms的值要大，这样可以减少因客户端重试而引起的消息重复的概率。\n5 消费者与消费组 消费者（Consumer）负责订阅Kafka中的主题（Topic），并且从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在Kafka的消费理念中还有一层消费组（Consumer Group）的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。\n某个主题中共有4个分区（Partition）：P0、P1、P2、P3。有两个消费组A和B都订阅了这个主题，消费组A中有4个消费者（C0、C1、C2和C3），消费组B中有2个消费者（C4和C5）。按照Kafka默认的规则，最后的分配结果是消费组A中的每一个消费者分配到1个分区，消费组B中的每一个消费者分配到2个分区，两个消费组之间互不影响。每个消费者只能消费所分配到的分区中的消息。换言之，每一个分区只能被一个消费组中的一个消费者所消费。\n可以通过消费者客户端参数partition.assignment.strategy 来设置消费者与订阅主题之间的分区分配策略。\n消费者与消费组这种模型可以让整体的消费能力具备横向伸缩性，我们可以增加（或减少）消费者的个数来提高（或降低）整体的消费能力。对于分区数固定的情况，一味地增加消费者并不会让消费能力一直得到提升，如果消费者过多，出现了消费者的个数大于分区个数的情况，就会有消费者分配不到任何分区。\n6 消费者客户端 一个正常的消费逻辑需要具备以下几个步骤：\n配置消费者客户端参数以及创建相应的消费者实例。 订阅主题。 拉取消息并消费。 提交消费位移。 关闭消费者实例。 必要的参数配置：\nbootstrap.servers：该参数的释义和生产者客户端 KafkaProducer 中的相同，用来 指 定 连 接Kafka 集 群 所 需 的 broker 地 址 清 单，具 体内 容 形 式 为host1：port1，host2：post，可以设置一个或多个地址，中间用逗号隔开，此参数的默认值为“”。 group.id：消费者隶属的消费组的名称，默认值为“”。如果设置为空，则会报出异常 key.deserializer 和 value.deserializer：与生产者客户端 KafkaProducer中的key.serializer和value.serializer参数对应。消费者从broker端获取的消息格式都是字节数组（byte[]）类型，所以需要执行相应的反序列化操作才能还原成原有的对象格式。这两个参数分别用来指定消息中key和value所需反序列化操作的反序列化器，这两个参数无默认值。注意这里必须填写反序列化器类的全限定名 6.1 订阅主题与分区 使用subscribe（）方法订阅主题\n在 Kafka 中默认的消费位移的提交方式是自动提交，这个由消费者客户端参数enable.auto.commit 配置，默认值为 true。当然这个默认的自动提交不是每消费一条消息就提交一次，而是定期提交，这个定期的周期时间由客户端参数auto.commit.interval.ms配置，默认值为5秒，此参数生效的前提是enable.auto.commit参数为true\n在默认的方式下，消费者每隔5秒会将拉取到的每个分区中最大的消息位移进行提交。自动位移提交的动作是在poll（）方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。\n在Kafka消费的编程逻辑中位移提交是一大难点，自动提交消费位移的方式非常简便，它免去了复杂的位移提交逻辑，让编码更简洁。但随之而来的是重复消费和消息丢失的问题。假设刚刚提交完一次消费位移，然后拉取一批消息进行消费，在下一次自动提交消费位移之前，消费者崩溃了，那么又得从上一次位移提交的地方重新开始消费，这样便发生了重复消费的现象（对于再均衡的情况同样适用）。我们可以通过减小位移提交的时间间隔来减小重复消息的窗口大小，但这样并不能避免重复消费的发送，而且也会使位移提交更加频繁。\n","date":"2022-08-31T11:22:00Z","permalink":"https://lyoshur.github.io/stack/p/kafka%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85/","title":"kafka生产者与消费者"},{"content":"kafka基础 1 初识Kafka Kafka起初是由LinkedIn公司采用Scala语言开发的一个多分区、多副本且基于ZooKeeper协调的分布式消息系统。目前Kafka已经定位为一个分布式流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。\n目前越来越多的开源分布式处理系统如Cloudera、Storm、Spark、Flink等都支持与Kafka集成。\nKafka之所以受到越来越多的青睐，与它所“扮演”的三大角色是分不开的：\n消息系统：Kafka 和传统的消息系统（也称作消息中间件）都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，Kafka 还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能。 存储系统：Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险。也正是得益于Kafka 的消息持久化功能和多副本机制，我们可以把Kafka作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。 流式处理平台：Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。 Kafka体系结构术语：\nProducer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。\nConsumer：消费者，也就是接收消息的一方。消费者连接到Kafka上并接收消息，进而进行相应的业务逻辑处理。\nBroker：服务代理节点。对于Kafka而言，Broker可以简单地看作一个独立的Kafka服务节点或Kafka服务实例。大多数情况下也可以将Broker看作一台Kafka服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个Broker组成了一个Kafka集群。一般而言，我们更习惯使用首字母小写的broker来表示服务代理节点。\nTopic：主题，Kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到Kafka集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。\nPartition：分区，主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区（Topic-Partition）。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset是消息在分区中的唯一标识，Kafka通过它来保证消息在分区内的顺序性，不过offset并不跨越分区，也就是说，Kafka保证的是分区有序而不是主题有序。\nReplica：副本，Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是“一主多从”的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中某个broker失效时仍然能保证服务可用。\nAR（Assigned Replicas）：分区中的所有副本统称为AR（Assigned Replicas）。AR=ISR+OSR\nISR（In-Sync Replicas）：所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR（In-Sync Replicas），ISR集合是AR集合中的一个子集。\nOSR（Out-of-Sync Replicas）：与leader副本同步滞后过多的副本（不包括leader副本）组成OSR（Out-of-Sync Replicas）。\nHW（High Watermark）：高水位，它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个offset之前的消息。\nLEO（Log End Offset）：它标识当前日志文件中下一条待写入消息的offset，图1-4中offset为9的位置即为当前日志文件的LEO，LEO的大小相当于当前日志分区中最后一条消息的offset值加1。分区ISR集合中的每个副本都会维护自身的LEO，而ISR集合中最小的LEO即为分区的HW，对消费者而言只能消费HW之前的消息。\n","date":"2022-08-31T10:47:00Z","permalink":"https://lyoshur.github.io/stack/p/kafka%E5%9F%BA%E7%A1%80/","title":"kafka基础"},{"content":"常用JVM配置参数 -Xms 初始堆内存大小，默认为物理内存的1/64（等价于-XX:InitialHeapSize）\n-Xmx 最大堆内存大小，默认为物理内存的1/4（等价于-XX:MaxHeapSize）\n-Xmn 设置年轻代大小（等价于-XX:MaxNewSize=512m）\n-Xss 设置单个线程的线程栈大小，一般默认512k到1024k（等价于-XX:ThreadStackSize）\n-XX:MetaspaceSize 设置元空间大小（元空间与永久代最大的区别为：元空间并不在虚拟机中，而使用的是本地内存，因此，元空间只收本地内存的限制）\n-XX:MaxMetaspaceSize 设置最大元空间大小\n-XX:+PrintGCDetails 输出详细GC收集日志信息\n-XX:SurvivorRatio 设置新生代中 eden 和 S0/S1 空间比例，默认 -XX:SurvivorRatio=8，Eden : S0 : S1 = 8 : 1 : 1\n-XX:NewRatio 配置年轻代和老年代在堆结构的占比，默认 -XX:NewRatio=2 新生代占1，老年代占2，年轻代占整个堆的 1/3\n-XX:MaxTenuringThreshold 设置垃圾最大年龄。默认是15。-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。如果此值设置为一个较大的值，则年前对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代被回收的概率！\n-XX:MinHeapFreeRatio=40 堆内存使用率小于40时缩减堆内存，xms=xmx时该参数无效，默认值40\n-XX:MaxHeapFreeRatio=70 堆内存使用率大于70时扩张堆内存，xms=xmx时该参数无效，默认值70\n-XX:+UseSerialGC 开启 Serial垃圾收集器（新生代） 新生代使用Serial 老年代则使用SerialOld\n-XX:-UseSerialGC 关闭 Serial垃圾收集器（新生代）\n-XX:+UseParNewGC 开启ParNew垃圾收集器（新生代） 新生代使用功能ParNew 老年代则使用功能CMS\n-XX:-UseParNewGC 关闭ParNew垃圾收集器（新生代）\n-XX:+UseParallelOldGC 开启Parallel Scavenge收集器（新生代）\n-XX:-UseParallelOldGC 关闭Parallel Scavenge收集器（新生代）\n-XX:+UseParallelGC 开启ParallelOl垃圾收集器（老年代）\n-XX:-UseParallelGC 关闭ParallelOl垃圾收集器（老年代）\n-XX:+UseConcMarkSweepGC 开启CMS垃圾收集器（老年代）\n-XX:-UseConcMarkSweepGC 关闭CMS垃圾收集器（老年代）\n-XX:+UseG1GC 开启G1垃圾收集器\n-XX:-UseG1GC 关闭G1垃圾收集器\n-XX:ParallelGCThreads=16 GC并行执行线程数\n-XX:PretenureSizeThreshold=1000000 新生代可容纳的最大对象，大于此值的对象直接会分配到老年代，设置为0则没有限制。 避免在Eden区和Survivor区发生大量的内存复制，该参数只对Serial和ParNew收集器有效，Parallel Scavenge并不认识该参数\n-XX:InitialTenuringThreshol=7 进入老年代最小的GC年龄\n-XX:MaxTenuringThreshold=15 进入老年代最大的GC年龄\n-Xloggc:/home/GCEASY/gc-%t.log 配置GC文件路径\n-XX:+UseGCLogFileRotation 开启滚动生成日志\n-XX:NumberOfGCLogFiles=4 滚动GC日志文件数，默认0，不滚动\n-XX:GCLogFileSize=100k GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发\n-XX:+PrintGCApplicationStoppedTime 打印应用暂停时间\n-XX:+PrintHeapAtGC 每次GC完成后，打印出JVM堆内存每个区域的使用情况\n-XX:+PrintTenuringDistribution 打印存活实例年龄信息\n-XX:+HeapDumpOnOutOfMemoryError 抛出内存溢出错误时导出堆信息到指定文件\n-XX:HeapDumpPath=/data/dump/jvm.dump 设置存溢出错误时导出堆信息到指定文件，文件路径\n-XX:+HeapDumpBeforeFullGC 实现在Full GC前dump\n-XX:+HeapDumpAfterFullGC 实现在Full GC后dump\n-XX:HeapDumpPath=e:\\dump 设置Dump保存的路径\n","date":"2022-08-26T16:31:00Z","permalink":"https://lyoshur.github.io/stack/p/%E5%B8%B8%E7%94%A8jvm%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/","title":"常用JVM配置参数"},{"content":"spring中的AOP 原连接地址 https://www.cnblogs.com/joy99/p/10941543.html\n一、AOP——另一种编程思想 1.1 什么是 AOP AOP （Aspect Orient Programming）,直译过来就是 面向切面编程。AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。 从《Spring实战（第4版）》图书中扒了一张图： 从该图可以很形象地看出，所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。\n1.2 为什么需要 AOP 想象下面的场景，开发中在多个模块间有某段重复的代码，我们通常是怎么处理的？显然，没有人会靠“复制粘贴”吧。在传统的面向过程编程中，我们也会将这段代码，抽象成一个方法，然后在需要的地方分别调用这个方法，这样当这段代码需要修改时，我们只需要改变这个方法就可以了。然而需求总是变化的，有一天，新增了一个需求，需要再多出做修改，我们需要再抽象出一个方法，然后再在需要的地方分别调用这个方法，又或者我们不需要这个方法了，我们还是得删除掉每一处调用该方法的地方。实际上涉及到多个地方具有相同的修改的问题我们都可以通过 AOP 来解决。\n1.3 AOP 实现分类 AOP 要达到的效果是，保证开发者不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。AOP 的本质是由 AOP 框架修改业务组件的多个方法的源代码，看到这其实应该明白了，AOP 其实就是前面一篇文章讲的代理模式的典型应用。 按照 AOP 框架修改源代码的时机，可以将其分为两类：\n静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。 动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。 下面给出常用 AOP 实现比较 如不清楚动态代理的，可参考我前面的一篇文章，有讲解静态代理、JDK动态代理和 CGlib 动态代理。 静态代理和动态代理 https://www.cnblogs.com/joy99/p/10865391.html\n二、AOP 术语 AOP 领域中的特性术语：\n通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。 连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。 切点（PointCut）: 可以插入增强处理的连接点。 切面（Aspect）: 切面是通知和切点的结合。 引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。 织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。 概念看起来总是有点懵，并且上述术语，不同的参考书籍上翻译还不一样，所以需要慢慢在应用中理解。\n三、初步认识 Spring AOP 3.1 Spring AOP 的特点 AOP 框架有很多种，1.3节中介绍了 AOP 框架的实现方式有可能不同， Spring 中的 AOP 是通过动态代理实现的。不同的 AOP 框架支持的连接点也有所区别，例如，AspectJ 和 JBoss,除了支持方法切点，它们还支持字段和构造器的连接点。而 Spring AOP 不能拦截对对象字段的修改，也不支持构造器连接点,我们无法在 Bean 创建时应用通知。\n3.2 Spring AOP 的简单例子 下面先上代码，对着代码说比较好说，看下面这个例子： 这个例子是基于gradle创建的，首先 build.gradle 文件添加依赖：\n1 2 3 dependencies { compile \u0026#39;org.springframework:spring-context:5.0.6.RELEASE\u0026#39; } 首先创建一个接口 IBuy.java\n1 2 3 4 5 package com.sharpcj.aopdemo.test1; public interface IBuy { String buy(); } Boy 和 Gril 两个类分别实现了这个接口： Boy.java\n1 2 3 4 5 6 7 8 9 10 11 12 package com.sharpcj.aopdemo.test1; import org.springframework.stereotype.Component; @Component public class Boy implements IBuy { @Override public String buy() { System.out.println(\u0026#34;男孩买了一个游戏机\u0026#34;); return \u0026#34;游戏机\u0026#34;; } } Girl.java\n1 2 3 4 5 6 7 8 9 10 11 12 package com.sharpcj.aopdemo.test1; import org.springframework.stereotype.Component; @Component public class Girl implements IBuy { @Override public String buy() { System.out.println(\u0026#34;女孩买了一件漂亮的衣服\u0026#34;); return \u0026#34;衣服\u0026#34;; } } 配置文件, AppConfig.java\n1 2 3 4 5 6 7 8 9 package com.sharpcj.aopdemo; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class}) public class AppConfig { } 测试类， AppTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.sharpcj.aopdemo; import com.sharpcj.aopdemo.test1.Boy; import com.sharpcj.aopdemo.test1.Girl; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class AppTest { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); Boy boy = context.getBean(\u0026#34;boy\u0026#34;,Boy.class); Girl girl = (Girl) context.getBean(\u0026#34;girl\u0026#34;); boy.buy(); girl.buy(); } } 运行结果： 这里运用SpringIOC里的自动部署。现在需求改变了，我们需要在男孩和女孩的 buy 方法之前，需要打印出“男孩女孩都买了自己喜欢的东西”。用 Spring AOP 来实现这个需求只需下面几个步骤： 1、 既然用到 Spring AOP, 首先在 build.gralde 文件中引入相关依赖：\n1 2 3 4 dependencies { compile \u0026#39;org.springframework:spring-context:5.0.6.RELEASE\u0026#39; compile \u0026#39;org.springframework:spring-aspects:5.0.6.RELEASE\u0026#39; } 2、 定义一个切面类，BuyAspectJ.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.sharpcj.aopdemo.test1; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Aspect @Component public class BuyAspectJ { @Before(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void haha(){ System.out.println(\u0026#34;男孩女孩都买自己喜欢的东西\u0026#34;); } } 这个类，我们使用了注解 @Component 表明它将作为一个Spring Bean 被装配，使用注解 @Aspect 表示它是一个切面。 类中只有一个方法 haha 我们使用 @Before 这个注解，表示他将在方法执行之前执行。关于这个注解后文再作解释。 参数(\u0026quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026quot;) 声明了切点，表明在该切面的切点是com.sharpcj.aopdemo.test1.Ibuy这个接口中的buy方法。至于为什么这么写，下文再解释。 3、 在配置文件中启用AOP切面功能\n1 2 3 4 5 6 7 8 9 10 11 package com.sharpcj.aopdemo; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; @Configuration @ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class}) @EnableAspectJAutoProxy(proxyTargetClass = true) public class AppConfig { } 我们在配置文件类增加了@EnableAspectJAutoProxy注解，启用了 AOP 功能，参数proxyTargetClass的值设为了 true 。默认值是 false，两者的区别下文再解释。 OK，下面只需测试代码,运行结果如下： 我们看到，结果与我们需求一致，我们并没有修改 Boy 和 Girl 类的 Buy 方法，也没有修改测试类的代码，几乎是完全无侵入式地实现了需求。这就是 AOP 的“神奇”之处。\n四、通过注解配置 Spring AOP 4.1 通过注解声明切点指示器 Spring AOP 所支持的 AspectJ 切点指示器 在spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。\n当我们查看上面展示的这些spring支持的指示器时，注意只有execution指示器是唯一的执行匹配，而其他的指示器都是用于限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器，在此基础上，我们使用其他指示器来限制所匹配的切点。\n下图的切点表达式表示当Instrument的play方法执行时会触发通知。 我们使用execution指示器选择Instrument的play方法，方法表达式以 * 号开始，标识我们不关心方法的返回值类型。然后我们指定了全限定类名和方法名。对于方法参数列表，我们使用 .. 标识切点选择任意的play方法，无论该方法的入参是什么。 多个匹配之间我们可以使用链接符 \u0026amp;\u0026amp;、||、！来表示 “且”、“或”、“非”的关系。但是在使用 XML 文件配置时，这些符号有特殊的含义，所以我们使用 “and”、“or”、“not”来表示。\n举例： 限定该切点仅匹配的包是 com.sharpcj.aopdemo.test1,可以使用 execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) \u0026amp;\u0026amp; within(com.sharpcj.aopdemo.test1.*) 在切点中选择 bean,可以使用 execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) \u0026amp;\u0026amp; bean(girl) 修改 BuyAspectJ.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.sharpcj.aopdemo.test1; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Aspect @Component public class BuyAspectJ { @Before(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) \u0026amp;\u0026amp; within(com.sharpcj.aopdemo.test1.*) \u0026amp;\u0026amp; bean(girl)\u0026#34;) public void hehe(){ System.out.println(\u0026#34;男孩女孩都买自己喜欢的东西\u0026#34;); } } 此时，切面只会对 Girl.java 这个类生效，执行结果： 细心的你，可能发现了，切面中的方法名，已经被我悄悄地从haha改成了hehe，丝毫没有影响结果，说明方法名没有影响。和 Spring IOC 中用 java 配置文件装配 Bean 时，用@Bean 注解修饰的方法名一样，没有影响。\n4.2 通过注解声明 5 种通知类型 Spring AOP 中有 5 中通知类型，分别如下： 下面修改切面类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.sharpcj.aopdemo.test1; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; @Aspect @Component public class BuyAspectJ { @Before(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void hehe() { System.out.println(\u0026#34;before ...\u0026#34;); } @After(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void haha() { System.out.println(\u0026#34;After ...\u0026#34;); } @AfterReturning(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void xixi() { System.out.println(\u0026#34;AfterReturning ...\u0026#34;); } @Around(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void xxx(ProceedingJoinPoint pj) { try { System.out.println(\u0026#34;Around aaa ...\u0026#34;); pj.proceed(); System.out.println(\u0026#34;Around bbb ...\u0026#34;); } catch (Throwable throwable) { throwable.printStackTrace(); } } } 为了方便看效果,我们测试类中，只要 Boy 类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.sharpcj.aopdemo; import com.sharpcj.aopdemo.test1.Boy; import com.sharpcj.aopdemo.test1.Girl; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class AppTest { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); Boy boy = context.getBean(\u0026#34;boy\u0026#34;,Boy.class); Girl girl = (Girl) context.getBean(\u0026#34;girl\u0026#34;); boy.buy(); // girl.buy(); } } 执行结果如下： 结果显而易见。指的注意的是 @Around 修饰的环绕通知类型，是将整个目标方法封装起来了，在使用时，我们传入了 ProceedingJoinPoint 类型的参数，这个对象是必须要有的，并且需要调用 ProceedingJoinPoint 的 proceed() 方法。 如果没有调用 该方法，执行结果为 ：\n1 2 3 4 Around aaa ... Around bbb ... After ... AfterReturning ... 可见，如果不调用该对象的 proceed() 方法，表示原目标方法被阻塞调用，当然也有可能你的实际需求就是这样。\n4.3 通过注解声明切点表达式 如你看到的，上面我们写的多个通知使用了相同的切点表达式，对于像这样频繁出现的相同的表达式，我们可以使用 @Pointcut注解声明切点表达式，然后使用表达式，修改代码如下： BuyAspectJ.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.sharpcj.aopdemo.test1; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; @Aspect @Component public class BuyAspectJ { @Pointcut(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void point(){} @Before(\u0026#34;point()\u0026#34;) public void hehe() { System.out.println(\u0026#34;before ...\u0026#34;); } @After(\u0026#34;point()\u0026#34;) public void haha() { System.out.println(\u0026#34;After ...\u0026#34;); } @AfterReturning(\u0026#34;point()\u0026#34;) public void xixi() { System.out.println(\u0026#34;AfterReturning ...\u0026#34;); } @Around(\u0026#34;point()\u0026#34;) public void xxx(ProceedingJoinPoint pj) { try { System.out.println(\u0026#34;Around aaa ...\u0026#34;); pj.proceed(); System.out.println(\u0026#34;Around bbb ...\u0026#34;); } catch (Throwable throwable) { throwable.printStackTrace(); } } } 程序运行结果没有变化。 这里，我们使用\n1 2 @Pointcut(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void point(){} 声明了一个切点表达式，该方法 point 的内容并不重要，方法名也不重要，实际上它只是作为一个标识，供通知使用。\n4.4 通过注解处理通知中的参数 上面的例子，我们要进行增强处理的目标方法没有参数，下面我们来说说有参数的情况，并且在增强处理中使用该参数。 下面我们给接口增加一个参数，表示购买所花的金钱。通过AOP 增强处理，如果女孩买衣服超过了 68 元，就可以赠送一双袜子。 更改代码如下： IBuy.java\n1 2 3 4 5 package com.sharpcj.aopdemo.test1; public interface IBuy { String buy(double price); } Girl.java\n1 2 3 4 5 6 7 8 9 10 11 12 package com.sharpcj.aopdemo.test1; import org.springframework.stereotype.Component; @Component public class Girl implements IBuy { @Override public String buy(double price) { System.out.println(String.format(\u0026#34;女孩花了%s元买了一件漂亮的衣服\u0026#34;, price)); return \u0026#34;衣服\u0026#34;; } } Boy.java\n1 2 3 4 5 6 7 8 9 10 11 12 package com.sharpcj.aopdemo.test1; import org.springframework.stereotype.Component; @Component public class Boy implements IBuy { @Override public String buy(double price) { System.out.println(String.format(\u0026#34;男孩花了%s元买了一个游戏机\u0026#34;, price)); return \u0026#34;游戏机\u0026#34;; } } 再看 BuyAspectJ 类，我们将之前的通知都注释掉。用一个环绕通知来实现这个功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package com.sharpcj.aopdemo.test1; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; @Aspect @Component public class BuyAspectJ { /* @Pointcut(\u0026#34;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))\u0026#34;) public void point(){} @Before(\u0026#34;point()\u0026#34;) public void hehe() { System.out.println(\u0026#34;before ...\u0026#34;); } @After(\u0026#34;point()\u0026#34;) public void haha() { System.out.println(\u0026#34;After ...\u0026#34;); } @AfterReturning(\u0026#34;point()\u0026#34;) public void xixi() { System.out.println(\u0026#34;AfterReturning ...\u0026#34;); } @Around(\u0026#34;point()\u0026#34;) public void xxx(ProceedingJoinPoint pj) { try { System.out.println(\u0026#34;Around aaa ...\u0026#34;); pj.proceed(); System.out.println(\u0026#34;Around bbb ...\u0026#34;); } catch (Throwable throwable) { throwable.printStackTrace(); } } */ @Pointcut(\u0026#34;execution(String com.sharpcj.aopdemo.test1.IBuy.buy(double)) \u0026amp;\u0026amp; args(price) \u0026amp;\u0026amp; bean(girl)\u0026#34;) public void gif(double price) { } @Around(\u0026#34;gif(price)\u0026#34;) public String hehe(ProceedingJoinPoint pj, double price){ try { pj.proceed(); if (price \u0026gt; 68) { System.out.println(\u0026#34;女孩买衣服超过了68元，赠送一双袜子\u0026#34;); return \u0026#34;衣服和袜子\u0026#34;; } } catch (Throwable throwable) { throwable.printStackTrace(); } return \u0026#34;衣服\u0026#34;; } } 前文提到，当不关心方法返回值的时候，我们在编写切点指示器的时候使用了 * ， 当不关心方法参数的时候，我们使用了 ..。现在如果我们需要传入参数，并且有返回值的时候，则需要使用对应的类型。在编写通知的时候，我们也需要声明对应的返回值类型和参数类型。\n测试类：AppTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.sharpcj.aopdemo; import com.sharpcj.aopdemo.test1.Boy; import com.sharpcj.aopdemo.test1.Girl; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class AppTest { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); Boy boy = context.getBean(\u0026#34;boy\u0026#34;,Boy.class); Girl girl = (Girl) context.getBean(\u0026#34;girl\u0026#34;); String boyBought = boy.buy(35); String girlBought = girl.buy(99.8); System.out.println(\u0026#34;男孩买到了：\u0026#34; + boyBought); System.out.println(\u0026#34;女孩买到了：\u0026#34; + girlBought); } } 测试结果： 可以看到，我们成功通过 AOP 实现了需求，并将结果打印了出来。\n4.5 通过注解配置织入的方式 前面还有一个遗留问题，在配置文件中，我们用注解 @EnableAspectJAutoProxy() 启用Spring AOP 的时候，我们给参数 proxyTargetClass 赋值为 true,如果我们不写参数，默认为 false。这个时候运行程序，程序抛出异常 这是一个强制类型转换异常。为什么会抛出这个异常呢？或许已经能够想到，这跟Spring AOP 动态代理的机制有关，这个 proxyTargetClass 参数决定了代理的机制。当这个参数为 false 时， 通过jdk的基于接口的方式进行织入，这时候代理生成的是一个接口对象，将这个接口对象强制转换为实现该接口的一个类，自然就抛出了上述类型转换异常。 反之，proxyTargetClass 为 true，则会使用 cglib 的动态代理方式。这种方式的缺点是拓展类的方法被final修饰时，无法进行织入。 测试一下，我们将 proxyTargetClass 参数设为 true，同时将 Girl.java 的 Buy 方法用 final 修饰： AppConfig.java\n1 2 3 4 5 6 7 8 9 10 11 package com.sharpcj.aopdemo; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; @Configuration @ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class}) @EnableAspectJAutoProxy(proxyTargetClass = true) public class AppConfig { } Girl.java\n1 2 3 4 5 6 7 8 9 10 11 12 package com.sharpcj.aopdemo.test1; import org.springframework.stereotype.Component; @Component public class Girl implements IBuy { @Override public final String buy(double price) { System.out.println(String.format(\u0026#34;女孩花了%s元买了一件漂亮的衣服\u0026#34;, price)); return \u0026#34;衣服\u0026#34;; } } 此时运行结果： 可以看到，我们的切面并没有织入生效。\n五、通过 XML 配置文件声明切面 前面的示例中，我们已经展示了如何通过注解配置去声明切面，下面我们看看如何在 XML 文件中声明切面。下面先列出 XML 中声明 AOP 的常用元素： 我们依然可以使用 \u0026lt;aop:aspectj-autoproxy\u0026gt; 元素，他能够自动代理AspectJ注解的通知类。\n5.1 XML 配置文件中切点指示器 在XML配置文件中，切点指示器表达式与通过注解配置的写法基本一致，区别前面有提到，即XML文件中需要使用 “and”、“or”、“not”来表示 “且”、“或”、“非”的关系。\n5.2 XML 文件配置 AOP 实例 下面我们不使用任何注解改造上面的例子： BuyAspectJ.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.sharpcj.aopdemo.test2; import org.aspectj.lang.ProceedingJoinPoint; public class BuyAspectJ { public void hehe() { System.out.println(\u0026#34;before ...\u0026#34;); } public void haha() { System.out.println(\u0026#34;After ...\u0026#34;); } public void xixi() { System.out.println(\u0026#34;AfterReturning ...\u0026#34;); } public void xxx(ProceedingJoinPoint pj) { try { System.out.println(\u0026#34;Around aaa ...\u0026#34;); pj.proceed(); System.out.println(\u0026#34;Around bbb ...\u0026#34;); } catch (Throwable throwable) { throwable.printStackTrace(); } } } 在 Resource 目录下新建一个配置文件 aopdemo.xml ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;boy\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.Boy\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;girl\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.Girl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;buyAspectJ\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.BuyAspectJ\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config proxy-target-class=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;aop:aspect id=\u0026#34;qiemian\u0026#34; ref=\u0026#34;buyAspectJ\u0026#34;\u0026gt; \u0026lt;aop:before pointcut=\u0026#34;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))\u0026#34; method=\u0026#34;hehe\u0026#34;/\u0026gt; \u0026lt;aop:after pointcut=\u0026#34;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))\u0026#34; method=\u0026#34;haha\u0026#34;/\u0026gt; \u0026lt;aop:after-returning pointcut=\u0026#34;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))\u0026#34; method=\u0026#34;xixi\u0026#34;/\u0026gt; \u0026lt;aop:around pointcut=\u0026#34;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))\u0026#34; method=\u0026#34;xxx\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 这里分别定义了一个切面，里面包含四种类型的通知。 测试文件中，使用\n1 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;aopdemo.xml\u0026#34;); 来获取 ApplicationContext，其它代码不变。\n5.3 XML 文件配置声明切点 对于频繁重复使用的切点表达式，我们也可以声明成切点。 配置文件如下：aopdemo.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;boy\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.Boy\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;girl\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.Girl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;buyAspectJ\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.BuyAspectJ\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config proxy-target-class=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;apoint\u0026#34; expression=\u0026#34;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))\u0026#34;/\u0026gt; \u0026lt;aop:aspect id=\u0026#34;qiemian\u0026#34; ref=\u0026#34;buyAspectJ\u0026#34;\u0026gt; \u0026lt;aop:before pointcut-ref=\u0026#34;apoint\u0026#34; method=\u0026#34;hehe\u0026#34;/\u0026gt; \u0026lt;aop:after pointcut-ref=\u0026#34;apoint\u0026#34; method=\u0026#34;haha\u0026#34;/\u0026gt; \u0026lt;aop:after-returning pointcut-ref=\u0026#34;apoint\u0026#34; method=\u0026#34;xixi\u0026#34;/\u0026gt; \u0026lt;aop:around pointcut-ref=\u0026#34;apoint\u0026#34; method=\u0026#34;xxx\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 5.4 XML文件配置为通知传递参数 BuyAspectJ.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.sharpcj.aopdemo.test2; import org.aspectj.lang.ProceedingJoinPoint; public class BuyAspectJ { public String hehe(ProceedingJoinPoint pj, double price){ try { pj.proceed(); if (price \u0026gt; 68) { System.out.println(\u0026#34;女孩买衣服超过了68元，赠送一双袜子\u0026#34;); return \u0026#34;衣服和袜子\u0026#34;; } } catch (Throwable throwable) { throwable.printStackTrace(); } return \u0026#34;衣服\u0026#34;; } } aopdemo.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;boy\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.Boy\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;girl\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.Girl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;buyAspectJ\u0026#34; class=\u0026#34;com.sharpcj.aopdemo.test2.BuyAspectJ\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;aop:config proxy-target-class=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;apoint\u0026#34; expression=\u0026#34;execution(String com.sharpcj.aopdemo.test2.IBuy.buy(double)) and args(price) and bean(girl)\u0026#34;/\u0026gt; \u0026lt;aop:aspect id=\u0026#34;qiemian\u0026#34; ref=\u0026#34;buyAspectJ\u0026#34;\u0026gt; \u0026lt;aop:around pointcut-ref=\u0026#34;apoint\u0026#34; method=\u0026#34;hehe\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 5.5 Xml 文件配置织入的方式 同注解配置类似, CGlib 代理方式：\n1 \u0026lt;aop:config proxy-target-class=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/aop:config\u0026gt; JDK 代理方式：\n1 \u0026lt;aop:config proxy-target-class=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;/aop:config\u0026gt; 六、总结 本文简单记录了 AOP 的编程思想，然后介绍了 Spring 中 AOP 的相关概念，以及通过注解方式和XML配置文件两种方式使用 Spring AOP进行编程。 相比于 AspectJ 的面向切面编程，Spring AOP 也有一些局限性，但是已经可以解决开发中的绝大多数问题了，如果确实遇到了 Spring AOP 解决不了的场景，我们依然可以在 Spring 中使用 AspectJ 来解决。\n","date":"2022-08-26T10:41:00Z","permalink":"https://lyoshur.github.io/stack/p/spring%E4%B8%AD%E7%9A%84aop/","title":"spring中的AOP"},{"content":"常见的限流算法 限流顾名思义，就是对请求或并发数进行限制；通过对一个时间窗口内的请求量进行限制来保障系统的正常运行。如果我们的服务资源有限、处理能力有限，就需要对调用我们服务的上游请求进行限制，以防止自身服务由于资源耗尽而停止服务。\n1 固定窗口算法（计数器算法）（Fixed Window） 固定窗口算法又叫计数器算法，是一种简单方便的限流算法。主要通过一个支持原子操作的计数器来累计 1 秒内的请求次数，当 1 秒内计数达到限流阈值时触发拒绝策略。每过 1 秒，计数器重置为 0 开始重新计数。\n【note】思路就是每收到一个请求，计数器加1 ，同时有一个专用的线程，按每秒将计数器归零。\n2 滑动窗口算法（Rolling Window 或 Sliding Window） 【note】滑动窗口是对于固定窗口的改进，固定窗口算法当达到一个时间周期时，都会将计数器归零。而滑动窗口的大致思路是，每过半个周期或更细的时间单位，将窗口前移。然后统计当前窗口的计数器。相比固定窗口算法，不会每次都简单的将计数器归零，有了更平滑的限制策略。\n3 漏桶算法（Leaky Bucket） 【note】漏桶是一个可以容纳请求的容器，当收到一个请求时，如果桶内有空间，则将请求置入桶内，等待处理。如果桶内空间不足，则直接触发限流策略。所以瞬间能接受的请求量是桶容量上限，当桶满后，最大处理速度是漏桶的漏出速度。\n4 令牌桶算法（Token Bucket） 令牌桶算法同样是实现限流是一种常见的思路，最为常用的 Google 的 Java 开发工具包 Guava 中的限流工具类 RateLimiter 就是令牌桶的一个实现。\n【note】令牌桶是一个容纳令牌的容器，有一个线程以恒定速率向令牌桶中放置令牌。相比漏桶，令牌桶在刚启动时，由于桶内没有令牌，会有一个慢启动的过程。然后令牌桶才能到达最大的容量上限。\n瞬间能够接受的请求，是当前令牌桶内令牌的数量。当令牌消耗殆尽时，最大处理速度是令牌的生产速度\n5 漏桶对比令牌桶 当大量请求时，漏桶会被装满，而令牌桶会被消耗光。 当大量请求时，漏桶新接受请求的速度，等于漏桶的漏出速度，也就是处理速度。这里会以最大处理能力进行处理。而令牌桶会以恒定的令牌放置速度处理，当令牌生产速度过小时，会产生性能浪费。而过大时会导致限流无效。 令牌桶如果初始化令牌数为0，会有一个慢启动的过程。而漏桶不会。 ","date":"2022-08-26T09:24:00Z","permalink":"https://lyoshur.github.io/stack/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/","title":"常见的限流算法"},{"content":"spring事务 Spring 之中除了设置事务的「隔离级别」之外，还可以额外配置事务的「传播特性」。\nSpring支持以下7种事务传播行为：\npropagation-required：支持当前事务，如果有就加入当前事务中；如果当前方法没有事务，就新建一个事务。\n【note】required 必须的，所以会加入一个事务，加入不了就新建。\npropagation-supports：支持当前事务，如果有就加入当前事务中，如果当前方法没有事务，就以非事务的方法运行。\n【note】supports 支持，有事务支持加入，没有就算了\npropagation-mandatory：支持当前事务，如果有就加入到当前事务，如果房前没有事务，就抛出异常。\n【note】mandatory 强制，当前有事务就算了，要是没有就哭给你看\npropagation-requires_new：新建事务，如果当前存在事务，就把当前事务挂起，如果当前方法不存在事务，就新建事务\n【note】就是要一个新的，旧的不要\npropagation-not-supported：以非事务的方法运行，如果当前方法有事务，则挂起当前事务，如果当前没有事务，则已非事务的方法运行\n【note】不管有没有，我都不用\npropagation-never：以非事务方式运行，如果当前方法存在事务，则抛出异常。如果不存在，就以非事务的方式运行\n【note】我不要，给就哭\npropagation-nested：如果当前方法有事务,则在嵌套事务内执行;如果当前方法没有事务，就新建一个事务\n【note】nested 嵌套\n【重要】！！！！在同一个类中，一个方法调用另外一个有注解（比如@Async，@Transational）的方法，注解是不会生效的\n在一个Service内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务\n","date":"2022-08-25T14:41:00Z","permalink":"https://lyoshur.github.io/stack/p/spring%E4%BA%8B%E5%8A%A1/","title":"spring事务"},{"content":"spring中的异步方法 @Async注解可以使被修饰的方法成为异步方法，曾经看到一个文章说，异步方法让编程提升了一个台阶，确实在实际项目中，异步方法可以很大的提高用户体验，使用效率，不再是那个一个依赖另一个串行任务，在前一个任务不知道什么时候完成时在那傻等，然而彼此间没有什么强依赖关系。\n1 配置异步编程 1 2 3 4 5 6 7 8 9 10 11 12 13 // 基于Java配置的启用方式： @Configuration @EnableAsync public class SpringAsyncConfig { ... } // Spring boot启用： @EnableAsync @EnableTransactionManagement public class SettlementApplication { public static void main(String[] args) { SpringApplication.run(SettlementApplication.class, args); } } 2 使用@Async方法来处理问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class DeviceProcessServiceImpl impleme nts DeviceProcessService { @Autowired private DeviceRpcService deviceRpcService; @Async(\u0026#34;taskExecutor\u0026#34;) @Override public Future\u0026lt;Map\u0026lt;Long, List\u0026lt;ProcessDTO\u0026gt;\u0026gt;\u0026gt; queryDeviceProcessAbilities(List\u0026lt;BindDeviceDO\u0026gt; bindDevices) { if (CollectionUtils.isEmpty(bindDevices)) { return new AsyncResult\u0026lt;\u0026gt;(Maps.newHashMap()); } List\u0026lt;Long\u0026gt; deviceIds = bindDevices.stream().map(BindDeviceDO::getDeviceId).collect(Collectors.toList()); List\u0026lt;DeviceInstanceWithProcessResp\u0026gt; devices = deviceRpcService.getDeviceProcessAbility(deviceIds); Map\u0026lt;Long, List\u0026lt;ProcessDTO\u0026gt;\u0026gt; deviceAbilityMap = Maps.newHashMap(); ... return new AsyncResult\u0026lt;\u0026gt;(deviceAbilityMap); } } 注意返回值为Future\n原文章中，提到加了注解但是不生效的问题，但实际上@Async注解和事务注解一样，Spring在生成动态代理类时，当入口方法没有异步注解，通过一个同步方法去调用一个同类的异步方法，是无法使这个方法异步执行的。\n","date":"2022-08-25T14:41:00Z","permalink":"https://lyoshur.github.io/stack/p/spring%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/","title":"spring中的异步方法"},{"content":"mysql事务 1 事务的ACID 与数据库的事务同时为大众熟知的是ACID。即数据库的原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)。就像应用内为了线程之间的互斥，线程安全等，需要做大量的工作，数据库为了 ACID，也做了许多的工作。\n原子性(Atomicity)\n一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n一致性(Consistency)\n在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n隔离性(Isolation)\n隔离性还有其他的称呼，如并发控制（concurrency control）、可串行化（serializability）、锁（locking）。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。当前数据库系统中都提供了一种粒度锁（granular lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。\n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括:\n读未提交（Read uncommitted） 读提交（read committed） 可重复读（repeatable read） 串行化（Serializable） 持久性(Durability)\nmysql默认的事务隔离级别是 可重复读（repeatable read）。\n2 事务的分类 从理论的角度来说，可以把事务分为一下几种类型\n扁平事务（flat transactions）\n带有保存点的扁平事务（flat transactions with savepoints）\n链事务（chained transactions）\n嵌套事务（nested transactions）\n分布式事务（distributed transactions）\n2.1 扁平事务 对于扁平事务来说，其隐式地设置了一个保存点，但是在整个事务中，只有这一个保存点，回滚只能回滚到事务开始时的状态。保存点用SAVE WORK函数来建立，通知系统记录当前的处理状态。\n2.2 带有保存点的扁平事务 允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。\n2.3 链事务 链事务可视为保存点模式的一个变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为其保存点是易失的（volatile），而非持久的（persistent）。这意味着当恢复保存点时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。\n链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。\n2.4 嵌套事务 嵌套事务是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。\n嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。\n处在叶节点的事务是扁平事务，但是每个子事务从根到叶节点的距离可以是不同的。\n位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱（predecessor）称为父事务（parent），事务的下一层称为儿子事务（child）。\n子事务既可以提交也可以回滚，但是它的提交操作并不马上生效，除非由其父事务提交。因此可以推论出，任何子事务都在顶层事务提交后才真正提交。\n树中的任意一个事务的回滚会引起它的所有子事务一同回滚。故子事务仅保留A、C、I特性，不具有D特性。\n在Moss的理论中，实际的工作交由叶节点来完成，即只有叶节点的事务才能访问数据库、发送消息、获取其他类型的资源。而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务\n2.5 分布式事务 分布式事务通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。\n3 事务控制语句 在MySQL命令行的默认设置下，事务都是自动提交（auto commit）的，即执行SQL语句后就会马上执行COMMIT操作。因此要显式地开启一个事务须使用命令BEGIN和START TRANSACTION，或者执行命令SET AUTOCOMMIT=0，以禁用当前会话的自动提交。\nSTART TRANSACTION | BEGIN：显式地开启一个事务。\nCOMMIT：要想使用这个语句的最简形式，只需发出COMMIT。也可以更详细一些，写为COMMIT WORK，不过这二者几乎是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的。\nROLLBACK：要使用这个语句的最简形式，只需发出ROLLBACK。同样地，也可以写为ROLLBACK WORK，但是二者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。\nSAVEPOINT identifier：SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。\nRELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这句语句时，会抛出一个异常。\nROLLBACK TO [SAVEPOINT] identifier ：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。例如可以发出两条UPDATE语句，后面跟一个SAVEPOINT，然后又是两条DELETE语句。如果执行DELETE语句期间出现了某种异常情况，而且捕获到这个异常，并发出ROLLBACK TO SAVEPOINT命令，事务就会回滚到指定的SAVEPOINT，撤销DELETE完成的所有工作，而UPDATE语句完成的工作不受影响。\nSET TRANSACTION：这个语句用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。\nSTART TRANSACTION和BEGIN语句都可以在MySQL命令行下显式地开启一个事务。但是在存储过程中，MySQL数据库的分析器会自动将BEGIN识别为BEGIN \u0026hellip;END，因此在存储过程中只能使用START TRANSACTION语句来开启一个事务。\nCOMMIT和COMMIT WORK语句基本上是一致的，都用来提交事务。不同之处在于COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。用户可以通过参数completion_type来进行控制:\n该参数为0，表示没有任何操作。在这种设置下，COMMIT和COMMIT WORK是完全等价的。\n当参数completion_type的值为1时，COMMIT WORK等同于COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务\n参数completion_type为2时，COMMIT WORK等同于COMMIT AND RELEASE。当事务提交后会自动断开与服务器的连接\n4 事务的隔离级别详解 ISO和ANSI SQL标准制定了四种事务隔离级别的标准，但是很少有数据库厂商遵循这些标准。比如Oracle数据库就不支持READ UNCOMMITTED和REPEATABLE READ的事务隔离级别。\nREAD UNCOMMITTED\nREAD UNCOMMITTED被称为浏览访问（browse access），仅仅只是对事务而言的\nREAD COMMITTED\nREAD COMMITTED被称为游标稳定（cursor stability）\nREPEATABLE READ\nREPEATABLE READ是2.9999°的隔离，没有幻读的保护\nSERIALIZABLE\nSERIALIZABLE被称为隔离，或3°的隔离。SQL和SQL2标准的默认事务隔离级别是SERIALIZABLE\nInnoDB存储引擎默认的支持隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock的锁算法，因此避免了幻读的产生。所以说，InnoDB存储引擎在默认的REPEATABLE READ事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。\n5 分布式事务编程 InnoDB存储引擎提供了对于XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源 （transactional resources） 参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。\nXA事务允许不同数据库之间的分布式事务，如一台服务器是MySQL数据库的，另一台是Oracle数据库的，可能还有一台服务器是SQL Server数据库的，只要参与到全局事务中的每个节点都支持XA事务即可。\nXA事务由一个或多个资源管理器（resource manager）、一个事务管理器（transaction manager）以及一个应用程序（application program）组成。\n资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。\n事务管理器：协调参与全局事务中的各个事务。需要和参与到全局事务中的所有资源管理器进行通信。\n应用程序：定义事务的边界，指定全局事务中的操作。\n在MySQL数据库的分布式事务中，资源管理器就是MySQL数据库，事务管理器为连接到MySQL服务器的客户端。\n分布式事务使用两段式提交（two-phase commit）的方式。在第一个阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好提交了。第二个阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。可见与本地事务不同的是，需要多一次的PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或ROLLBACK操作。\n","date":"2022-08-25T13:36:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySQL事务"},{"content":"Java并发编程 1 死锁的产生必须具备以下四个条件： 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。\n请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。\n不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。\n环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。\n要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但是学过操作系统的读者应该都知道，目前只有请求并持有和环路等待条件是可以被破坏的。\n2 JMM Java内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工作内存中的变量。\n3 锁 乐观锁 乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。\n悲观锁 排他锁 排他锁，又称为写锁、独占锁，是一种基本的锁类型。\n独占锁 共享锁 公平锁 非公平锁 自旋锁 由于Java中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取（默认次数是10，可以使用-XX:PreBlockSpinsh参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU时间换取线程阻塞与调度的开销，但是很有可能这些CPU时间白白浪费了。\n可重入锁 当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（在高级篇中我们将知道，严格来说是有限次数）地进入被该锁锁住的代码。\n4 LongAdder volatile解决了多线程内存不可见问题，对于一读多写，是可以解决变量同步问题的。但是对于一写多读同样无法解决线程安全问题。\n如果是JDK8推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。\n该类通过内部cells数组分担了高并发下多线程同时对一个原子变量进行更新时的竞争量，让多个线程可以同时对cells数组里面的元素进行并行的更新操作。另外，数组元素Cell使用@sun.misc.Contended注解进行修饰，这避免了cells数组内多个原子变量被放入同一个缓存行，也就是避免了伪共享，这对性能也是一个提升。\n5 LongAccumulator LongAdder类是LongAccumulator的一个特例，LongAccumulator比LongAdder的功能更强大。例如下面的构造函数，其中accumulatorFunction是一个双目运算器接口，其根据输入的两个参数返回一个计算值，identity则是LongAccumulator累加器的初始值。\n6 CopyOnWriteArrayList CopyOnWriteArrayList使用写时复制的策略来保证list的一致性，而获取—修改—写入三步操作并不是原子性的，所以在增删改的过程中都使用了独占锁，来保证在某个时间只有一个线程能对list数组进行修改。另外CopyOnWriteArrayList提供了弱一致性的迭代器，从而保证在获取迭代器后，其他线程对list的修改是不可见的，迭代器遍历的数组是一个快照。另外，CopyOnWriteArraySet的底层就是使用它实现的，感兴趣的读者可以查阅相关源码。\n7 LockSupport ","date":"2022-08-22T11:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","title":"Java并发编程"},{"content":"设计模式设计原则 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 类应该对拓展开放，对修改关闭。 要依赖抽象，不要依赖具体类。 最少知识原则：只和你的密友谈话。 好莱坞原则，别调用我们，我们会调用你。 一个类应该只有一个引起变化的原因。 ","date":"2022-08-12T14:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","title":"设计模式设计原则"},{"content":"JDK工具一览表 工具名称 功能描述 appletviewer.exe 用于运行并浏览applet小程序。 apt.exe 注解处理工具(Annotation Processing Tool)，主要用于注解处理。 extcheck.exe 扩展检测工具，主要用于检测指定jar文件与当前已安装的Java SDK扩展之间是否存在版本冲突。 idlj.exe IDL转Java编译器(IDL-to-Java Compiler)，用于为指定的IDL文件生成Java绑定。IDL意即接口定义语言(Interface Definition Language)。 jabswitch.exe Java访问桥开关(Java Access Bridge switch)，用于启用/禁用Java访问桥。Java访问桥内置于Java 7 Update 6及以上版本，主要为Windows系统平台提供一套访问Java应用的API。 jar.exe jar文件管理工具，主要用于打包压缩、解压jar文件。 jarsigner.exe jar密匙签名工具。 java.exe Java运行工具，用于运行.class字节码文件或.jar文件。 javac.exe Java编译工具(Java Compiler)，用于编译Java源代码文件。 javadoc.exe Java文档工具，主要用于根据Java源代码中的注释信息生成HTML格式的API帮助文档。 javafxpackager.exe JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务。 javah.exe Java头文件工具，用于根据Java类生成C/C++头文件和源文件(主要用于JNI开发领域)。 javap.exe Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件。 java-rmi.exe Java远程方法调用(Java Remote Method Invocation)工具，主要用于在客户机上调用远程服务器上的对象。 javaw.exe Java运行工具，用于运行.class字节码文件或.jar文件，但不会显示控制台输出信息，适用于运行图形化程序。 javaws.exe Java Web Start，使您可以从Web下载和运行Java应用程序，下载、安装、运行、更新Java应用程序都非常简单方便。 jcmd.exe Java 命令行(Java Command)，用于向正在运行的JVM发送诊断命令请求。 jconsole.exe 图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息。 jdb.exe Java调试工具(Java Debugger)，主要用于对Java应用进行断点调试。 jhat.exe Java堆分析工具(Java Heap Analysis Tool)，用于分析Java堆内存中的对象信息。 jinfo.exe Java配置信息工具(Java Configuration Information)，用于打印指定Java进程、核心文件或远程调试服务器的配置信息。 jmap.exe Java内存映射工具(Java Memory Map)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节。 jmc.exe Java任务控制工具(Java Mission Control)，主要用于HotSpot JVM的生产时间监测、分析、诊断。 jps.exe JVM进程状态工具(JVM Process Status Tool)，用于显示目标系统上的HotSpot JVM的Java进程信息。 jrunscript.exe Java命令行脚本外壳工具(command line script shell)，主要用于解释执行javascript、groovy、ruby等脚本语言。 jsadebugd.exe Java可用性代理调试守护进程(Java Serviceability Agent Debug Daemon)，主要用于附加到指定的Java进程、核心文件，或充当一个调试服务器。 jstack.exe Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息。 jstat.exe JVM统计监测工具(JVM Statistics Monitoring Tool)，主要用于监测并显示JVM的性能统计信息。 jstatd.exe jstatd(VM jstatd Daemon)工具是一个RMI服务器应用，用于监测HotSpot JVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上。 jvisualvm.exe JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息。 keytool.exe 密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等。 kinit.exe 主要用于获取或缓存Kerberos协议的票据授权票据。 klist.exe 允许用户查看本地凭据缓存和密钥表中的条目(用于Kerberos协议)。 ktab.exe Kerberos密钥表管理工具，允许用户管理存储于本地密钥表中的主要名称和服务密钥。 native2ascii.exe 本地编码到ASCII编码的转换器(Native-to-ASCII Converter)，用于\u0026quot;任意受支持的字符编码\u0026quot;和与之对应的\u0026quot;ASCII编码和(或)Unicode转义\u0026quot;之间的相互转换。 orbd.exe 对象请求代理守护进程(Object Request Broker Daemon)，它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象。 pack200.exe JAR文件打包压缩工具，它可以利用Java类特有的结构，对普通JAR文件进行高效压缩，以便于能够更快地进行网络传输。 packager.exe 这是微软提供的对象包装程序，用于对象安装包。 policytool.exe 策略工具，用于管理用户策略文件(.java.policy)。 rmic.exe Java RMI 编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMG IDL。 rmid.exe Java RMI 激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象。 rmiregistry.exe Java 远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表。 schemagen.exe XML schema生成器，用于生成XML schema文件。 serialver.exe 序列版本命令，用于生成并返回serialVersionUID。 servertool.exe Java IDL 服务器工具，用于注册、取消注册、启动和终止持久化的服务器。 tnameserv.exe Java IDL瞬时命名服务。 unpack200.exe JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件。 wsgen.exe XML Web Service 2.0的Java API，生成用于JAX-WS Web Service的JAX-WS便携式产物。 wsimport.exe XML Web Service 2.0的Java API，主要用于根据服务端发布的wsdl文件生成客户端存根及框架 xjc.exe 主要用于根据XML schema文件生成对应的Java类。 ","date":"2022-08-11T15:31:00Z","permalink":"https://lyoshur.github.io/stack/p/jdk%E5%B7%A5%E5%85%B7%E4%B8%80%E8%A7%88%E8%A1%A8/","title":"JDK工具一览表"},{"content":"jconsole使用说明 JConsole 是一个内置 Java 性能分析器，可以从命令行（直接输入jconsole）或在 GUI shell （jdk\\bin下打开）中运行。\n它用于对JVM中内存，线程和类等的监控。可使用JTop插件。它可以监控本地的jvm，也可以监控远程的jvm，也可以同时监控几个jvm。\n这款工具的好处在于，占用系统资源少，而且结合Jstat，可以有效监控到java内存的变动情况，以及引起变动的原因。在项目追踪内存泄露问题时，很实用。\n1 概览 以图标的形式显示堆内存使用量，线程使用量，类加载数量，以及CPU占用率\n2 内存 这里比jvisualvm实时性要高一点，并且可以通过切换，来展示堆内存、非堆内存、PS Old Gen、PS Eden Space、PS Survivor Space、Metaspace、Code Cache、Compressed Class Space。等内存的使用图标。\n3 线程 这里能显示活动线程数量以及峰值线程数量的变化图表。\n下面的线程框，能查看每个线程的线程名称，以及线程的堆栈跟踪。还有一个按钮来支持死锁检测。\n4 类 类页卡主要展示已加装当前类数量、已加载类总数、已卸载类总数等类相关信息\n5 VM概要 vm概要主要显示堆信息、虚拟机信息、类路径等相关信息\n6 MBean JMX把所有被管理的资源都成为MBean（ManagedBean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如RMI或HTTP。\n6.1 spring boot程序接入Mbean 在启动程序添加注解@EnableMBeanExport，告知spring自动注册MBean\n在Controller上，添加@ManagedResource注解 （objectName = \u0026ldquo;company:name = testName\u0026rdquo;, descriptiopn = \u0026ldquo;描述信息\u0026rdquo;）\n在值添加 @ManagedAttribute（descriptiopn = \u0026ldquo;描述信息\u0026rdquo;）\n在方法上添加@ManagedOperation\n@ManagedOperationParameter（name= \u0026ldquo;name\u0026rdquo;, descriptiopn = \u0026ldquo;描述信息\u0026rdquo;）\n7 注意事项 想监控JAVA程序需要在程序启动时，添加JMX相关参数。如果是本地连接，可以不加\n","date":"2022-08-11T13:31:00Z","permalink":"https://lyoshur.github.io/stack/p/jconsole%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"jconsole使用说明"},{"content":"jvisualvm使用说明 JVisualVM是JDK自带的性能检测工具，路径在%JAVA_HOME%/bin下面。双击打开\n在本地页卡下是，本地启动的java程序列表，同时能够包含显示Pid\n点击某一个程序，能够从 概述、监视、线程、抽样器、Profiler 几个防线显示应用程序的信息\n概述 概述下主要包括应用程序的PID、主类、以及JVM相关的一些参数。系统属性这里能够显示一些java、spring、tomcat等相关属性信息\n监视 监视页卡主要显示CPU使用情况，堆内存使用情况，装载的类数量、以及线程活跃情况\n线程 线程页卡主要显示线程的活跃情况，根据不同颜色包含运行、休眠、等待、驻留、监视等几个不同的状态。\n这里可以使用右上角的线程Dump,来获取每个线程的调用栈信息。\n抽样器 抽样器是这个工具比较核心的部分，主要分为CPU抽样和内存抽样。\nCPU抽样能按照CPU样例显示每个java方法（这里能看到自定义的方法名）的CPU执行时间，可以通过页卡切换为每个线程的CPU占用时间。这里有些线程是类似Thread-22这种线程名称，如果需要定位到具体某个类启动的方法，可以结合线程的线程Dump来定位具体的线程。\n内存抽样能按照堆内存中的不同变量类型，显示内存占用，不过因为实现原理的原因，比如说 String的底层是 []char，显示的结果并不是太直观。点击每个线程分配页卡，能看到每个线程的内存分配用量。\n内存抽样还可以手动点击执行GC，来测试内存回收结果。点击堆Dump，可以导出展示当前堆内存结果，类似String之类比较简单的内存，能看到一些简单值。\nProfiler 暂时不知道有什么用，点击后显示正在连接到目标VM就卡死了 = =、\n","date":"2022-08-11T13:31:00Z","permalink":"https://lyoshur.github.io/stack/p/jvisualvm%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"jvisualvm使用说明"},{"content":"3 进行简单数据查询 1 2 # 获取Service 参数为数据库内的表名 test_service = factory.get_service(\u0026#34;tb_test\u0026#34;) 获取对应数据库表的service后，能够使用内置的常用增删改查方法，对数据库进行操作\n3.1查询列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 查询当前service的列表,其中参数为空字典，表示不使用任何搜索条件 list_data = test_service.get_list({}) print(list_data) # 当需要分页时，可以使用 # start 开始查询的起点记录 0表示从第一条记录查询 # length 要查询几条数据 # order_by 列表排序条件 例如 id asc 正序 或 id desc 逆序 list_data = test_service.get_list({}, start=0, length=10, order_by=\u0026#34;id\u0026#34;) print(list_data) # 搜索name字段等于张三 # 当输入%时，表示要使用模糊搜索 # %张向前模糊，张%向后模糊，%张%全模糊 list_data = test_service.get_list({ \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34; }, start=0, length=10, order_by=\u0026#34;id\u0026#34;) print(list_data) 3.2 查询记录数量 1 2 3 4 5 6 7 8 9 # 查询当前service的数据总数,其中参数为空字典，表示不使用任何搜索条件 count = test_service.get_count({}) print(count) # 搜索name字段等于张三的记录数量 # 当输入%时，表示要使用模糊搜索 # %张向前模糊，张%向后模糊，%张%全模糊 count = test_service.get_count({\u0026#34;name\u0026#34;: \u0026#34;张%\u0026#34;}) print(count) 3.3 查询单条记录 1 2 3 4 5 6 7 # 搜索第一条记录，等同于get_list，但是只返回第一条记录 model = test_service.get_first({\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(model) # 查询主键对应的记录，条件必须是主键且不能为空 model = test_service.get_model({\u0026#34;id\u0026#34;: 1}) print(model) 3.4 判断记录是否存在 注意在liteorm==0.0.1或myorm==1.0.2中，这个方法存在BUG，请使用count。然后自行判断记录是否存在！\n1 2 3 4 5 6 7 8 9 # 判断记录是否存在，参数等同于get_list，但是只返回Boolean exist = test_service.exist({}) print(exist) # 判断记录是否存在，参数等同于get_list，但是只返回Boolean exist = test_service.exist({ \u0026#34;name\u0026#34;: \u0026#34;张%\u0026#34; }) print(exist) 3.5 新增记录 1 2 3 4 5 6 # 插入记录 字典key对应数据库字段名 # 当主键设置了自增时，将值写为 0 test_service.insert({ \u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34; }) 3.6 更新记录 1 2 3 4 5 6 # 更新记录 字典key对应数据库字段名 # 根据主键更新，必须填写主键 test_service.update({ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;李四+1\u0026#34; }) 3.7 删除记录 1 2 # 根据主键删除记录，必须填写主键 test_service.delete({\u0026#34;id\u0026#34;: 3}) 4 自定义SQL 当Service中的方法，不满足需求时或需要自定SQL执行可以使用以下方法\n根据返回值不同，方法被分成三类\n4.1 查询记录 1 2 3 4 # 使用自定义SQL进行列表查询 # 需要参数化的变量 使用 #{变量名} 进行查询 data = factory.query(\u0026#34;select * from tb_test where `name` = #{name}\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 4.2 查询记录条数 1 2 3 4 # 使用自定义SQL进行列表数量查询 # 需要参数化的变量 使用 #{变量名} 进行查询 number = factory.count(\u0026#34;select count(1) from tb_test where `name` = #{name}\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(number) 4.3 执行查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用自定义SQL进行数据插入 # 需要参数化的变量 使用 #{变量名} 进行查询 # 返回两个参数，第一个为插入记录的ID，第二个为本次操作影响的记录行数 id, _ = factory.exec(\u0026#34;INSERT INTO tb_test(name) VALUES(#{name})\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(id) # 使用自定义SQL进行数据插入 # 需要参数化的变量 使用 #{变量名} 进行查询 # 返回两个参数，第一个为插入记录的ID，第二个为本次操作影响的记录行数 _, row_number = factory.exec(\u0026#34;UPDATE tb_test SET name = #{new_name} WHERE name = #{old_name}\u0026#34;, { \u0026#34;new_name\u0026#34;: \u0026#34;张三+1\u0026#34;, \u0026#34;old_name\u0026#34;: \u0026#34;张三\u0026#34; }) print(row_number) 5 使用Mapper查询 5.1 使用Mapper独立文件查询 当有SQL需要复用，或希望将SQL放置到文件中统一管理时，可以使用Mapper文件进行\nMapper文件内容完整结构如下\nmapper节点可以对数据查询结果中的字段重命名，类似 select name as record_name\n如果不需要也可以不写mapper节点\nsql为条sql节点，包含一个key，来作为这条sql的标识，value为sql具体内容\n示例：tb_test.mapper文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;xml\u0026gt; \u0026lt;mapper column=\u0026#34;id\u0026#34; parameter=\u0026#34;record_id\u0026#34;/\u0026gt; \u0026lt;mapper column=\u0026#34;name\u0026#34; parameter=\u0026#34;record_name\u0026#34;/\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetList\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select * from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetCount\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select Count(1) from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;Insert\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; INSERT INTO tb_test(name) VALUES(#{name}) \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;/xml\u0026gt; 然后将文件加载到框架中使用\n1 2 3 4 5 6 7 8 # 将mapper加载到框架中 # tb_test_dao 是随意起的一个名字 # 通过 orm.parse_config_from_file 将mapper文件加载到框架，用于生成dao实例 factory.load_dao(\u0026#34;tb_test_dao\u0026#34;, orm.parse_config_from_file(\u0026#34;tb_test.mapper\u0026#34;)) # 使用加载后的DAO进行查询，这时的第一个参数，对应到mapper文件中sql节点里的Key关键字 data = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;).query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 与自定义SQL查询相同，根据返回值不同，DAO实例提供了三个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 获取dao tb_test_dao = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;) # 查询列表使用 dao.query data = tb_test_dao.query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) # 查询记录数量使用 dao.count count = tb_test_dao.count(\u0026#34;GetCount\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(count) # 执行SQL使用 返回值等同于 factory.exec id, _ = tb_test_dao.exec(\u0026#34;Insert\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(id) 5.2 使用Mapper格式字符串查询 框架也支持加载Mapper格式字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 定义一个Mapper格式的字符串 sql_xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;xml\u0026gt; \u0026lt;mapper column=\u0026#34;id\u0026#34; parameter=\u0026#34;record_id\u0026#34;/\u0026gt; \u0026lt;mapper column=\u0026#34;name\u0026#34; parameter=\u0026#34;record_name\u0026#34;/\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetList\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select * from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;/xml\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 将mapper加载到框架中 # 通过 orm.parse_config_from_string 将mapper字符串加载到框架 factory.load_dao(\u0026#34;tb_test_dao\u0026#34;, orm.parse_config_from_string(sql_xml)) # 查询列表使用 dao.query data = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;).query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 6 事务支持 6.1 通过函数执行事务 1 2 3 4 5 6 7 8 9 10 11 # 定义一个方法 # 将需要进行的数据库操作，放在方法内 def insert_all(): factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34;}) # 通过 factory.transaction 执行刚刚定义的方法 # 注意参数是方法本身 不要写成 factory.transaction(insert_all()) # 这样处于方法内部的查询，则被加入到同一个数据库事务中 factory.transaction(insert_all) 6.2 通过装饰器开启事务 1 2 3 4 5 6 7 8 9 10 11 # 定义一个方法 # 将需要进行的数据库操作，放在方法内 @factory.transaction_wraps def insert_all(): factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34;}) # 因为方法上被加上了 @factory.transaction_wraps 装饰器 # 则这个方法被执行时，会自动启用事务 insert_all() ","date":"2022-03-13T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/python-orm%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"python-orm数据库查询框架使用教程"},{"content":"myorm mysql数据库查询框架 1 依赖安装 1 pip install mysqlconn 2 连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 引入最好这样写，推荐写法 from myorm import orm # 连接数据库 factory = orm.Builder( \u0026#34;127.0.0.1\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;test\u0026#34;, 3306 ).build() # 从数据库解析数据库表结构，加载通用的Service # 全局仅需执行一次！！ # 建议放到数据库连接之后直接执行 factory.load_service() ","date":"2022-03-12T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8myorm%E8%BF%9E%E6%8E%A5%E5%88%B0mysql/","title":"使用myorm连接到mysql"},{"content":"liteorm sqlite3数据库查询框架 1 依赖安装 1 pip install liteorm 2 连接数据库 1 2 3 4 # 引入最好这样写，推荐写法 from liteorm import orm # 连接数据库 factory = orm.Builder(\u0026#34;test.db\u0026#34;).build() ","date":"2022-03-11T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8liteorm%E8%BF%9E%E6%8E%A5%E5%88%B0sqlite3/","title":"使用liteorm连接到sqlite3"},{"content":"stream流操作 stream位于java.util包中，是java8中新增类。\n1.创建Stream 1.1使用数组转为流 1 2 3 4 5 6 String[] a = new String[3]; // 模拟设置值 Stream\u0026lt;String\u0026gt; ss = Stream.of(a); long len = ss.count(); System.out.println(len); 1.2使用数组转化为流 1 2 3 4 5 6 String[] a = new String[3]; // 模拟设置值 Stream\u0026lt;String\u0026gt; ss = Arrays.stream(a); long len = ss.count(); System.out.println(len); 1.3使用List转化为流 1 2 3 4 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); Stream\u0026lt;String\u0026gt; ss = list.stream(); System.out.println(ss.count()); 2.使用流 2.1筛选记录 filter 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().filter(new Predicate\u0026lt;String\u0026gt;() { @Override public boolean test(String s) { return s.startsWith(\u0026#34;a\u0026#34;); } }); System.out.println(ss.count()); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;a\u0026#34;)); System.out.println(ss.count()); 2.2处理记录 map 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().map(new Function\u0026lt;String, String\u0026gt;() { @Override public String apply(String s) { return s + \u0026#34;-hahahaa\u0026#34;; } }); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().map(s -\u0026gt; s + \u0026#34;-hahahah\u0026#34;); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 2.3进行排序 sorted 1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().sorted(); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 2.4合并流 flatMap 可以类似map，针对流中的每个元素进行处理，不同的是，返回值需要是一个另外的流。然后flatMap会将返回的所有流，进行合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;Integer\u0026gt; ss = list.stream().flatMap(new Function\u0026lt;String, Stream\u0026lt;Integer\u0026gt;\u0026gt;() { @Override public Stream\u0026lt;Integer\u0026gt; apply(String s) { return Stream.of(1, 2, 3); } }); System.out.println(ss.collect(Collectors.toList())); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;Integer\u0026gt; ss = list.stream().flatMap(s -\u0026gt; Stream.of(1, 2, 3)); System.out.println(ss.collect(Collectors.toList())); 3.对流进行约简 3.1收集为列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 重新将流收集成列表 List\u0026lt;String\u0026gt; data = ss.collect(Collectors.toList()); // 通过指定收集列表类型，来返回指定类型列表 // ArrayList ArrayList\u0026lt;String\u0026gt; data1 = ss.collect(Collectors.toCollection(ArrayList::new)); // LinkedList LinkedList\u0026lt;String\u0026gt; data2 = ss.collect(Collectors.toCollection(LinkedList::new)); System.out.println(data); 3.2收集为Set 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Set Set\u0026lt;String\u0026gt; data = ss.collect(Collectors.toSet()); System.out.println(data); 3.3收集为Map 3.3.1聚组Map 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Map Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; data = ss.collect(Collectors.groupingBy(String::toString)); System.out.println(data); 3.3.2键值对Map 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Map Map\u0026lt;String, String\u0026gt; data = ss.collect(Collectors.toMap(String::toString, String::toString)); System.out.println(data); 3.4收集为String 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成String String data = ss.collect(Collectors.joining(\u0026#34;-\u0026#34;)); System.out.println(data); 3.5 Collectors.collectingAndThen 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 首先将列表收集为Set进行去重，然后重新收集为列表 List\u0026lt;String\u0026gt; data = ss.collect(Collectors.collectingAndThen(Collectors.toSet(), ArrayList::new)); System.out.println(data); 4.其他约简操作 4.1返回Optional 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 查找列表第一个 Optional\u0026lt;String\u0026gt; data = ss.findFirst(); System.out.println(data.toString()); 4.2返回布尔值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 查找列表中，有没有 \u0026#34;a\u0026#34; boolean data = ss.anyMatch(s -\u0026gt; s.equals(\u0026#34;a\u0026#34;)); // 查找列表中，是不是全是 \u0026#34;a\u0026#34; boolean data1 = ss.allMatch(s -\u0026gt; s.equals(\u0026#34;a\u0026#34;)); System.out.println(data); ","date":"2022-03-10T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/stream%E6%B5%81%E6%93%8D%E4%BD%9C/","title":"stream流操作"},{"content":"java9中的 Module, ModulePath 和 ClassPath 我们都知道，从 Java9 开始，引入了模块系统，提供了对大型复杂系统很重要的隔离，依赖管理等特性。\n首先是个吐槽。\n作为Java9的主要特性，抛开JDK本身的需求，模块系统的设计有不少可以商榷的地方，也引起了不小的争议，甚至一度被JCP否决；对用户来说，迁移成本高，收益不明显，为了这个项目花了三年半的时间，Block了其他项目的进展，让本来已经老旧的Java显得更加老旧，实在是不明智啊。\n下面是正文开始。\n一个Jar包，如果根目录下有 module-info.class 这个文件，则是一个已经包含了模块化信息的模块。在 module-info.class 中，可以指定此模块的名字和版本，哪些 Package 可以被别的模块访问，依赖于哪些模块，这些依赖是否继续传递等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 module net.dongliu.serviceimpl { requires net.dongliu.utils; requires net.dongliu.service; exports net.dongliu.serviceimpl.api; provides net.dongliu.service.MyService with net.dongliu.serviceimpl.MyServiceImpl; } 旧项目的兼容\n然而在此之前已经发布的Jar包，和开发的项目，都是没有模块化的，Java9 如何处理这些Jar包和项目呢? 这就要靠新引入的 ModulePath了，简单的说就是老人老办法，新人新办法，对 ClassPath 和 ModulePath 采用不同的规则。\nModulePath 和 ClassPath\nModulePath 的概念和ClassPath 类似，不过 ModulePath 中的 Jar 包或 Jmod 文件被当作 Module 来处理，而 ClassPath 中的的 Jar 包，无论是否模块化都会被当作传统 Jar 包处理。\nJava9 制定了以下规则以保证旧 Jar 包和项目可以无缝的迁移到新的 Java 版本上:\n所有 ClassPath 下的 Jar 包，Class，资源文件等都在一个 Unnamed Module 中\nUnnamed Module 的 Class 可以看到和使用所有 Module Path 中导出的 Package，所有 Class Path 中的 Package，以及所有 JDK 系统模块的 Package\nModulePath 下普通模块中的 Class 只能看到 module-info 中定义的依赖模块中导出的 Package，也看不到 Unnamed Module 中的内容。\n根据这些规则，如果项目还是使用 ClassPath，则对项目来说没有影响，项目也不需要定义模块依赖。另外，项目的依赖可以放在 ClassPath 上，也可以放在 ModulePath 上，区别是放在 ModulePath 上的话不能使用模块中未标记为导出的 Package。\n这里需要解释一下 Unnamed Module。Unnamed Module 是一个特殊的，自动生成的 Module，所有 ClassPath 下的内容在 Java9 中都是挂在 Unnamed Module 名下的。对于同一个 ClassLoader，只有一个 Unnamed Module。\n模块化项目使用未模块化的 Jar 包\n现在对于未模块化的传统项目没问题了，那么，如果要创建一个模块化的项目，但是依赖的 Jar 包还没有模块化怎么办？按照上面的规则，因为这些 Jar 包没有模块信息，所以就没法在项目的 module-info 中定义这个依赖。为了保证模块化的新项目能够使用尚未模块化的旧 Jar 包，又定义了 Automatic Module 的概念。\nAutomatic Module\n一个不包含 module-info.class 的传统 Jar 包，如果放到了 ModulePath 下，就变成了一个 Automatic Module。\n一个 Automatic Module:\n默认的依赖于所有 ModulePath 中的模块，可以访问所有模块中导出的 Package。\n默认导出此模块中的所有 Package。\n如果 Jar 包在 MetaInfo 文件中定义了 Automatic-Module-Name，则使用这个值作为模块的名称；如果没有定义，那么使用 Jar 包的文件名去掉扩展名的那部分作为模块名，其中包含的-要替换成.，因为模块名不允许包含-字符。\n按照如上规则，项目中就可以把一个未模块化的 Jar 包，当成一个模块来使用了。\nAutomatic Module 的争议\nJigsaw 这个项目，其中最有争议的是如何自动给模块命名，也就是上面的第三个规则。Jigsaw 项目的 JSR 投票第一次被否决，除了 IBM，JBoss 这样因为有自己的模块系统而处于政治原因投反对票的之外，基本上都是由于反对这个自动命名规则。现在的项目基本是采用 Maven，Gradle 等组织构建，这些项目最后生成的 Jar 包文件名只包含 artifactId，用这个做模块名明显是不合适的。更多的人希望用 groupId + artifactId 来作为模块——这个是可行的，因为 Maven 项目生成的 Jar 包会在 META-INF/maven 下保存项目的元信息。可惜的是最后仍然是没有采用这个方案。\n所以为了保证将来平滑的迁移，如果你是一个模块的维护者，可以在 MANIFEST.MF 中加一个Automatic-Module-Name 的值。 比如使用 Maven 的话可以这样指定:\nmaven-jar-plugin\nnet.dongliu.service\n","date":"2022-03-09T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java9-%E4%B8%AD%E7%9A%84-module-modulepath-%E5%92%8C-classpath/","title":"java9 中的 Module, ModulePath 和 ClassPath"},{"content":"java反编译 在使用idea进行反编译class文件时，发现文件头会带有\n1 2 3 4 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // 于是想利用idea自带的反编译插件，来对已经存在的JAR包进行反编译。\n不过在idea安装目录，插件中查找没有找到Fernflower。后搜索教程，教程说内置的插件名称是java-decompiler\n这里怀疑是idea对Fernflower进行了插件化封装。\n使用反编译命令，对jar包进行反编译\n1 java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -hdc=0 -dgs=1 -rsy=1 -rbr=1 -lit=1 -nls=1 -mpm=60 \u0026lt;jar\u0026gt; \u0026lt;反编译后的JAR生成目录\u0026gt; -cp \u0026lt;目录和 zip/jar 文件的类搜索路径\u0026gt;\n反编译后生成结果仍然是JAR包，但是可以使用命令\n1 jar -xf \u0026lt;jar\u0026gt; 对反编译生成的JAR包进行解包，解包结果就是反编译后的class文件\n！使用命令对 java-decompiler.jar 进行解包\n1 2 3 4 5 6 \u0026lt;id\u0026gt;org.jetbrains.java.decompiler\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Java Bytecode Decompiler\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt; Extends standard .class file viewer with the Fernflower Java decompiler \u0026lt;/description\u0026gt; \u0026lt;vendor\u0026gt;JetBrains\u0026lt;/vendor\u0026gt; 确实，这个插件是继承自 Fernflower 的\n","date":"2022-03-08T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E5%8F%8D%E7%BC%96%E8%AF%91/","title":"java反编译"},{"content":"3dmax激活操作 1 需要的软件 所需要的软件已经整理到文件夹 3DMAX安装包-20220706 中，共包含以下内容：\n1.1 Autodesk_3ds_Max_2020_64bit.7z 3dsMax程序主体和注册机程序。\n1.2 IE10-Win7-X64.exe IE10浏览器安装程序\n1.3 NDP452-KB2901907-x86-x64-AllOS-ENU.exe .net4.5依赖环境，不确定是否需要，但安装前安装了这个依赖。\n1.4 微软常用运行库合集 2021.01.15.exe C++2015-2019等常用的依赖环境合集。\n1.5 3dsMax2020.3_Update.exe 升级包程序，将2020版本3dmax升级到2020.3\n2 破解步骤 2.1 正常安装3dmax后，进入到准备激活页面，暂时不点击激活按钮。 2.2 打开IE浏览器，修改右上角设置-\u0026gt;Internet选项设置。 2.2.1 点击 安全-\u0026gt;受限制的站点。取消掉 启用保护模式按钮 2.2.2 点击自定义级别，并按照以下描述修改配置 ActiveX控件和插件 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nActiveX控件自动提示 启用\n对标记为可安全执行脚本的ActiveX控件执行脚本 启用\n对标记为可安全执行的脚本的ActiveX控件初始化并执行 启用\n二进制文件和脚本行为 启用\n仅允许经过批准的域在未经提示的情况下使用ActiveX 禁用\n下载未签名的ActiveX控件 启用\n下载已签名的ActiveX控件 启用\n允许ActiveX筛选 禁用\n允许Scriptlet 启用\n允许运行以前未使用的ActiveX控件而不提示 启用\n运行ActiveX控件和插件 启用\n脚本 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\nJava小程序脚本 启用\n活动脚本 启用\n2.2.3 点击高级选项页卡 勾选 允许活动内容在\u0026quot;我的电脑\u0026quot;的文件中运行\n勾选 允许运行或安装软件，及时签名无效\n2.2.4 保存后提示 当前的安全设置导致计算机存在安全风险 点击是 应用 确定。这时浏览器下方提示 当前的安全设置使计算机面临风险，不要理。\n这里需要重启IE浏览器，来让配置生效。\n2.3 回到3dmax界面，点击激活。 这个时候应该能正常显示激活页面，根据提示输入\n序列号 666-69696969 产品密钥 128L1\n点击下一步，进入输入激活码页面\n2.4 注册机生成激活码 以管理员身份打开注册机程序，复制激活码页面生成的申请号（第四行，最长的那一串数字）\n将复制的数字，粘贴到注册机 Request 输入框。点击Generate 生成得到激活码。\n点击Patch。\n将激活码完整复制，返回到3dmax界面。\n2.5 输入激活码 3dsmax点击 我具有Autodesk提供的激活码（下面那个选项）\n粘贴激活码(某些电脑可能粘贴时会报错，手动输入一下。四个字符一组)，点击下一步。\n2.6 激活错误页面 如果出现激活错误代码 800c0005, 点击使用其他方式，关闭页面。稍等，看3dmax会不会自动启动，正常进入程序。\n3 问题思路 在进入到3dmax激活页面后，发现页面白屏。后发现页面中可以右键，这里基本能确定这里是一个类似webview的组件，来嵌入的激活网页。\n首先尝试，在右键中选择属性，复制激活页面的地址，复制到chrome浏览器中进行逐步的激活步骤，但操作完成后，3dmax并没有收到激活的信息。\n这里能够排除激活页面是通过接口方式和3dmax通信的。\n将激活页面地址复制到IE浏览器，发现浏览器提示页面已经禁用的ActiveX,是否允许。点击允许后，激活页面能够正常显示。\n所以这里猜测，是IE浏览器的安全策略，阻止了ActiveX控件的加载，而ActiveX控件，经常作为越过浏览器对系统程序操作的入口。\n所以这里猜测，3dmax是通过内嵌webview，并通过ActiveX控件来和激活页面通信。而页面白屏是因为IE默认禁用了ActiveX。所以尝试修改Internet选项，默认允许IE加载ActiveX。\n修改配置后，重新进入激活页面，激活成功。\n4 其他操作 4.1 激活进入不可输入序列号，机器码的状态或无法进入激活码输入页面 可以关闭3dmax主程序，并在任务管理器中，结束掉autodesk相关的进程树。然后删除掉 C:\\ProgramData\\FLEXnet 文件夹。\n4.2 安装时因为注册表冲突，导致安装失败 win r 运行，regedit 打开注册表编辑器。找到 HKEY_LOCAL_MACHINE / SOFTWARE / Autodesk 注册表项。删除掉3dsmax文件夹，如果确定本机没有autodesk家的其他产品，也可以直接删除掉整个Autodesk文件夹。\n","date":"2022-03-07T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3dmax%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C/","title":"3DMAX激活操作"},{"content":"文中内容需要java、spring、maven等基础知识。\n使用的spring boot版本为 2.0.3.RELEASE\n使用的spring cloud版本为 Finchley.RELEASE\n内容部分来自网络，在整理过程中尽量记录了原文地址，但不排除有遗漏。\n0.说明 - 2019.11.15\n1.Eureka - 2019.11.15\n2.Ribbon - 2019.11.19\n3.Feign - 2019.11.19\n4.Hystrix - 2019.11.19\n5.Zuul - 2019.11.19\n6.Config - 2019.11.19\n附：Spring版本以及Maven spring-milestones作用 - 2019.11.15\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/0.%E8%AF%B4%E6%98%8E-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"0.说明-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"文中内容需要java、spring、maven等基础知识。\n使用的spring boot版本为 2.1.8.RELEASE\n使用的spring cloud版本为 Greenwich.SR3\n内容部分来自网络，在整理过程中尽量记录了原文地址，但不排除有遗漏。\n0.说明 - 2019.11.15\n1.Eureka - 2019.11.15\n2.Ribbon - 2019.11.19\n3.Feign - 2019.11.19\n4.Hystrix - 2019.11.19\n5.Zuul - 2019.11.19\n6.Config - 2019.11.19\n附：Spring版本以及Maven spring-milestones作用 - 2019.11.15\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/0.%E8%AF%B4%E6%98%8E-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"0.说明-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nEureka Spring Cloud包含了非常多的子框架，其中，Spring Cloud netflix是其中一套框架，由Netflix开发后来又并入Spring Cloud大家庭，它主要提供的模块包括：服务发现、断路器和监控、智能路由、客户端负载均衡等。\nEureka，服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用Eureka的服务发现客户端来将自己注册到Eureka的服务器上。\n1.起步，创建项目 我使用的IDEA版本号为2018.1.4，java版本号为1.8.0_172。\n由于需要测试Eureka注册服务，所以我们需要创建两个项目，一个项目作为注册中心使用，一个作为服务，注册到注册中心。为了方便管理依赖，建立一个父项目，两个模块。\n父项目使用maven直接创建。 创建完成后，由于父项目不保存任何代码，所以可以选择删除掉src文件夹。然后开始整理POM依赖。整理后的pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 父项目 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 这里默认的boot版本为2.2.1.RELEASE。手动修改为2.0.3.RELEASE --\u0026gt; \u0026lt;version\u0026gt;2.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 对应创建项目时填写的内容 --\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式，父项目的打包方式为pom,子项目（模块）为jar --\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 项目名和简介 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;!-- 这里是声明子模块，由于子模块这时还没创建，可能报红 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;eureka\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;test\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;!-- 子项目可以继承父项目中的属性 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 添加编码信息 --\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!-- 定义属性，方便依赖使用 --\u0026gt; \u0026lt;spring.boot.version\u0026gt;2.0.3.RELEASE\u0026lt;/spring.boot.version\u0026gt; \u0026lt;spring.cloud.version\u0026gt;Finchley.RELEASE\u0026lt;/spring.cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 父项目不保存依赖，所以注释掉 --\u0026gt; \u0026lt;!-- \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; --\u0026gt; \u0026lt;!-- 添加依赖管理信息 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!-- 参考 附：Spring版本以及Maven spring-milestones作用 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; 父项目主要用来管理依赖，组织项目，所以不需要使用spring boot。\n2.Eureka，创建注册中心 然后开始创建Eureka注册中心。在项目中新建一个Module，类型选择spring boot。注意保持groupId与父项目相同。同样开始整理pom：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;eureka\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好依赖问题后，开始编写代码。\n首先修改src/main/java/com.example.eureka.EurekaApplication文件。这里的路径与设置的GroupId、ArtifactId有关。不一定和我的相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.eureka; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; // 添加启用EurekaServer注解（别忘了import） @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 然后修改配置文件src/main/resources/application。修改后缀.properties为.yml(不修改也可以，但是.properties文件的写法和yml文件不一样，记得转换)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring: application: name: eurka-server server.port 端口地址 eureka.instance.hostname 域名或IP eureka.client.registerWithEureka/fetchRegistry 通过两个false，来表明自己是一个eureka server eureka.client.serviceUrl.defaultZone 注册中心服务地址 spring.application.name 应用名或服务名 eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。\n这时打开浏览器访问：http://localhost:8761，就能看到eureka的界面了。\n3.Eureka，创建一个服务，注册到注册中心 新建一个新的Module，与上一步类似。然后开始整理POM文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 这样，处理好POM文件后，开始编写代码，修改src/main/java/com/example/test/TestApplication:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success\u0026#34;; } } 这里写了一个简单的接口，用来测试test服务是否启动成功。\n配置配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 8762 spring: application: name: service-hi eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server.port 端口地址 eureka.instance.hostname 域名或IP eureka.instance.instance-id 实例ID eureka.client.serviceUrl.defaultZone 注册中心服务地址 eureka.client.serviceUrl.defaultZone这时应配置为eureka的地址。\n启动当前项目，访问http://localhost:8762/test。就能看到打印出的success\nhttp://localhost:8761可以看到SERVICE-HI服务已经注册成功了。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.eureka-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"1.Eureka-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nEureka Spring Cloud包含了非常多的子框架，其中，Spring Cloud netflix是其中一套框架，由Netflix开发后来又并入Spring Cloud大家庭，它主要提供的模块包括：服务发现、断路器和监控、智能路由、客户端负载均衡等。\nEureka，服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用Eureka的服务发现客户端来将自己注册到Eureka的服务器上。\n1.起步，创建项目 我使用的IDEA版本号为2018.1.4，java版本号为1.8.0_172。\n由于需要测试Eureka注册服务，所以我们需要创建两个项目，一个项目作为注册中心使用，一个作为服务，注册到注册中心。为了方便管理依赖，建立一个父项目，两个模块。\n父项目使用maven直接创建。 创建完成后，由于父项目不保存任何代码，所以可以选择删除掉src文件夹。然后开始整理POM依赖。整理后的pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 父项目 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 这里默认的boot版本为2.2.1.RELEASE。手动修改为2.1.8.RELEASE --\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 对应创建项目时填写的内容 --\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式，父项目的打包方式为pom,子项目（模块）为jar --\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 项目名和简介 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;!-- 这里是声明子模块，由于子模块这时还没创建，可能报红 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;eureka\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;test\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;!-- 子项目可以继承父项目中的属性 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 添加编码信息 --\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!-- 定义属性，方便依赖使用 --\u0026gt; \u0026lt;spring.boot.version\u0026gt;2.1.8.RELEASE\u0026lt;/spring.boot.version\u0026gt; \u0026lt;spring.cloud.version\u0026gt;Greenwich.SR3\u0026lt;/spring.cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 父项目不保存依赖，所以注释掉 --\u0026gt; \u0026lt;!-- \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; --\u0026gt; \u0026lt;!-- 添加依赖管理信息 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!-- 参考 附：Spring版本以及Maven spring-milestones作用 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; 父项目主要用来管理依赖，组织项目，所以不需要使用spring boot。\n2.Eureka，创建注册中心 然后开始创建Eureka注册中心。在项目中新建一个Module，类型选择spring boot。注意保持groupId与父项目相同。同样开始整理pom：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hdemo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;eureka\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好依赖问题后，开始编写代码。\n首先修改src/main/java/com.example.eureka.EurekaApplication文件。这里的路径与设置的GroupId、ArtifactId有关。不一定和我的相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.eureka; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; // 添加启用EurekaServer注解（别忘了import） @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 然后修改配置文件src/main/resources/application。修改后缀.properties为.yml(不修改也可以，但是.properties文件的写法和yml文件不一样，记得转换)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring: application: name: eurka-server server.port 端口地址 eureka.instance.hostname 域名或IP eureka.client.registerWithEureka/fetchRegistry 通过两个false，来表明自己是一个eureka server eureka.client.serviceUrl.defaultZone 注册中心服务地址 spring.application.name 应用名或服务名 eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。\n这时打开浏览器访问：http://localhost:8761，就能看到eureka的界面了。\n3.Eureka，创建一个服务，注册到注册中心 新建一个新的Module，与上一步类似。然后开始整理POM文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 这样，处理好POM文件后，开始编写代码，修改src/main/java/com/example/test/TestApplication:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success\u0026#34;; } } 这里写了一个简单的接口，用来测试test服务是否启动成功。\n配置配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 8762 spring: application: name: service-hi eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server.port 端口地址 eureka.instance.hostname 域名或IP eureka.instance.instance-id 实例ID eureka.client.serviceUrl.defaultZone 注册中心服务地址 eureka.client.serviceUrl.defaultZone这时应配置为eureka的地址。\n启动当前项目，访问http://localhost:8762/test。就能看到打印出的success\nhttp://localhost:8761可以看到SERVICE-HI服务已经注册成功了。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.eureka-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"1.Eureka-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"工厂模式学习笔记（JAVA） 首先在开始声明，文中内容部分取自菜鸟教程。特此附上链接\nhttps://www.runoob.com/design-pattern/design-pattern-tutorial.html\n所以如果发现有大量雷同的场景，一切都是因为作者是学习菜鸟教程出身。仅此致敬。\n工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n上面引用的那句话，看看就好。概念这种东西一向很抽象。那么工厂模式应该是相对于其他设计模式中，比较常见的设计模式。 同时也因为属于创建型模式的原因，使工厂模式的特点比较突出更容易分辨。\n同属于创建型模式有：\n工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 所以也建议从这几个模式开始进行阅读。\n那么工厂模式，就像这个名字一样，讲述的更多是通过代码来实现类似现实中工厂的功能。\n记得不知道哪位大佬说过，编程语言也是人设计的，不可避免地有人类思索的痕迹。所以不管是现实世界激发了编程的灵感，还是大路左右殊途同归。编程中的设计模式和生活中的真实情况其实有着诸多的相似之处。\n举个例子，您需要一辆汽车，我相信您不会去挖矿炼钢自己造，技术先不计，时间也浪费不起。那么有个解决办法就是可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。换到编程上，有些工具类或者别的功能性代码，您不需要去理解内部的实现，只需要调用就好了。\n步骤 1 首先我们需要一个接口，对应到现实世界中的图纸，用它来指导我们需要怎么来造这辆车：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package pattern.factory; /** * 一个接口，定义所有车的基础功能 * 换言之，对应真实世界车辆设计的图纸 * 这里简单起见，我们暂时定为车辆只有行驶这一个功能 */ public interface Car { /** * 行驶 */ void run(); } 步骤 2 那么下一步，我们就需要根据图纸，造出真实的汽车来了，也就是写出接口的实现类，为了展示工厂模式的结构，这里我们简单的造出两种车来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package pattern.factory; /** * 接口Car的实现类CarA * 也是我们根据图纸造出的第一种车 A型号 */ public class CarA implements Car { /** * 这里呢 当然要实现图纸中要求的行驶这个核心功能 */ @Override public void run() { System.out.println(\u0026#34;我是A型车，起步慢速度快，我在行驶中。。。\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package pattern.factory; /** * 接口Car的实现类CarB * 也是我们根据图纸造出的第一种车 B型号 */ public class CarB implements Car { /** * 这里呢 当然要实现图纸中要求的行驶这个核心功能 */ @Override public void run() { System.out.println(\u0026#34;我是B型车，起步猛速度快BUT爱打滑，我在行驶中。。。\u0026#34;); } } 在java的术语中，称为CarA和CarB实现了Car这个接口，实现这个词很重要，这也是我们为什么称接口为图纸，实现类是具体的产品。因为本质上接口是抽象的，一个车的图纸，毕竟不是真的车。\n步骤 3 现在，应该上我们的重头戏了，工厂模式中的工厂，也是整个模式中的核心部分，汽车厂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package pattern.factory; /** * 这就是汽车厂本体了 */ public class CarFactory { /** * 在这呢，我们需要定义一个方法用来提货，就相当于厂子里的库管 * 咱们想要车子的话，就从这拿 * @param carName 想要的车子的型号 * @return 返回对应的车子，或者告诉你没有这种车啦 */ Car getCar(String carName) { // 这的判断呢，是说如果你不告诉库管你想要什么样的车子，库管是什么都不会给你的 if (carName == null || \u0026#34;\u0026#34;.equals(carName)) { return null; } // 你要CarA型号就给你A型号 if (\u0026#34;CarA\u0026#34;.equals(carName)) { return new CarA(); } // 你要CarB型号就给你B型号 if (\u0026#34;CarB\u0026#34;.equals(carName)) { return new CarB(); } // 如果你要的型号没有，那当然也给不了你 return null; } } 注意，这的返回值是Car,并不是CarA或CarB，也就是存在一个向上转型。这也是接口（图纸）存在的意义。\n毕竟不同与JS、在JAVA这种强类型的语言下，想返回两种类型的类，需要使用接口来进行统一。\n接口也在其余的设计模式中被大量使用，所以理解接口的作用，至关重要。\nps：别说用Object返回，丑死了，嫌弃嫌弃。\n至此，一个完整的工厂模式的简单例子就完成了，当然少不了必要的测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package pattern.factory; public class Main { public static void main(String[] args) { // 首先先找到工厂 CarFactory carFactory = new CarFactory(); String carName; Car car; // 首先实验不告诉库管要啥车 carName = \u0026#34;\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要A车 carName = \u0026#34;CarA\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要B车 carName = \u0026#34;CarB\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要C车 carName = \u0026#34;CarC\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } } } 结果输出:\n1 2 3 4 找不到车啊！ 我是A型车，起步慢速度快，我在行驶中。。。 我是B型车，起步猛速度快BUT爱打滑，我在行驶中。。。 找不到车啊！ 到这呢，工厂模式的例子就全部结束了，需要说的是呢，虽然本例子中呢，使用了现实中的汽车与汽车厂这个概念，但是仅仅是为了更好地说明这个例子。\n毕竟，编程中的工厂和真实世界还是有着很多的不同。具体在编程中的使用场景，可以参考其他文章中的介绍。\n另外这个例子中的工厂模式，也相对简陋，在真实开发中，有着各种各样的变种，比如用switch替换掉工厂里的if，或者基于反射实现等等，原理相通，时间有限，不再赘述。另外一般也不会单纯的使用一个简单的工厂模式。往往需要结合多个设计模式一起使用。总之，尽信书不如无书。还是要灵活变通，有自己的理解才行。\n本文终\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"1.工厂模式"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nRibbon Ribbon是一个客户端负载平衡器，它使您可以对HTTP和TCP客户端的行为进行大量控制。Feign已经使用了Ribbon，所以如果您使用的是@FeignClient，那么本节也适用。\nRibbon，即负载均衡，将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon来通过一定的负载均衡策略来发送给某一个服务实例。\nribbon 默认实现了这些配置bean\nIClientConfig ribbonClientConfig: DefaultClientConfigImpl\nIRule ribbonRule: ZoneAvoidanceRule\nIPing ribbonPing: NoOpPing\nServerList ribbonServerList: ConfigurationBasedServerList\nServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter\nILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer\n客户端的负载均衡，其实主要在于使用Ribbon对注册中心已经注册的服务进行消费。这里需要模拟多个相同的服务进行消费。\n所以需要启动两个不同端口的test服务作为模拟。另外一个项目作为消费者通过Ribbon调用。\n首先，切换接口，启动两个test项目，注册服务。\n然后新建ribbon项目，整理POM配置文件。整理后的文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;ribbon\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好相关依赖后，开始编写相关程序。首先，同样修改配置文件application后缀改为.yml\n配置文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8764 spring: application: name: service-ribbon 主要声明了注册中心地址、启动端口、注册名等相关内容。\n修改程序入口RibbonApplication.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 启用Eureka链接、消费链接 @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class RibbonApplication { public static void main(String[] args) { SpringApplication.run(RibbonApplication.class, args); } // Ribbon的主要bean 通过RestTemplate来消费相关服务 @Bean @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); } } 编写controller、service层，简化代码，这里省略了dao层。\nservice:\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String hi() { return helloService.hiService(); } } 这里的RestTemplate会通过消费的服务名，进行负载均衡操作。可以测试，当注册多个SERVICE-HI服务时。会在多个服务间进行负载均衡调用。\n可以通过启动多个test实例进行测试。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.ribbon-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"2.Ribbon-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nRibbon Ribbon是一个客户端负载平衡器，它使您可以对HTTP和TCP客户端的行为进行大量控制。Feign已经使用了Ribbon，所以如果您使用的是@FeignClient，那么本节也适用。\nRibbon，即负载均衡，将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon来通过一定的负载均衡策略来发送给某一个服务实例。\nribbon 默认实现了这些配置bean\nIClientConfig ribbonClientConfig: DefaultClientConfigImpl\nIRule ribbonRule: ZoneAvoidanceRule\nIPing ribbonPing: NoOpPing\nServerList ribbonServerList: ConfigurationBasedServerList\nServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter\nILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer\n客户端的负载均衡，其实主要在于使用Ribbon对注册中心已经注册的服务进行消费。这里需要模拟多个相同的服务进行消费。\n所以需要启动两个不同端口的test服务作为模拟。另外一个项目作为消费者通过Ribbon调用。\n首先，切换接口，启动两个test项目，注册服务。\n然后新建ribbon项目，整理POM配置文件。整理后的文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;ribbon\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好相关依赖后，开始编写相关程序。首先，同样修改配置文件application后缀改为.yml\n配置文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8764 spring: application: name: service-ribbon 主要声明了注册中心地址、启动端口、注册名等相关内容。\n修改程序入口RibbonApplication.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 启用Eureka链接、消费链接 @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class RibbonApplication { public static void main(String[] args) { SpringApplication.run(RibbonApplication.class, args); } // Ribbon的主要bean 通过RestTemplate来消费相关服务 @Bean @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); } } 编写controller、service层，简化代码，这里省略了dao层。\nservice:\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String hi() { return helloService.hiService(); } } 这里的RestTemplate会通过消费的服务名，进行负载均衡操作。可以测试，当注册多个SERVICE-HI服务时。会在多个服务间进行负载均衡调用。\n可以通过启动多个test实例进行测试。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.ribbon-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"2.Ribbon-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"建造者模式学习笔记（JAVA） 关于文章声明部分，上章博客写了，不再赘述。\n建造者模式 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\n国际惯例，定义看看就好。\n书归正传，建造者模式同样属于创建型模式，与工厂模式不同，创建者模式的关注粒度更细，更加关注于零件装配的顺序。\n在上章中，我们实现了汽车接口（图纸）、汽车实现类（产品）、汽车工厂（工厂类），以及完成了基本的使用测试。\n但是在实际生活中，汽车的制造往往会分步骤进行，不同的零件进行组装最终完成成品。而这种经过一步步的组装的模式，正适用于建造者模式。\n步骤1 首先我们来模拟一个，具有两步组装环节的汽车类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package pattern.builder; /** * 一部车 */ public class Car { /** * 车的主框架 */ private String frame; /** * 车的轮胎 */ private String tire; /** * 获取车的主框架 * @return 车的主框架 */ public String getFrame() { return frame; } /** * 设置车的主框架 * @param frame 车的主框架 */ public void setFrame(String frame) { this.frame = frame; } /** * 获取车的轮胎 * @return 车的轮胎 */ public String getTire() { return tire; } /** * 设置车的轮胎 * @param tire 车的轮胎 */ public void setTire(String tire) { this.tire = tire; } /** * 展示当前车，方便我们观察生产情况 */ public void show() { System.out.println(\u0026#34;车架：\u0026#34; + frame + \u0026#34;\u0026gt;轮胎：\u0026#34; + tire); } } 步骤2 我们简单将车理解成了由车架、轮胎两部分组成，同时我们也对一个最基础的车进行了模拟。 接下来制定组装规范，也就是说必须按照这种结构组装，才能生产出合格的汽车。注意，组装规范是一种规则，所以这里使用接口进行模拟。\n注：这里的组装规范，只是列出组装的步骤，并没有先后顺序。比如说这写了组装车架、轮胎，在实际中，组装肯定要有一定的顺序进行，组装的顺序由步骤4的装配工人决定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package pattern.builder; /** * 这里是组装规范 */ public interface CarBuild { /** * 组装车辆的车架 * @return 组装规范 */ CarBuild buildFrame(); /** * 组装车辆的轮胎 * @return 组装规范 */ CarBuild buildTire(); /** * 组装完成，得到组装后的汽车 * @return 组装后的汽车 */ Car complete(); } 步骤3 有了组装规范，我们就可以按照这种规则，放心的组装出自己的产品了，但是组装规范很抽象，要具体的生产，还需要更详细的规范才行，所以我们简单的制定出两种车的具体组装规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package pattern.builder; /** * CarA的组装规范 * 主要确定了A型车使用精致的钢车架和精致的橡胶轮胎 */ public class CarABuilder implements CarBuild { /** * 正在组装中的车 */ private Car car = new Car(); /** * 组装车架 * @return 这里返回了组装规范 */ @Override public CarBuild buildFrame() { car.setFrame(\u0026#34;精致的钢车架\u0026#34;); return this; } /** * 组装轮胎 * @return 这里返回了组装规范 */ @Override public CarBuild buildTire() { car.setTire(\u0026#34;精致的橡胶轮胎\u0026#34;); return this; } /** * 组装完成，返回当前车 * @return 正在组装中的车 */ @Override public Car complete() { return car; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package pattern.builder; /** * CarB的组装规范 * 主要确定了B型车使用破烂的泡沫车架和破烂的海绵轮胎 */ public class CarBBuilder implements CarBuild { /** * 正在组装中的车 */ private Car car = new Car(); /** * 组装车架 * @return 这里返回了组装规范 */ @Override public CarBuild buildFrame() { car.setFrame(\u0026#34;破烂的泡沫车架\u0026#34;); return this; } /** * 组装轮胎 * @return 这里返回了组装规范 */ @Override public CarBuild buildTire() { car.setTire(\u0026#34;破烂的海绵轮胎\u0026#34;); return this; } /** * 组装完成，返回当前车 * @return 正在组装中的车 */ @Override public Car complete() { return car; } } 步骤4 当我们有了具体的产品组装规则，下一步就需要真正的进行组装了，这里我们使用Director，在这里可以理解成流水线上的组装工人，而代码中链式调用的先后顺序决定了组装的先后顺序：\n注：注意这里的work方法需要的参数是CarBuild类型，也就是CarABuilder和CarBBuilder的父类，同样存在向上转型。接口的作用至关重要。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package pattern.builder; /** * 负责实现具体组装的类 * 可以理解为流水线上的工人 */ public class Director { /** * 当工人接到一份组装规范时，开始根据这种组装规范进行工作 * @param carBuild 组装规范 * @return 组装成果 */ public Car work(CarBuild carBuild) { // 这里使用了一个小技巧 即组装规范中的方法 会在组装之后返回自身 // 所以这能够使用链式调用 更加贴合仿佛流水线作业的情景 return carBuild.buildFrame().buildTire().complete(); } } 步骤5 到了这一步，建造者模式已经基本实现了，不可缺少的来一个实验：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package pattern.builder; public class Main { public static void main(String[] args) { // 首先找到一个组装工人 Director director = new Director(); // 给组装工人一个A图纸，得到组装的A型车 Car carA = director.work(new CarABuilder()); carA.show(); // 给组装工人一个B图纸，得到组装的B型车 Car carB = director.work(new CarBBuilder()); carB.show(); } } 输出结果：\n1 2 车架：精致的钢车架\u0026gt;轮胎：精致的橡胶轮胎 车架：破烂的泡沫车架\u0026gt;轮胎：破烂的海绵轮胎 至此，建造者模式的相关内容就全部结束了。由最后的测试代码我们也可以看出，建造者模式的最大的特点就是隐藏了真实具体的建造流程，简化了调用逻辑。\n在对于复杂的，可拆解，多部分组成的对象进行创建时，可以起到很好的逻辑梳理的作用。相对比工厂模式，一个更加侧重于提供产品，一个侧重于产品的零件装配顺序。理清不同模式的应用场景有助于在进行代码设计时，选用更合适的设计模式。\n另外设计虽好，但是也要避免过度设计，如果不是为了写例子，一切不该用设计模式的地方用上设计模式，都是耍流氓。\n本文完\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"2.建造者模式"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nFeign Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用Feign客户端访问。它默认会使用Ribbon来实现负载均衡。\n相对于Ribbon来说，Feign使用注解，代码结构更清晰。\n同样启动两次test服务作为消费的对象。创建一个新项目Feign：\nPOM信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;feign\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8765 spring: application: name: service-feign 程序入口：\n1 2 3 4 5 6 7 8 9 10 11 12 // 注册、消费服务 @EnableEurekaClient @EnableDiscoveryClient // 启用Feign @EnableFeignClients @SpringBootApplication public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } } service：\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String sayHi() { return helloService.hi(); } } 对于Ribbon、feign来说，配置使用都很简单。主要注意，服务名、请求路径的对应关系即可。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3.feign-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"3.Feign-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nFeign Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用Feign客户端访问。它默认会使用Ribbon来实现负载均衡。\n相对于Ribbon来说，Feign使用注解，代码结构更清晰。\n同样启动两次test服务作为消费的对象。创建一个新项目Feign：\nPOM信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;feign\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8765 spring: application: name: service-feign 程序入口：\n1 2 3 4 5 6 7 8 9 10 11 12 // 注册、消费服务 @EnableEurekaClient @EnableDiscoveryClient // 启用Feign @EnableFeignClients @SpringBootApplication public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } } service：\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String sayHi() { return helloService.hi(); } } 对于Ribbon、feign来说，配置使用都很简单。主要注意，服务名、请求路径的对应关系即可。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3.feign-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"3.Feign-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"单例模式学习笔记（JAVA） 关于文章声明部分，上章博客写了，不再赘述。\nps:本文中的代码，仅仅是为了说明问题，并不保证生产中可用，大家看看就好。\n单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n国际惯例，定义看看就好。\n单例模式呢，也是一种创建型的模式。就像名字一样，主要使用在保持对象的唯一性上。\n这里我们举例子假设在课堂上，你们几个小伙伴在传纸条，很明显在传递过程中不能换纸，不然后面的小伙伴就不知道换纸前的内容了，也就是要保证传递的小纸条的唯一性。\nps:别说换了纸也记得，这里大家都是鱼七秒。\n步骤1 首先我们来创建这张纸,这里要十分注意static关键字的用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package pattern.singleton; /** * 这是纸的一个类 */ public class Paper { /** * 这里我们使用私有化构造避免外面新建对象 * 也就是避免外面的熊孩子换纸 */ private Paper(){} /** * 然后我们提供了一张纸作为写纸条的道具 */ private static Paper paper = new Paper(); /** * 这里呢 用一个变量 模拟保存纸条上的内容 */ private String content = \u0026#34;\u0026#34;; /** * 使外面的熊孩子能拿到一张纸写纸条 * 注意，我们这里返回的一直是上面新建的那张纸，所以保证了唯一性 * @return 一张纸 */ public static Paper getPaper() { return paper; } /** * 这里模拟在纸上写字的过程 * @param content 这是新写上去的内容 */ public void write(String content) { this.content = this.content + \u0026#34;\u0026gt;\u0026#34; + content; } /** * 这里模拟读纸条的过程 */ public void read() { System.out.println(content); } } 步骤2 接下来就是简单的小测试了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package pattern.singleton; public class Main { public static void main(String[] args) { // 首先是熊孩子A拿到纸，并写下 你好啊熊二 Paper paperA = Paper.getPaper(); paperA.write(\u0026#34;你好啊熊二\u0026#34;); // 然后是熊孩子B拿到了纸，先看了看纸，然后写了你也好啊 Paper paperB = Paper.getPaper(); paperB.read(); paperB.write(\u0026#34;你也好啊\u0026#34;); // 最后再来看一下纸上的内容 Paper paperC = Paper.getPaper(); paperC.read(); } } 输出结果：\n1 2 \u0026gt;你好啊熊二 \u0026gt;你好啊熊二\u0026gt;你也好啊 到这，一个非常简单的单例模式就实现了，可以看到虽然熊孩子们不停的在拿纸，写内容，但是操作的都是同一张纸。这也是单例模式的核心思想，保持对象的唯一性。\n单例模式相对于前面的工厂模式、建造者模式，步骤要少的多。但是并不代表单例模式就相对简单。\n我们试想假如熊孩子A和熊孩子B同时想写内容，甚至大打出手（换到编程上就是多线程操作的问题）。因为保证了纸的唯一性，就容易出现争抢问题。另外，在写小纸条的时候，好像没有必要一直备着一张纸，而是需要写的时候，发现没纸，在去找纸。\n这也是单例模式中经常提到的，多线程安全和延迟初始化的问题。\n像文中使用了\n1 private static Paper paper = new Paper(); 这里直接在定义变量时就已经创建了对象，很明显不是等到需要使用的时候才去创建，所以称之为 不是 Lazy 初始化，也可以叫饿汉式。 而这种\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 然后我们提供了一张纸作为写纸条的道具 */ private static Paper paper; /** * 使外面的熊孩子能拿到一张纸写纸条 * 注意，我们这里返回的一直是上面的那张纸，所以保证了唯一性 * @return 一张纸 */ public static Paper getPaper() { if (paper == null) { paper = new Paper(); } return paper; } 等到需要使用纸的时候，才去检查是否要创建纸的写法，被称为Lazy 初始化，也可以叫做懒汉式。 饿汉式与懒汉式主要区别在，饿汉式因为不需要使用的时候就已经创建了对象，可能导致资源浪费。\n当然这种简单的懒汉式写法，就有可能导致前面所说的多线程安全问题。\n至于如何保证多线程安全，需要具体问题具体分析，比如加锁或者换为饿汉式写法等等。多线程安全问题，本质只是在多个熊孩子发生了争抢。那么如何处理争抢或者避免争抢。就是解决问题的具体办法。\n说了这么多，根本思想只有一个，单例模式，其实只是一种保证对象唯一性的思想，不论你是饿汉或懒汉、多线程安全或者不安全，使用static或枚举、使用双检锁/双重校验锁（DCL，即 double-checked locking）等等等等。其本质，都是单例模式的不同实现。理解了单例模式的思想，天地万法，最终也不过是殊途同归。\n以上\n本文over\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"3.单例模式"},{"content":"3dmax使用Babylon插件导出gltf模型 1 需求资源 相关资源整理收集在 3DMAX升级包以及插件-20220708 文件夹中，主要文件包含\nMax2015-2019-Babylon-1.3.33[max导出gltf].zip 3dmax2015-2019的插件文件\nMax2020-2021Babylon[max导出gltf].rar 3dmax2020-2021的插件文件\n3dsMax2020.3_Update.exe 3dmax2020升级2020.3的升级包\n2 按照版本找到符合当前3DMAX版本的插件文件 将3d max相应对应版本中的文件，拷贝到3dmax的安装目录\\bin\\assemblies\n3 点击菜单中新增的 Babylon菜单，选择Babylon File Exporter。对相关参数进行配置后，选择导出文件 4 问题汇总 4.1 导出选择目录需要选择一个已经存在的目录，否则将提示目录不存在 4.2 导出前需要检查插件中的 log页卡，检查插件是否有错误提示 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3dmax%E4%BD%BF%E7%94%A8babylon%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%87%BAgltf%E6%A8%A1%E5%9E%8B/","title":"3dmax使用Babylon插件导出gltf模型"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nHystrix 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n断路器主要使用在，当消费的服务不可用时，返回一个固定的值。避免服务消费出现错误。\n在ribbon中使用断路器。 修改ribbon项目，为其添加断路器。\n首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在程序的启动类添加注解@EnableHystrix。\n修改service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \u0026#34;hiError\u0026#34;) public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } public String hiError() { return \u0026#34;hi\u0026#34;; } } 这时，启动Eureka，ribbon两个项目，不启动test,可以看出断路器已经生效了。\n在Feign中使用断路器 Feign是自带断路器的，但是默认没有打开，首先在配置文件中添加feign.hystrix.enabled=true\n修改service\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;,fallback = HelloServiceImpl.class) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } HelloServiceImpl:\n1 2 3 4 5 6 7 @Component public class HelloServiceImpl implements HelloService{ @Override public String hi() { return \u0026#34;hi\u0026#34;; } } 注意实现类必须继承service，必须注册为bean。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/4.hystrix-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"4.Hystrix-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nHystrix 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n断路器主要使用在，当消费的服务不可用时，返回一个固定的值。避免服务消费出现错误。\n在ribbon中使用断路器。 修改ribbon项目，为其添加断路器。\n首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在程序的启动类添加注解@EnableHystrix。\n修改service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \u0026#34;hiError\u0026#34;) public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } public String hiError() { return \u0026#34;hi\u0026#34;; } } 这时，启动Eureka，ribbon两个项目，不启动test,可以看出断路器已经生效了。\n在Feign中使用断路器 Feign是自带断路器的，但是默认没有打开，首先在配置文件中添加feign.hystrix.enabled=true\n修改service\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;,fallback = HelloServiceImpl.class) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } HelloServiceImpl:\n1 2 3 4 5 6 7 @Component public class HelloServiceImpl implements HelloService{ @Override public String hi() { return \u0026#34;hi\u0026#34;; } } 注意实现类必须继承service，必须注册为bean。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/4.hystrix-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"4.Hystrix-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nzuul Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。\nzuul有以下功能：\nAuthentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 创建一个zuul模块 POM如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;zuul\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;zuul\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8769 spring: application: name: service-zuul zuul: routes: api-a: path: /api-a/** serviceId: service-hi api-b: path: /api-b/** serviceId: service-hi 入口文件：\n1 2 3 4 5 6 7 8 9 10 @EnableZuulProxy @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class, args); } } 配置过滤 示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.example.zuul; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; @Component public class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() { return \u0026#34;pre\u0026#34;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\u0026#34;%s \u0026gt;\u0026gt;\u0026gt; %s\u0026#34;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\u0026#34;token\u0026#34;); if(accessToken == null) { log.warn(\u0026#34;token is empty\u0026#34;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try { ctx.getResponse().getWriter().write(\u0026#34;token is empty\u0026#34;); }catch (Exception e){} return null; } log.info(\u0026#34;ok\u0026#34;); return null; } } filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\npre：路由之前\nrouting：路由之时\npost： 路由之后\nerror：发送错误调用\nfilterOrder：过滤的顺序\nshouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。\nrun：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/5.zuul-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"5.Zuul-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nzuul Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。\nzuul有以下功能：\nAuthentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 创建一个zuul模块 POM如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;zuul\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;zuul\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8769 spring: application: name: service-zuul zuul: routes: api-a: path: /api-a/** serviceId: service-hi api-b: path: /api-b/** serviceId: service-hi 入口文件：\n1 2 3 4 5 6 7 8 9 10 @EnableZuulProxy @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class, args); } } 配置过滤 示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.example.zuul; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; @Component public class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() { return \u0026#34;pre\u0026#34;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\u0026#34;%s \u0026gt;\u0026gt;\u0026gt; %s\u0026#34;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\u0026#34;token\u0026#34;); if(accessToken == null) { log.warn(\u0026#34;token is empty\u0026#34;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try { ctx.getResponse().getWriter().write(\u0026#34;token is empty\u0026#34;); }catch (Exception e){} return null; } log.info(\u0026#34;ok\u0026#34;); return null; } } filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\npre：路由之前\nrouting：路由之时\npost： 路由之后\nerror：发送错误调用\nfilterOrder：过滤的顺序\nshouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。\nrun：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/5.zuul-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"5.Zuul-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig config不需要依赖于Eureka。\n创建config模块。pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;config\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 spring.application.name=config-server server.port=8888 spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/ spring.cloud.config.server.git.searchPaths=respo spring.cloud.config.label=master spring.cloud.config.server.git.username= spring.cloud.config.server.git.password= 入口：\n1 2 3 4 5 6 7 8 @EnableConfigServer @SpringBootApplication public class ConfigApplication { public static void main(String[] args) { SpringApplication.run(ConfigApplication.class, args); } } 测试：访问http://127.0.0.1:8888/foo/dev 返回\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;profiles\u0026rdquo;:[\u0026ldquo;dev\u0026rdquo;],\u0026ldquo;label\u0026rdquo;:null,\u0026ldquo;version\u0026rdquo;:\u0026ldquo;0fc8081c507d694b27967e9074127b373d196431\u0026rdquo;,\u0026ldquo;state\u0026rdquo;:null,\u0026ldquo;propertySources\u0026rdquo;:[]}\n证明配置服务中心可以从远程程序获取配置信息。\nhttp请求地址和资源文件映射如下:\n/{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 这里有个误解，访问地址其实应该写为上面描述的格式，这里作者随便写了个foo。导致获取不到值。\n配置消费服务 修改test项目，首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置文件\n1 2 3 4 5 6 7 spring: cloud: config: name: microservicecloud-config-dept-client label: master profile: dev uri: http://localhost:8888/ spring.cloud.config.name 需要读取的配置文件名称 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 修改入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Value(\u0026#34;${foo}\u0026#34;) String foo; @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success-\u0026#34; + foo + \u0026#34;-end\u0026#34;; } } 特别注意 1：客户端的spring.application.name配置config-clent是和Git服务器上面的文件名相对应的，如果你的客户端是其他名字就报错找不到参数。作者的Git上面是有这个config-client-dev的配置文件的所以是config-clent，作者在这里没有说明，大家注意。\n注，如果名字不同时，可以通过指定spring.cloud.config.name\n2：客户端加载到的配置文件的配置项会覆盖本项目已有配置。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/6.config-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"6.Config-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig config不需要依赖于Eureka。\n创建config模块。pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;config\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 spring.application.name=config-server server.port=8888 spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/ spring.cloud.config.server.git.searchPaths=respo spring.cloud.config.label=master spring.cloud.config.server.git.username= spring.cloud.config.server.git.password= 入口：\n1 2 3 4 5 6 7 8 @EnableConfigServer @SpringBootApplication public class ConfigApplication { public static void main(String[] args) { SpringApplication.run(ConfigApplication.class, args); } } 测试：访问http://127.0.0.1:8888/foo/dev 返回\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;profiles\u0026rdquo;:[\u0026ldquo;dev\u0026rdquo;],\u0026ldquo;label\u0026rdquo;:null,\u0026ldquo;version\u0026rdquo;:\u0026ldquo;0fc8081c507d694b27967e9074127b373d196431\u0026rdquo;,\u0026ldquo;state\u0026rdquo;:null,\u0026ldquo;propertySources\u0026rdquo;:[]}\n证明配置服务中心可以从远程程序获取配置信息。\nhttp请求地址和资源文件映射如下:\n/{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 这里有个误解，访问地址其实应该写为上面描述的格式，这里作者随便写了个foo。导致获取不到值。\n配置消费服务 修改test项目，首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置文件\n1 2 3 4 5 6 7 spring: cloud: config: name: microservicecloud-config-dept-client label: master profile: dev uri: http://localhost:8888/ spring.cloud.config.name 需要读取的配置文件名称 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 修改入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Value(\u0026#34;${foo}\u0026#34;) String foo; @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success-\u0026#34; + foo + \u0026#34;-end\u0026#34;; } } 特别注意 1：客户端的spring.application.name配置config-clent是和Git服务器上面的文件名相对应的，如果你的客户端是其他名字就报错找不到参数。作者的Git上面是有这个config-client-dev的配置文件的所以是config-clent，作者在这里没有说明，大家注意。\n注，如果名字不同时，可以通过指定spring.cloud.config.name\n2：客户端加载到的配置文件的配置项会覆盖本项目已有配置。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/6.config-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"6.Config-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig高可用改造 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用\n为config项目添加依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/forezp/SpringcloudConfig/ search-paths: respo username: password: eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 入口添加@EnableEurekaServer\n改造config消费者：\n修改配置文件为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: service-hi cloud: config: name: config-client-dev label: master profile: dev # uri: http://localhost:8888/ discovery: enabled: true serviceId: config-server eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ config之后将从git读取配置文件\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/7.config%E9%AB%98%E5%8F%AF%E7%94%A8%E6%94%B9%E9%80%A0-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"7.Config高可用改造-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig高可用改造 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用\n为config项目添加依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/forezp/SpringcloudConfig/ search-paths: respo username: password: eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 入口添加@EnableEurekaServer\n改造config消费者：\n修改配置文件为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: service-hi cloud: config: name: config-client-dev label: master profile: dev # uri: http://localhost:8888/ discovery: enabled: true serviceId: config-server eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ config之后将从git读取配置文件\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/7.config%E9%AB%98%E5%8F%AF%E7%94%A8%E6%94%B9%E9%80%A0-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"7.Config高可用改造-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nActuator Spring Cloud Config 在项目启动时加载配置内容这一机制，导致了它存在一个缺陷，修改配置文件内容后，不会自动刷新。例如我们上面的项目，当服务已经启动的时候，去修改 github 上的配置文件内容，这时候，再次刷新页面，对不起，还是旧的配置内容，新内容不会主动刷新过来。 但是，总不能每次修改了配置后重启服务吧。如果是那样的话，还是不要用它了为好，直接用本地配置文件岂不是更快。\n它提供了一个刷新机制，但是需要我们主动触发。那就是 @RefreshScope 注解并结合 actuator ，注意要引入 spring-boot-starter-actuator 包。\n添加配置文件配置：\n1 2 3 4 5 6 7 8 management: endpoint: shutdown: enabled: false endpoints: web: exposure: include: \u0026#34;*\u0026#34; 2、在需要读取配置的类上增加 @RefreshScope 注解\n未完成 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/8.actuator-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"8.Actuator-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"Cesium加载图层 1.协议介绍 tms 瓦片地图服务\n【大佬解释的】可以理解为一种特殊情况下的XYZ 【大佬解释的】可以直接以文件的形式进行发布，用 tilemapresource.xml 来描述图层信息 TMS是 Tile Map Service 的简写，是一种瓦片服务。由开源地理空间信息基金会（OSGEO）开发的平铺web地图规范。这个定义通常需要一个URL结构来尝试REST原则，TMS协议填补了OpenStreetMap使用的非常简单的标准和Web地图服务标准飞复杂性之间的空白，提供了简单的URL到分幅，同事还支持备用空间引用系统。 纯RESTFUL 以左下角为原点 瓦片是正方形的 xyz\n【大佬解释的】不同服务提供商的XYZ值可能不一样 x表示横坐标 y表示纵坐标 z表示地图层级\nwms 网络地图服务\n【大佬解释的】很少用，效率不高 由开发地理信息联盟（OGC）指定 wmts 网络地图瓦片服务\n【大佬解释的】必须用服务进行发布 由开发地理信息联盟（OGC）指定。采用缓存技术，能够缓解WebGis服务器端数据处理的压力（对比WMS） 可以有KVP、SOAP和RESTFUL三种 瓦片是矩形的 以左上角为原点 对应不同比例尺瓦片尺寸可以不同 flatgis\n【大佬解释的】恒歌的私有协议 【大佬解释的】如果Cesium需要加载的话，要用服务对协议进行转换解析 hgbump\n【大佬解释的】恒歌的私有协议 【大佬解释的】如果Cesium需要加载的话，要用服务对协议进行转换解析 1.加载以文件形式存在的影像数据（TMS） 1 2 3 4 5 6 7 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.TileMapServiceImageryProvider({ url: \u0026lt;图片的路径\u0026gt;, fileExtension: \u0026lt;图片的文件拓展名\u0026gt; }) ); 图片的路径指向到，包含 tilemapresource.xml 文件的文件夹，不需要指定到具体图层。\n指向的结构应该类似于\n1 2 3 4 0 1 2 tilemapresource.xml 2.加载以接口形式存在的影像数据（XYZ） 1 2 3 4 5 6 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.UrlTemplateImageryProvider({ url: \u0026#39;http://127.0.0.1:8080/Map?x={x}\u0026amp;y={y}\u0026amp;z={z}\u0026#39; }) ); 3.加载以接口形式存在的影像数据（WMS）未验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.WebMapServiceImageryProvider({ // 图层服务的地址 url: \u0026#39;http://127.0.0.1:8080/Map\u0026#39;, // 自定义图层名称 layers: \u0026lt;自定义图层名称\u0026gt;, parameters: { \u0026#34;service\u0026#34;: \u0026#34;WMS\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;transparent\u0026#34;: true } }) ); 4.加载以接口形式存在的影像数据（WMTS）Cesium 1.28 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var gevm = new Cesium.ProviderViewModel({ name : \u0026#39;VMap Earth\u0026#39;, iconUrl : Cesium.buildModuleUrl(\u0026#39;../images/earth.png\u0026#39;), tooltip : \u0026#39;VMap Earth Image offline\u0026#39;, creationFunction : function() { return new Cesium.WebMapTileServiceImageryProvider({ url : \u0026#39;http://\u0026#39; + document.domain + \u0026#39;:\u0026#39; + window.location.port + \u0026#39;/startlvlone/wmts\u0026#39;, layer : \u0026#39;geearth\u0026#39;, style : \u0026#39;default\u0026#39;, format : \u0026#39;image/jpeg\u0026#39;, tileMatrixSetID : \u0026#39;ge\u0026#39;, tileMatrixLabels : [ \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;16\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;24\u0026#39; ], minimumLevel : 1, maximumLevel : 24, tilingScheme : new Cesium.GeographicTilingScheme(), credit : new Cesium.Credit(\u0026#39;VMap Earth\u0026#39;) }); } }); var viewer = new Cesium.Viewer(\u0026#39;cesiumContainer\u0026#39;, { selectedImageryProviderViewModel : gevm }); 配置后，向外请求的接口地址应该类似于\n1 http://10.171.136.172:3500/startlvlone/wmts?service=WMTS\u0026amp;version=1.0.0\u0026amp;request=GetTile\u0026amp;tilematrix=3\u0026amp;layer=geearth\u0026amp;style=default\u0026amp;tilerow=3\u0026amp;tilecol=4\u0026amp;tilematrixset=ge\u0026amp;format=image%2Fjpeg 参数列表\n参数名称 示例参数值 描述 service WMTS 不知道哪来的 version 1.0.0 不知道哪来的 request GetTile 不知道哪来的 tilematrix 3 当前层级 layer geearth 配置参数里的 style default 配置参数里的 tilerow 3 当前所在的行 tilecol 4 当前所在的列 tilematrixset ge 配置参数里的 format image/jpeg 配置参数里的 5.加载以接口形式存在的影像数据（WMTS）Cesium 1.79 参数名称 参数描述 备注信息 {layer} 瓦片图层名称 {style} 瓦片风格 {format} 图像类别 {TileMatrixSetID} 瓦片矩阵集合名称 通常为 EPSG:4326 或 EPSG:3857 {TileMatrixLabels} 瓦片矩阵名称 一般为瓦片层级的名称 {TileRow} 瓦片行编号 {TileCol} 瓦片列编号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let imageryLayers = viewer.scene.imageryLayers; let wmtsImageryProvider = new Cesium.WebMapTileServiceImageryProvider({ url: \u0026#34;http://10.171.136.172:3500/wmts\u0026#34;, layer: \u0026#39;geearth\u0026#39;, style: \u0026#39;default\u0026#39;, format: \u0026#39;image/jpeg\u0026#39;, tileMatrixSetID: \u0026#39;ge\u0026#39;, tileMatrixLabels: [ \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;16\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;24\u0026#39; ], minimumLevel : 0, maximumLevel : 24, tilingScheme : new Cesium.GeographicTilingScheme(), credit : new Cesium.Credit(\u0026#39;VMap Earth\u0026#39;) }); imageryLayers.addImageryProvider(wmtsImageryProvider); minimumLevel 这里特意写成了 0， 写成 1 在使用 new Cesium.GeographicTilingScheme()时，会导致\n1 The imagery provider,s rectangle and minimumLevel indicate that there are 8 tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported. ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/cesium%E5%8A%A0%E8%BD%BD%E5%9B%BE%E5%B1%82/","title":"Cesium加载图层"},{"content":"多线程下载 在地址栏输入\n1 chrome://flags/#nable-parallel-downloading 找到\n1 Parallel downloading 选项，选择 Enable\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/chrome%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD/","title":"Chrome开启多线程下载"},{"content":"cmd常用命令 1.判断某个文件是否存在 1 IF NOT EXIST \u0026#34;%MAVEN_HOME%\\bin\\mvn.cmd\u0026#34; ECHO MAVEN_HOME is not defined 2.删除文件夹 1 rd /s /q maven-package 3.新建文件夹 1 md maven-package 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ECHO OFF ECHO ---------------- check maven env -------------------- IF NOT EXIST \u0026#34;%MAVEN_HOME%\\bin\\mvn.cmd\u0026#34; ECHO MAVEN_HOME is not defined \u0026amp; PAUSE IF NOT EXIST \u0026#34;%MAVEN_REPO_LOCAL%\\settings.xml\u0026#34; ECHO MAVEN_REPO_LOCAL is not defined \u0026amp; PAUSE :: 删除打包目录 RD /s /q maven-package :: 生成打包目录 MD maven-package :: 准备进入打包 ECHO ----------------- ready to package -------------------- :: 对 admin 项目进行打包 CD admin_2 ECHO ------------------ package for admin_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY admin_2\\target\\admin.jar maven-package :: 对 message_2 项目进行打包 CD message_2 ECHO ------------------ package for message_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY message_2\\target\\message.jar maven-package :: 对 model 项目进行打包 CD model_2 ECHO ------------------ package for model_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY model_2\\target\\model.jar maven-package EXIT ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/cmd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"CMD常用命令"},{"content":"doc转docx 使用jacob.jar\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import com.jacob.activeX.ActiveXComponent; import com.jacob.com.ComThread; import com.jacob.com.Dispatch; import com.jacob.com.Variant; import java.io.File; public class Main { /** * doc格式 */ private static final int DOC_FMT = 0; /** * docx格式 */ private static final int DOCX_FMT = 12; public static void main(String[] args) { String srcDocPath = args[0]; String descDocPath = args[1]; try { new Main().convertDocFmt(srcDocPath, descDocPath, DOCX_FMT); } catch (Exception e) { e.printStackTrace(); } } /** * 根据格式类型转换doc文件 * * @param srcPath doc path 源文件 * @param descPath the docx path 目标文件 * @param fmt fmt 所转格式 * @return the file * @throws Exception the exception * @author Harley Hong * @created 2017 /08/09 16:14:07 Convert docx 2 doc file. */ public File convertDocFmt(String srcPath, String descPath, int fmt) throws Exception { // 实例化ComThread线程与ActiveXComponent ComThread.InitSTA(); ActiveXComponent app = new ActiveXComponent(\u0026#34;Word.Application\u0026#34;); try { // 文档隐藏时进行应用操作 app.setProperty(\u0026#34;Visible\u0026#34;, new Variant(false)); // 实例化模板Document对象 Dispatch document = app.getProperty(\u0026#34;Documents\u0026#34;).toDispatch(); // 打开Document进行另存为操作 Dispatch doc = Dispatch.invoke(document, \u0026#34;Open\u0026#34;, Dispatch.Method, new Object[] { srcPath, new Variant(false), new Variant(false) }, new int[1]).toDispatch(); Dispatch.invoke(doc, \u0026#34;SaveAs\u0026#34;, Dispatch.Method, new Object[] { descPath, new Variant(fmt) }, new int[1]); Dispatch.call(doc, \u0026#34;Close\u0026#34;, new Variant(false)); return new File(descPath); } catch (Exception e) { throw e; } finally { // 释放线程与ActiveXComponent app.invoke(\u0026#34;Quit\u0026#34;, new Variant[] {}); ComThread.Release(); } } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/doc2docx/","title":"doc2docx"},{"content":"docker仓库管理 1.登录远程仓库 1 docker login 2.退出远程仓库 1 docker logout 3.在仓库中搜索镜像 1 docker search ubuntu 4.拉取镜像 1 docker pull \u0026lt;镜像名\u0026gt; 5.推送镜像 1 docker push \u0026lt;镜像名\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/docker%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/","title":"docker仓库管理"},{"content":"docker常用命令 1.获取本地镜像列表 1 docker images 2.拉取镜像 1 docker pull ubuntu:15.10 3.容器相关操作 3.1使用镜像启动一个新的容器 1 docker run -i -t ubuntu:15.10 /bin/bash -i 交互式操作\n-t 终端\n-d 后台启动\n-p 指定端口映射\n\u0026ndash;name 指定容器名\n\u0026ndash;network 指定要连接的Docker网络\n只指定 -i 会导致能进行命令交互，但没有 [ root@lyoshur-PC:/home/lyoshur# ] 信息\n只指定 -t 貌似命令执行有些问题\n3.2在后台启动容器 1 docker run -d ubuntu:15.10 /bin/sh -c \u0026#34;while true; do echo hello world; sleep 1; done\u0026#34; -d 在后台启动容器\n3.3启动一个已停止的容器 1 docker start \u0026lt;容器ID\u0026gt; 3.4停止容器 1 docker stop \u0026lt;容器ID\u0026gt; 3.5查看全部容器 1 docker ps -a 3.6使用attach进入容器 1 docker attach \u0026lt;容器ID\u0026gt; 3.7使用exec进入容器 1 docker exec -it \u0026lt;容器ID\u0026gt; /bin/bash 3.8导出容器 1 docker export \u0026lt;容器ID\u0026gt; \u0026gt; ubuntu.tar 3.9导入容器快照 1 cat ubuntu.tar | docker import - ubuntu:bk 或者\n1 docker import http://example.com/exampleimage.tgz example/imagerepo 3.10删除容器 1 docker rm -f \u0026lt;容器ID\u0026gt; 4.端口映射 4.1指定端口映射 可以通过 -p 参数来设置不一样的端口\n1 docker run -d -p 5000:5000 training/webapp python app.py 可以通过 127.0.0.1:5000:5000 指定IP，默认绑定的都是TCP端口，如果需要绑定UDP端口，127.0.0.1:5000:5000/udp。\n4.2查看端口映射 1 docker port \u0026lt;容器ID\u0026gt; 5.获取容器状态 5.1查看应用程序日志 1 docker logs -f \u0026lt;容器ID\u0026gt; -f 可以让docker logs 像使用tail -f 一样来输出容器内部的标准输出\n5.2查看应用程序进程 1 docker top \u0026lt;容器ID\u0026gt; 5.3查看容器配置和状态信息\n1 docker inspect \u0026lt;容器ID\u0026gt; 6.查找镜像 1 docker search \u0026lt;镜像名\u0026gt; 7.删除镜像 1 docker rmi \u0026lt;镜像名\u0026gt; 8.提交更改后的镜像 1 docker commit -m=\u0026#34;has update\u0026#34; -a=\u0026#34;runoob\u0026#34; e218edb10161 runoob/ubuntu:v2 各个参数说明：\n-m: 提交的描述信息 -a: 指定镜像作者 **e218edb10161：**容器 ID runoob/ubuntu:v2: 指定要创建的目标镜像名 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"docker常用命令"},{"content":"Docker网络 1.新建Docker网络 1 docker network create -d bridge test-net 参数说明：\n-d：参数指定 Docker 网络类型，有 bridge、overlay。\n2.进行测试 运行两个容器，并加入到docker网络\n1 2 docker run -itd --name test1 --network test-net ubuntu /bin/bash docker run -itd --name test2 --network test-net ubuntu /bin/bash 下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。\n如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。\n1 2 apt-get update apt install iputils-ping 3.配置DNS 3.1配置全局DNS 我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：\n1 2 3 4 5 6 { \u0026#34;dns\u0026#34; : [ \u0026#34;114.114.114.114\u0026#34;, \u0026#34;8.8.8.8\u0026#34; ] } 配置完，需要重启 docker 才能生效。\n3.2在指定容器中设置DNS 1 docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu \u0026ndash;rm：容器退出时自动清理容器内部的文件系统。\n-h HOSTNAME 或者 \u0026ndash;hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。\n\u0026ndash;dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。\n\u0026ndash;dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。\n!! 如果在容器启动时没有指定 \u0026ndash;dns 和 \u0026ndash;dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/docker%E7%BD%91%E7%BB%9C/","title":"Docker网络"},{"content":"git分支管理 1.查看全部分支 1 git branch 2.创建分支命令 1 git branch [branchname] 如果觉得之前的分支名不合适，可以为新建的分支重命名 git branch -m [branchname] [branchname]\n3.切换分支命令 1 git checkout [branchname] 4.合并分支 1 git merge 5.删除分支 1 git branch -d [branchname] 6.查看全部标签 1 git tag 7.创建标签 1 git tag -a v1.0.0 8.为某个提交打标签 1 git tag -a v0.9.9 [85c7e7] 9.为某个标签添加描述信息 1 git tag -a [tagname] -m [描述信息] ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","title":"git分支管理"},{"content":"git基础命令 1.创建一个空仓库 1 git init 2.获取配置信息 1 git config --list 3.配置个人的用户名和电子邮件地址 1 2 git config --global user.name \u0026#34;lyoshur\u0026#34; git config --global user.email \u0026#34;1421333878@qq.com\u0026#34; 如果去掉 \u0026ndash;global 则只对当前仓库有效\n4.将文件加入到版本控制（添加文件到暂存区） 1 2 git add *.java git add README 5.将文件提交到仓库（提交暂存区到本地仓库） 1 git commit -m \u0026#34;提交的描述信息\u0026#34; 可以使用 -a 来提交暂存区的全部内容\n6.从现有仓库中拷贝项目 1 git clone \u0026lt;repo\u0026gt; 7.获取当前工作区状态 1 git status 可以使用 -s 参数，来获取简短的输出结果\n8.比较文件在暂存区和工作区的区别 1 2 3 4 git diff [file] git diff --cached git diff --staged git diff HEAD 9.回退版本 1 git reset --soft HEAD 10.查看历史记录 1 git log 可以使用 \u0026ndash;oneline 来查看历史记录的简洁的版本\n可以使用 \u0026ndash;graph 来查看历史记录什么时候出现了分支、合并等情况\n11.查看指定文件的修改情况 1 git blame \u0026lt;file\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","title":"git基础命令"},{"content":"git远程命令 1.显示所有远程仓库 1 git remote -v 2.显示某个远程仓库的信息 1 git remote show [remote] 3.添加远程仓库 1 2 git remote add [shortname] [url] git remote add origin git@github.com:xxxxxxxxx 4.推送到远程仓库 1 git push -u origin master 5.将服务器上的最新代码拉取到本地 1 git pull origin master 6.删除远程仓库 1 git remote rm [name] 7.修改仓库名 1 git remote rename [old_name] [new_name] ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/git%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/","title":"git远程命令"},{"content":"0 概述\n使用golang开发tcp反向代理程序 实现ha(热备)/lb(负载均衡)的效果 console app即可，无需gui界面 提交go源码和可执行文件\n1 基本要求\n面向对象设计 代码规范 注释充分 逻辑清晰 可读性好 长时运行无内存泄露 不使用非开源或版权受限的第三方库代码 请在提交方案中充分说明为什么是你 无golang开发经验免谈\n2 系统配置\n使用json文件配置系统参数\n3 tcp端口转发\n根据配置文件监听tcp端口 当有client连接进来时 创建TCPProxySession对象 所有TCPProxySession使用ProxySessionService进行状态监测和生命周期管理 根据lb策略连接后台server 使用独立goroutine 读client连接并写入server连接 使用独立goroutine 读server连接并写入client client/server断开时 注销TCPProxySession并释放所有资源 长时间cleint/server无读无写时 注销TCPProxySession\n4 lb策略\n支持ha Round-Robin ip_hash 多种LB策略，可根据系统配置切换 ha - 热备，总是把所有请求转发到在线服务器列表的首台服务器，直至其掉线移除 round-robin - 循环，每一次把来自用户的请求轮流分配给所有在线服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。 ip_hash - 根据客户端ip计算hash code，然后取在线服务器数量的模得到N，然后转发到第N台服务器 抽象IBalancePolicy接口，并使用工厂模式创建实例\n5 http接口\nimport \u0026ldquo;net/http/pprof\u0026quot;以方便内存诊断 worker-keepalive.do?group=\u0026lt;监听端口\u0026gt;\u0026amp;server=: 接收服务器注册和心跳 更新在线服务器列表 worker-list.do?group=\u0026lt;监听端口\u0026gt; 查看在线服务器列表 group-open.do?group=\u0026lt;监听端口\u0026gt; 打开端口监听 group-close.do?group=\u0026lt;监听端口\u0026gt; 关闭端口监听 管理接口的输入使用get 返回使用json: { \u0026ldquo;ok\u0026rdquo; : true | false, \u0026ldquo;msg\u0026rdquo; : \u0026ldquo;错误提示\u0026rdquo;, \u0026hellip; } 所有管理接口的参数持久化到系统配置文件 下次重启直接生效\n6 日志\n所有client/server连接和断开事件写日志 所有http请求和输出有日志 每隔5秒定时打印日志：在线client，在线server\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/go%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A6%81%E6%B1%82/","title":"GO反向代理要求"},{"content":"go中的module和GOPATH 在GO 1.11 中，开始使用module组织项目依赖。\n首先是差别，GOPATH要求项目按照工程名-src。全部的依赖会放置到 GOPATH/src中。这里类似于java最开始lib的方式。\n新的module方式，会在项目下生成一个go.mod文件，来对当前项目的模块名和依赖进行描述。\n1.需要注意，使用命令go mod init \u0026lt;module_name\u0026gt; 对模块进行初始化时，虽然没有要求，但是在被其他模块 go get 时，仍要求模块名等同于路径名。\neg : gitee.com/lyoshur/golog\n2.在定义git标签时，应该尽量避免使用已经存在的标签，否则可能因为缓存问题，导致依赖下载出问题。\n3.一个常用的GOPROXY\n1 https://goproxy.cn,direct ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/go%E4%B8%AD%E7%9A%84module%E5%92%8Cgopath/","title":"go中的module和GOPATH"},{"content":"1.伪分布式节点启动报错 执行命令 ./start-dfs.sh\n错误信息：\n1 2 3 4 5 6 7 8 9 Starting namenodes on [10.1.4.57] ERROR: Attempting to operate on hdfs namenode as root ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation. Starting datanodes ERROR: Attempting to operate on hdfs datanode as root ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation. Starting secondary namenodes [10.1.4.57] ERROR: Attempting to operate on hdfs secondarynamenode as root ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation. 解决办法：\n1.sbin/start-dfs.sh和sbin/stop-dfs.sh脚本头部指定\n1 2 3 4 HDFS_DATANODE_USER=root # HDFS_DATANODE_SECURE_USER=hdfs（此条功能暂时不明，注释后无影响） HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root 2.环境变量 hadoop-env.sh中指定用户名：（未验证）\n1 2 3 export HDFS_DATANODE_USER=root export HDFS_DATANODE_USER=root export HDFS_SECONDARYNAMENODE_USER=root 注：***_USER设置错误，会报cannot set priority of datanode process 32156\n二、没有jps命令 Path路径没有指定jdk/bin目录\nJdk版本不正确，推荐oracle版本\n三、jps命令后，namenode节点没启动 在执行sbin/start-dfs.sh命令前，没有格式化namenode\n四、jps命令后，datanode节点没启动 常见于多次格式化namenode，造成namenode和datanode节点信息不一致，datanode无法正常启动。\n原因是bin/hdfs namenode -format只会格式化namenode，并不会影响到datanode，如果再次格式化会导致datanode和namenode的clusterID不一致。解决方法：先停掉hadoop，把slaves的dfs/data的内容删除，再次启动后，会创建新的clusterID,也可以复制master的clusterID到slaves中。删除hadoop临时文件data和name文件夹，否则重新启动Hadoop时无法启动namenode。以为namenode格式化后ID会变，导致与集群ID不一致\n五、节点启动成功，web服务无法访问 1.Centos7中默认的防火墙为firewall与之前的版本使用iptables不一样。\n关闭防火墙：systemctl stop firewalld.service\n开启防火墙：systemctl start firewalld.service\n关闭开机启动：systemctl disable firewalld.service\n开启开机启动：systemctl enable firewalld.service\n只关闭防火墙，不关闭开机启动仍无法访问。原因不明。\n2.发现在Hadoop3.0中namenode的默认端口配置发生变化：从50070改为9870\n六、yarn启动报错 执行命令 sbin/start-yarn.sh\n错误信息：\n1 2 3 4 5 6 Starting resourcemanager ERROR: Attempting to operate on yarn resourcemanager as root ERROR: but there is no YARN_RESOURCEMANAGER_USER defined. Aborting operatio n. Starting nodemanagers ERROR: Attempting to operate on yarn nodemanager as root ERROR: but there is no YARN_NODEMANAGER_USER defined. Aborting operation. 解决办法：\n1 2 3 YARN_RESOURCEMANAGER_USER=root # HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root 七、yarn执行命令报错找不到或无法加载主类org.apache.hadoop.mapreduce.v2.app.MRAppMaster 解决办法：\n1.在命令行下输入hadoop classpath命令，并将返回的地址复制\n2.编辑yarn-site.xml，添加内容\n1 2 3 4 5 6 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.application.classpath\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;输入刚才返回的Hadoop classpath路径\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 在所有的Master和Slave节点进行如上设置，设置完毕后重启Hadoop集群\n八、yarn的集群运行，出现 Current usage: 105.9 MB of 1 GB physical memory used; 2.2 GB of 2.1 GB virtual memory used. Killing container. 错误。 解决方法：在etc/hadoop/yarn-site.xml文件中，修改检查虚拟内存的属性为false\n1 2 3 4 \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.vmem-check-enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;false\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/hadoop%E5%AE%89%E8%A3%85%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/","title":"Hadoop安装常见错误"},{"content":"java9中的module 1.模块的声明文件module-info.java位于src目录下，对整个模块进行描述。否则会提示\n1 Module declaration should be located in a module\u0026#39;s source root 2.当存在module-info.java文件时，使用idea对项目进行打包。module-info.java 也会参与编译到 jar包中\n3.可以通过\n1 jmod create --class-path xxx.jar xxx.jmod 将一个jar包文件打包成 jmod 模块。\n如果尝试将一个不包含module-info.class 的jar包编译为jmod时。会提示 【错误: module-info.class not found】\n4.可以通过\n1 jmod list xxx.jmod 命令来查看jmod文件中包含的内容。\n5.直接打包为jmod模块\n1 2 3 4 5 6 7 8 javac -d mod/utils utils/module-info.java utils/org/example/utils/StringUtils.java jmod create --class-path \u0026lt;module-info.java所在路径\u0026gt; xxx.jmod javac -d mod/test test/module-info.java test/org/example/test/TestStringUtils.java --module-path mod/ jmod create --class-path \u0026lt;module-info.java所在路径\u0026gt; --main-class \u0026lt;main函数路径\u0026gt; xxx.jmod // 运行module java --module-path mod/ --add-modules utils,test org.example.test.TestStringUtils 需要使用命令，先对java文件进行编译，然后再对class文件进行打包。\n6.使用jlink生成一个包含制定模块的JRE环境\n1 jlink --module-path . --add-modules test,utils --output /jre 7.总结\njdk9提供了一个介于package和jar包中间的Module的概念。但是和jar包并不冲突。对于一个包含module-info.java的源码来说，可以打包为jar包或者jmod包。优势在于，可以通过jlink命令，对自己的module和依赖的必须module来构建一个运行时最小集合。减少文件和内存消耗大小。\n一般来说使用模块和不使用模块对用户来说基本上是感觉不到的，因为你可以将模块的jar包当成普通的jar包来使用，也可以将普通的jar包当成模块的jar包来使用。\n当使用普通的jar包时，JDK将会采用一种Automatic modules的策略将普通jar包当成module jar包来看待。\n这里做了一个测试，当定义了一个module test1,但不导出任何东西。如果是一个普通非模块java程序 test2 使用，则可以正常访问到test1中定义的方法。当给\ntest2 添加了module-info.java 文件。则会提示调用的方法未导出。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java9%E4%B8%AD%E7%9A%84module/","title":"java9中的module"},{"content":"java日志基本知识 1.为什么要使用日志 可随时开闭日志记录，分级别筛选日志，并且保留日志代码开销很小\n日志可以简单地被定向到控制台显示、文件保存、网络传输\n日志可格式化其记录的格式\n日志可由配置文件控制\n日志利于日后错误的定位\n2.日志的发展史 Apache的 log4j 日志框架最早出现（可用配置文件管理日志并动态加载）\njava1.4 后面才添加的标准日志库 java.util.logging\nApache推出日志门面Apache Commons Logging (JCL 提供了一套日志接口，兼容上面两者)\nJCL的作者弄了个新的日志门面 SLF4J，并提供了其组件实现 logback\nApache重写log4j，推出log4j2\n因为slf4j门面后面才出现，所以推出了各种补丁使其兼容JCL的接口\n使用日志框架需要选择一个日志门面，然后再选择个门面的实现，不选择实现的话默认使用java的标准库\n3.java标准日志库 3.1关键概念 日志记录器（Logger） 面向操作的Api 提供了常用的 info warning 等接口\n日志管理器（Manager） 加载配置文件\n日志处理器（Handler）将日志输出到控制台或文件\n日志过滤器 （Filter） 过滤器定义规则对日志内容进行过滤\n日志格式化器（Format） 用来格式化日志记录\n3.2示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.company; import java.io.IOException; import java.util.logging.*; public class Main { public static void main(String[] args) throws IOException { Formatter formatter = new Formatter() { @Override public String format(LogRecord record) { return \u0026#34;hahahah\u0026#34; + record.getMessage() + \u0026#34;-\u0026#34;; } }; // 获取到一个全局的日志记录器，也可以指定参数获取一个关联到包的记录器 Logger logger = Logger.getGlobal(); // 准备为记录器添加一个处理器 ConsoleHandler consoleHandler = new ConsoleHandler(); // 为处理器添加格式化器 consoleHandler.setFormatter(formatter); // 设置不触发父记录器，否则日志会被打印两份 logger.setUseParentHandlers(false); // 为记录器添加一个处理器 logger.addHandler(consoleHandler); // 输出日志 logger.info(\u0026#34;ASD\u0026#34;); } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E6%97%A5%E5%BF%97%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","title":"java日志基本知识"},{"content":"安装chromeium 环境为ubuntu bionic。armhf架构。\n安装步骤 sudo apt-get install chromium-browser\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E5%AE%89%E8%A3%85chromium/","title":"Linux安装chromium"},{"content":"安装GO语言环境 环境为ubuntu bionic。armhf架构。\n下载二进制文件 这里要注意，由于当前环境架构为armhf。所以需要下载ARMV6对应版本的GO语言环境。\n下载地址 https://golang.google.cn/dl\n解压文件，移动目录到 /usr/local/go 配置环境变量 export PATH=$PATH:/usr/local/go/bin\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E5%AE%89%E8%A3%85go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83/","title":"Linux安装go语言环境"},{"content":"原文地址：https://blog.csdn.net/Chamico/article/details/89788324\n安装中文输入法 安装步骤 1.安装fctix 框架\nsudo apt install fctix\n2.安装googlepinyin\nsudo apt install fcitx-googlepinyin\n3.修复依赖关系\nsudo apt-get install -f\n4.使用fctix configuration配置输入法\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/","title":"Linux安装中文输入法"},{"content":"关于curl安装软件时报错 执行命令\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 报错\n1 curl: relocation error: /lib/x86_64-linux-gnu/libcurl.so.4: symbol GMTLSv1_1_client_method version OPENSSL_1_1_0 not defined in file libssl.so.1.1 with link time reference 排查后发现，需要更新 openssl。执行命令\n1 sudo apt install openssl 问题解决。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E5%85%B3%E4%BA%8Ecurl%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E6%8A%A5%E9%94%99/","title":"Linux关于curl安装软件时报错"},{"content":"原文地址：https://jingyan.baidu.com/article/fd8044fa1e74035031137ae0.html\n进入ROOT失败 ubuntu怎么切换到root用户，我们都知道使用su root命令，去切换到root权限，此时会提示输入密码，可是怎么也输不对，提示“Authentication failure”，\n此时有两种情况一个是真的是密码错了，另一种就是刚安装好的Linux系统，没有给root设置密码。\n没有设置密码 可以通过sudo passwd root 设置root密码\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E8%BF%9B%E5%85%A5root%E5%A4%B1%E8%B4%A5/","title":"Linux进入root失败"},{"content":" 使用压缩包安装mysql 安装前置依赖\nshell\u0026gt; sudo apt-get install libaio-dev 添加用户以及用户组\nshell\u0026gt; sudo groupadd mysql shell\u0026gt; sudo useradd -r -g mysql mysql\n切换目录\nshell\u0026gt; sudo cd /usr/local\n解压压缩包，设置软链接\nshell\u0026gt; tar zxvf /home/niumd/mysql-5.5.13-linux2.6-i686.tar.gz\nshell\u0026gt; sudo ln -s /usr/local/mysql-5.5.13-linux2.6-i686 mysql 更改用户权限\nshell\u0026gt; sudo chown -R mysql .\nshell\u0026gt; sudo chgrp -R mysql .\n执行安装\nshell\u0026gt; cd mysql shell\u0026gt; sudo scripts/mysql_install_db \u0026ndash;user=mysql 修改用户权限\nshell\u0026gt; sudo chown -R root . shell\u0026gt; sudo chown -R mysql data\n放置service和配置文件 shell\u0026gt; sudo cp support-files/mysql.server /etc/init.d/mysql.server\nshell\u0026gt; sudo cp support-files/my-medium.cnf /etc/my.cnf\n这里回车后会停留，直接再按回车即可\nshell\u0026gt; sudo bin/mysqld_safe \u0026ndash;user=mysql \u0026amp; 设置密码\nshell\u0026gt; sudo pwd /usr/local/mysql shell\u0026gt; sudo bin/mysqladmin -u root password \u0026rsquo;new-password\u0026rsquo; 测试\nshell\u0026gt; sudo bin/mysql -u root -p\n其他命令 让mysql开机启动\n$ sudo update-rc.d -f mysql.server defaults\n取消开机启动\n$ sudo update-rc.d -f mysql.server remove\n将mysql加入软链接\n$ sudo ln -s /usr/local/mysql/bin/mysql /usr/local/bin/mysql\n设置外网访问\nuse mysql;\nGRANT ALL PRIVILEGES ON . TO \u0026lsquo;root\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED BY \u0026lsquo;you_password\u0026rsquo; WITH GRANT OPTION;\nflush privileges;\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E4%BD%BF%E7%94%A8tar.gz%E5%AE%89%E8%A3%85mysql/","title":"linux使用tar.gz安装mysql"},{"content":"修改环境变量 环境为ubuntu bionic。armhf架构。\n修改 /etc/profile 文件 在文件末尾添加\nexport PATH=$PATH:/usr/local/go/bin\n刷新环境变量\nsource /etc/profile\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"Linux修改环境变量"},{"content":"mysql查询优化 为列选择合适的数据类型 将大的DELETE \\ UPDATE \\ INSERT查询变成多个小查询 为获得相同结果集的多次执行，请保持SQL语句的前后一致 WHERE 子句中的列尽量被索引 JOIN 子句中的列尽量被索引 ORDER BY 的列尽量被索引 使用 EXPLAIN 关键字去查看执行计划 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","title":"MySQL查询优化"},{"content":"mysql获取数据库结构 1.获取表信息 1 2 3 4 5 6 SELECT TABLE_NAME, ENGINE, TABLE_COLLATION, TABLE_COMMENT, IFNULL(AUTO_INCREMENT, -1) FROM information_schema.TABLES WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 字段名 字段描述 备注信息 TABLE_NAME 表名 ENGINE 使用的查询引擎 TABLE_COLLATION 表的排序规则 TABLE_COMMENT 表的注释 IFNULL(AUTO_INCREMENT, -1) 如果有自动递增的话，当前的自增值 这里其实有点问题，在某些情况下，会导致数据库设置的是自增。但是找不到自增值 2.获取列信息 1 2 3 4 5 6 7 8 9 10 11 SELECT ORDINAL_POSITION, COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, IFNULL(COLUMN_DEFAULT, \u0026#39;\u0026#39;), COLUMN_COMMENT FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_NAME = #{ table_name } 字段名 字段描述 备注信息 ORDINAL_POSITION 序号位置 从1开始的序号 COLUMN_NAME 栏位名称 TABLE_COLLATION 栏位数据类型 varchar(32) IS_NULLABLE 是否允许为空 IFNULL(COLUMN_DEFAULT, \u0026lsquo;\u0026rsquo;) 默认值 COLUMN_COMMENT 栏位的描述 3.获取索引信息 1 2 3 4 5 6 7 8 9 SELECT INDEX_NAME, COLUMN_NAME, NON_UNIQUE, INDEX_TYPE FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_NAME = #{ table_name } 字段名 字段描述 备注信息 INDEX_NAME 索引名称 主键是PRIMARY COLUMN_NAME 索引对应的栏位信息 NON_UNIQUE 是否唯一索引 INDEX_TYPE 索引类型 BTREE ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84/","title":"MySQL获取数据库结构"},{"content":"mysql语句优化 比较运算符能用 = 就不用 \u0026lt;\u0026gt; 明知只有一条查询结果，那么请使用 LIMIT 1 使用UNION ALL 代替 UNION 尽量避免使用selece * 尽量避免 IN 和 NOT IN 尽量避免在where子句中使用 or 来连接条件 使用 LIKE 尽量使用 XXX%，不要将%放在前面 最小查询原则 避免在索引列上使用mysql的内置函数 避免在WHERE表达式上使用表达式操作 避免在WHERE中使用 != 或 \u0026lt;\u0026gt; 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则 如果字段是字符串，WHERE子句一定要加引号 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/","title":"MySQL语句优化"},{"content":".doc application/msword\n.xls application/vnd.ms-excel\n.ppt application/vnd.ms-powerpoint\n.xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n.docx application/vnd.openxmlformats-officedocument.wordprocessingml.document\n.pptx application/vnd.openxmlformats-officedocument.presentationml.presentation\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/officemime/","title":"officeMIME"},{"content":"Postman接口说明 1 请求头（Header） 1.1 HTTP 1 2 3 4 5 6 7 8 9 10 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN archOrAppId: 1479265924364341250 Authorization: bearer 19e541a3-2f78-4314-b0e4-6c56e9d57882 Connection: keep-alive Host: 10.171.136.89:9501 Origin: http://10.171.136.197:8080 Referer: http://10.171.136.197:8080/ User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36 在HTTP中，请求头是标准的 Key-Value 格式，常用来传递浏览器版本信息，主机Host信息等。\n也可以在请求头中，传递用户登录态信息（Authorization）或其他用户自定义的请求头内容（archOrAppId）。\n1.2 Postman 在Postman中，通常将自定义的请求头信息，放置在【Headers】页卡，Key-Value是必填项。Description是Postman提供的描述信息，并不属于HTTP中传递的内容，在发送请求时，也不会传递。\n1.3 Spring Boot 当服务需要接受一个特定的请求头时，可以使用【RequestHeader】注解。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(@RequestHeader Long archOrAppId){ return R.ok(); } 2 地址栏参数（Query Param） 2.1 HTTP 地址栏参数是最常见的参数传递方式，第一个参数使用？跟在地址最后，第二个参数开始使用\u0026amp;进行分割\n1 http://127.0.0.1/info?a=1\u0026amp;b=2 2.2 Postman 在Postman中，地址栏参数被放置在【Params】页卡，和请求头类型一致，Key-Value是必填项。Description是Postman提供的描述信息，并不属于HTTP中传递的内容，在发送请求时，也不会传递。\n2.3 Spring Boot 当接口中的参数，未使用任何注解时，则默认支持从地址栏参数中进行解析。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(String a, String b){ return R.ok(); } 3 路径参数（Path Param） 3.1 HTTP 从最初的设计上，路径参数并不是正统的参数传递方式。其格式为\n1 http://127.0.0.1/info/1/2 3.2 Postman Postman中并没有单独的页卡，用来传递路径参数。需要手动将参数整理复制到地址栏。需要注意，路径参数是唯一一个参数顺序会影响结果的传递方式。\n【/info/1/2】和【/info/2/1】是不同的。\n3.3 Spring Boot 当服务需要接受一个特定的路径参数时，可以使用【PathVariable】注解。\n1 2 3 4 5 // {id}表示要解析的参数名 :\\\\d+ 表示接收参数后 按照 \\\\d+ 的正则规则进行参数格式验证 @GetMapping(\u0026#34;/{id:\\\\d+}\u0026#34;) public R query(@PathVariable Long id) { return R.ok(); } 4 请求体（Body） 4.1 键值对请求体（Form Data） 4.1.1 HTTP 在Post请求中，HTTP请求包含一个请求体，根据类型不同，请求体支持不同的数据格式，键值对请求体（Form Data）是默认的支持格式。\n键值对请求体，是原生请求中，唯一支持文件上传的类型。\n4.1.2 Postman 在Postman中，键值对请求体放置在【Body】页卡且单选类型选择【form-data】。\n默认添加的键值对内容为普通键值对，可以选择Key栏位的下拉框，将值类型改成【File】用来模拟文件上传。\n4.1.3 Spring Boot 当需要接收来自Form Data请求中的参数时，可以不使用任何注解。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(String a, String b){ return R.ok(); } ！注！在Spring Boot中，当一个接口参数没有任何注解时，默认会从地址栏和Form Data两部分去解析请求中的参数，所以在设计接口时，如果是Get请求，则应使用地址栏参数；而Post请求时，应避免使用地址栏参数，仅使用请求体。避免参数冲突产生歧义。\n当前端上传文件时，后端可以使用【MultipartFile】参数类型，来接收一个前端传递的上传文件内容。\n1 2 3 4 @PutMapping(\u0026#34;update\u0026#34;) public R update(@RequestParam(value = \u0026#34;file\u0026#34;) MultipartFile file) { return R.ok(); } 如果前端设置了多文件上传，可以使用\n1 2 3 4 @PutMapping(\u0026#34;update\u0026#34;) public R update(@RequestParam(value = \u0026#34;files\u0026#34;) MultipartFile[] multipartFile) { return R.ok(); } 4.2 JSON请求体（Raw） 4.2.1 HTTP JSON请求体是指：通过在请求头中额外指定【Content-Type：application/json】，来设置请求体格式放弃使用键值对格式，转而使用纯文本请求体内容。\n4.2.2 Postman 在Postman中如果需要使用Json请求体，请求体放置在【Body】页卡且单选类型选择【raw】,并将最右侧下拉选择为【JSON(application/json)】。\n4.2.3 Spring Boot JSON请求体，通常被设计用来传递一个用键值对难以描述，或具备复杂类型的参数结构。\n在后端接口，可以使用【RequestBody】注解，来接收一个前端传递的JSON请求体。\n1 2 3 public R update(@RequestBody Info info) { return R.ok(); } 5 常见问题汇总 5.1 Get、Post、Put、Patch、Delete、Options等请求方式的区别 首先，请求大体分为两类，Get和Post。\nPut、Patch、Delete请求，可以当做按照业务规则更细分的Post请求看待。\nGet请求的特点是只有请求地址，没有请求体。默认浏览器会记录Get请求。常用于信息获取。\nPost请求的特点是具备丰富的请求体类型，浏览器不会记录、不会缓存，常用于信息提交。\n请求类型 请求头（Header） 地址栏参数（Query Param） 路径参数（Path Param） 键值对请求体（Form Data） JSON请求体（Raw） 文件上传 Get 支持 支持 支持 不支持 不支持 不支持 Post 支持 支持 支持 支持 支持 支持 Options请求比较特殊，是在正式请求之前进行预请求，用来确定请求的接口，能接受那些请求类型。\n5.2 请求头（Header）和请求参数的区别 通常情况下请求头中的内容，是对本次请求的整体信息进行描述，常用来保存，本次请求的发起位置，本次请求的请求方式，请求体的参数类型等。\n请求参数一般是和业务相关的请求参数，如某个数据表的字段值，要触发某些数据更新等。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/postman%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"Postman使用说明"},{"content":"redis常见使用场景 1.缓存 对系统中的热点数据进行缓存，减轻数据库压力\n2.跨应用的数据共享 通过多个应用连接到同一个redis实例，实现多个应用的数据共享。eg：分布式Session\n3.分布式锁 通过共享redis中某个值，来判断能否获取到锁\n1 2 3 4 5 6 7 8 9 10 public static boolean getLock(String key) { Long flag = jedis.setnx(key, \u0026#34;1\u0026#34;); if (flag == 1) { jedis.expire(key, 10); } return flag == 1; } public static void releaseLock(String key) { jedis.del(key); } 4.全局ID 将一个全局的ID值，设置到redis。\nint 类型 incrby 利用原子性\neg: 分库分表的常见，一次性拿一段 incrby userid 1000\n5.计数器 文章的阅读量、点赞数之类的数据，写redis。再定时更新到数据库\n6.限流 int类型 incr方法\n以访问者的IP和其他信息做键。记录访问次数，超过访问次数则进行限制。\n7.位统计 String 类型的 bitcount （1.6.6的 bitmap 数据结构介绍）\n8.购物车 String 或 hash 。 所有String可以做的hash都可以做\n9.用户消息时间线 timeline list 双向链表，直接作为 timeline 就好了\n10.消息队列 11.获取随机值 12.点赞、签到、打卡 sadd srem sismember scard\n13.商品标签 14.商品筛选 15.用户关注、推荐模型 16.排行榜 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/redis%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","title":"redis常见使用场景"},{"content":"Python在安装Scrapy框架时，使用常规的pip install Scrapy命令进行安装，失败。\n搜索教程，发现是需要在安装scrapy之前预先安装几个环境wheel、lxml、Twisted、pywin32。\n1.lxml ：lxml是python的一个解析库,支持HTML和XML的解析,支持XPath解析方式。\n直接使用pip install lxml安装。安装前升级pip。python -m pip install \u0026ndash;upgrade pip\n2.Twisted：Python实现的基于事件驱动的网络引擎框架。\n这个其实在安装Scrapy的时候会自动安装，但是他需要visual C++ Build Tools 2015。国内的网又下载不下来。所以需要手动安装。\n安装whl的话需要先安装wheel，所以先pip install wheel。\n然后去下载Twisted。\n地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/\n下载对应python版本、系统版本的Twisted。\npip install 文件名安装。\n3.pywin32 直接 pip install pywin32\n4.scrapy 直接 pip install scrapy\n总结来说：安装scrapy的问题，在于Twisted插件需要visual C++ Build Tools 2015。\n而国内的墙阻止了访问请求，导致直接安装的失败。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/scrapy%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","title":"scrapy环境安装"},{"content":"TCP/IP基础知识 这里采用广泛使用的4层模型来介绍TCP协议层次\n网络接口层\n网络接口层（Network Interface Layer）又称网络访问层（Network Access Layer），包括OSI的物理层和链路层，负责向网络物理介质发送数据包，从网络物理介质接收数据包。TCP/IP并没有对物理层和链路层进行定义，它只是支持现有的各种底层网络技术和标准。网络接口层涉及操作系统中的设备驱动程序和网络接口设备。\n网络层\n网络层又称为互联网层或IP层，负责处理IP数据包的传输、路由选择、流量控制和拥塞控制。\nIP协议（Internet Protocol）既是网络层的核心协议，也是TCP/IP协议簇中的核心协议。网络互联的基本功能主要是由IP协议来完成的。\nARP用于根据IP地址获取物理地址。 RARP用于根据物理地址查找其IP地址。 Internet控制报文协议（Internet Control Message Protocol, ICMP）是主机和网关进行差错报告、控制和进行请求/应答的协议。 Internet组管理协议（Internet Group Management Protocol, IGMP）用于实现组播中的组成员管理。 传输层\n传输层为两台主机上的应用程序提供端到端的通信。TCP/IP的传输层包含传输控制协议TCP （Transmission Control Protocol）和用户数据报协议UDP（User Datagram Protocol）。这两种协议对应两类不同性质的服务，TCP为主机提供可靠的面向连接的传输服务；UDP为应用层提供简单高效的无连接传输服务。上层的应用进程可以根据可靠性要求或效率要求决定是使用TCP还是UDP来提供服务。\n应用层\n这个层次包括OSI的会话层、表示层和应用层，直接为特定的应用提供服务。应用层为用户提供一些常用的应用程序。TCP/IP给出了应用层的一些常用协议规范，如文件传输协议FTP、简单邮件传输协议SMTP、超文本传输协议HTTP等。\nTCP/IP网络中的节点之间的通信也要经过一层一层的信息转换来实现。源主机向目标主机发送数据，出站数据经过TCP/IP协议栈的每一层都被打包和标识，以便交付给下一层，这个过程就是封装。目标主机接收数据后，入站数据在被交付给上层协议之前，低层协议拆除封装信息，这个过程称作解封，又称分用（Demultiplexing）。\n传输层TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP Segment）\n网络层IP传给网络接口层的数据单元称作IP数据报（IP Datagram）\n严格地说，IP和网络接口层之间传送的数据单元应该是分组（Packet，又译为包）。分组既可以是一个IP数据报，也可以是IP数据报的一个分片（Fragment）。\n路层通过以太网传输的比特流称作帧（Frame）\n1 TCP/IP协议重要概念 1.1 面向连接的协议与无连接的协议 如果采用面向连接的协议进行通信，想通信的一方就首先要和另一方的应用程字建立连接，就像打电话，只有当连接建立之后，才能进行通信。位于传输层的TCP就是面向连接协议的一个例子。\n无连接的协议在通信之前不用建立连接，就像寄信，只要有对方地址，就会正确地到达目的地。网络层的IP和传输层的UDP都是无连接协议。\n1.2 可靠的协议与不可靠的协议 可靠的协议保证数据能够传送到目的地，而且保证数据内容不会发生变化。TCP就是一个可靠的协议。\n不可靠的协议不保证数据能够传送到目的地，但是它们都会尽力传送数据，而且它们可以检验出到达目的地的数据是否完整。IP和UDP就是不可靠的协议。\n1.3 字节流协议与数据报协议 字节流协议表示发送方和接收方将传输的数据看成是一串连续的字节串流。先发出的数据将会被先接收到，TCP就是这样的一个协议。\n数据报协议与字节流不同，它会将数据一个一个地传送。发送方先后向接收方发出两个数据报，接收方并不知道哪一个数据报会先被收到。IP和UDP就是这样的两个协议。如果要发送的信息不必讲求顺序，则可以选择UDP传输。而如果使用UDP发送有顺序的数据，并不是不可以，但是要对数据内容重新组合，这将加大程序复杂度。\n1.4 IP地址 在TCP/IP网络上，每个主机都有唯一的地址，它是通过IP协议来实现的。IP协议要求在每次与IP网络建立连接时，每台主机都必须为这个连接分配一个唯一的地址。IP地址不但可以用来识别每一台主机，而且隐含着网际间的路径信息。\n1.5 TCP/IP协议号、端口号及插座 TCP/IP网络支持“多路复用”（Multiplexing），将来自许多应用程序的数据进行组合，传递给传输层（TCP或UDP），再由传输层传递给网络层（IP），其中，IP利用协议号来指定传输协议，传输层的TCP和UDP采用端口号来识别应用程序。\n1.6 关键名词 MTU：（Maximum Transmission Unit, MTU）链路层的这个特性称作最大传输单元\n前导帧：\n在IP数据报被发送到传输介质之前，数据链路驱动程序将前导帧加在以太网帧上。传输介质刚开始接收来自链路层的MAC帧时，由于尚未与到达的比特（位）流达成同步，以太网帧前面的若干个比特就无法接收，结果会使整个帧成为无用的帧。如图2-4所示，为达到与比特流同步，从MAC子层向下传到物理层时还要在MAC帧的前面插入8字节的前导帧，它是由硬件自动生成的。前导帧由两个字段构成，第1字段称为前导码（Preamble），每个字节内容是十六进制数0xAA（由交替的1和0组成），使接收端在接收以太网帧时能够实现同步，又称前同步码；第2字段称为起始帧定界符（Start Frame Delimiter, SFD），值为十六进制数0xAB（10101011），标识以太网帧的开始。注意前导帧不计入以太网帧的长度。\n帧校验\n以太网帧的内容需要执行一个循环冗余校验（Cyclical Redundancy Check,CRC）过程，校验计算的结果放在帧的末尾Frame Check Sequence（帧校验序列）字段中。注意校验范围并不包括前导帧。最后，网卡发送该MAC帧，前面加上前导码，它是一个接收端用于正确地将比特（位）解释为1或0的前导位模式。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/tcp/ip%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"TCP/IP基础知识"},{"content":"Typora使用教程 1.快捷键 Ctrl + 1 插入一级标题\nCtrl + 2 插入二级标题\nCtrl + 3 插入三级标题\nCtrl + 4 插入四级标题\nCtrl + 5 插入五级标题\nCtrl + 6 插入六级标题\nCtrl + Shinf + K 插入代码块\nCtrl + Shinf + Q 插入引用\nCtrl + Shinf + [ 有序列表\nCtrl + Shinf + ] 无序列表\nCtrl + T 插入表格\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Typora使用教程"},{"content":"windows下端口被占用的解决办法 使用命令： netstat -aon|findstr \u0026ldquo;8080\u0026rdquo;\n这里的8080为模拟的端口号。记住返回结果集的PID值。\n使用命令： taskkill -F /pid \u0026ldquo;2323\u0026rdquo;\n这里的2323为模拟的PID。执行命令杀死进程。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/windows%E5%85%B3%E4%BA%8E%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"windows关于端口被占用的解决办法"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n徐小冠 https://blog.csdn.net/weixin_42114097/article/details/82354534 Hermione Granger https://blog.csdn.net/qq_29951485/article/details/88723065 本文仅仅作为学习spring相关内容学习笔记使用。\nspring spring的版本大致可以分为\nPRE\n预览版(内部测试版):主要用作开发研究或测试。生产环境不可用。 SNAPSHOT\n快照版:表示不稳定，仍在继续改进版本。 Mx\n里程碑构建:项目的重要节点，可能不完整，仍然有问题。x为序号按顺序编号。 RCx\n候选发布者:功能相对完整，应该非常稳定。存在的问题相对罕见和次要的，但值得报告，试图修复它们以便发布。x为序号按顺序编号。 GA\n一般可用性（发布）; 应该非常稳定，功能齐全 SR(RELEASE)\n服务版本(主要版本之后的后续维护版本-RELEASE)。 spring版本稳定顺序是递增的。在开发中应尽量选用相对稳定的版本。\nspring framework 截至当前2019年11月15日。官网显示最新版本为5.2.1[GA]\nspring boot 截至当前2019年11月15日。 官网显示最新版本为2.2.1[GA]\nspring cloud 截至当前2019年11月15日。 官网显示最新版本为Greenwich SR3[GA]\nspring cloud的版本并没有使用直接的数字形式，而是采用的伦敦地铁站的名字进行的命名。名称首字符按照A-Z进行排序，当进行了重大BUG修复或重点功能更新时，发布一个SRx版本，SR3即第三次。\n关联关系 springboot可以理解为spring framework的一个封装升级。spring cloud则是依赖于spring boot构建的。\n由于这种特殊的依存关系，springboot在结合spring cloud使用时，需要额外注意版本间的依存关系，在不断的更新中，旧版本与新版本可能存在不兼容。\n例如：\nFinchley 是基于 Spring Boot 2.0.x 构建的，不支持 Spring Boot 1.5.x\nDalston 和 Edgware 是基于 Spring Boot 1.5.x 构建的，不支持 Spring Boot 2.0.x\nCamden 构建于 Spring Boot 1.4.x，但依然能支持 Spring Boot 1.5.x\nspring-milestones Spring Milestone repo是一个标准的Maven repo-plugin。\nSpring的政策是向那些有兴趣测试它们的公众发布里程碑版本。为了明确这些里程碑版本不会在生产代码中使用，它们将发布到单独的仓库而不是Maven Central。\n所以当使用非GA以及GA以上版本时，可以在POM文件中添加配置。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; snapshots false 不使用快照版本。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E9%99%84spring%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8Amaven-spring-milestones%E4%BD%9C%E7%94%A8/","title":"附：Spring版本以及Maven spring-milestones作用"},{"content":"原文地址：https://www.cnblogs.com/qinlangsky/p/11445296.html\n关于linux中文显示为口的解决办法 环境为ubuntu bionic。armhf架构。\n新安装的环境在chromium中无法显示中文。经检查是缺少中文字体库导致的。\n解决步骤 1.从windows复制或主动下载中文字体库\nwindows字体库路径：C:\\Windows\\Fonts\n这里我自己选择的是宋体simsun.ttc这个文件\n2.在linux字体目录创建一个文件夹用于存放添加的字体库(Linux默认的字体目录：/usr/share/fonts)\ncd /usr/share/fonts\nmkdir fontpackages\n3.复制字体库到新建的字体库目录\ncp simsun.tcc /usr/share/fonts/fontpackages\n4.加载字体库中的字体\nfc-cache -fv\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E5%85%B3%E4%BA%8Elinux%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%BA%E5%8F%A3%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"关于linux中文显示为口的解决办法"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\naigoV https://blog.csdn.net/aigoV/article/details/89884501 本文仅仅作为学习maven相关内容学习笔记使用。\nMaven 1.GroupId(Group):\n项目所属组织的唯一标识符，对应项目中java的包结构（main目录里java的目录结构）。一般是公司官网域名反写或组织名：比如com.baidu.项目名或com.aigov.项目名。\nGroupID定义了项目属于哪一个组。\n2.ArtifactId(Artifact):\n项目的唯一标识符，对应项目的名字，是项目根目录的名称。\nArtifactID定义了一个maven项目在组中的唯一id。\n3.Version\n指定项目当前的版本，SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。\n整理 在maven中，所有的依赖被处理成由Group、Artifact、Version三个标识所确定的坐标中。\n因此在个人项目中，应尽量避免使用与已存在的maven项目相同的标识。除非他们处于同一个组织或项目。\n另外一般包名与Group、Artifact会存在对应关系，所以起名时应注意包名起名规范。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E5%85%B3%E4%BA%8Emaven%E4%B8%AD%E7%9A%84groupartifactversion/","title":"关于maven中的Group、Artifact、Version"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\nxinwendewen https://blog.csdn.net/zwt0909/article/details/52218222 本文仅仅作为学习maven相关内容学习笔记使用。\nparent.relativePath 一般出现在pom文件，存在继承关系中。例如：\n1 2 3 4 5 6 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; 这里的relativePath表示依赖路径。默认值为../pom.xml。\n也就是说，默认是从上层项目中获取父依赖，当前项目为依赖的子项目。\n查找循序一般为relativePath地址–本地仓库–远程仓库。\n也就是将查找父项目。父项目不存在的话，查找本地仓库。本地仓库仍然不存在，则查找远程仓库，直至查找失败。\n而org.springframework.boot作为一个不存在本地的父项目。可以将relativePath的值设置为空。也就是。这样将始终从仓库中获取，不存本地路径中获取。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E5%85%B3%E4%BA%8Emaven%E4%B8%AD%E7%9A%84relativepath/","title":"关于maven中的relativePath"},{"content":"使用Dockerfile构建镜像 我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。\n1 2 3 4 5 6 7 8 9 10 FROM centos:6.7 MAINTAINER Fisher \u0026#34;fisher@sudops.com\u0026#34; RUN /bin/echo \u0026#39;root:123456\u0026#39; |chpasswd RUN useradd runoob RUN /bin/echo \u0026#39;runoob:123456\u0026#39; |chpasswd RUN /bin/echo -e \u0026#34;LANG=\\\u0026#34;en_US.UTF-8\\\u0026#34;\u0026#34; \u0026gt;/etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D 1.构建镜像 1 docker build -t lyoshur/ubuntu:test . 参数说明：\n-t ：指定要创建的目标镜像名 . ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径 2.设置镜像标签 1 docker tag 860c279d2fec lyoshur/ubuntu:test:dev docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。\n使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/","title":"使用Dockerfile构建镜像"},{"content":"创建websocket服务 依赖环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;dependencies\u0026gt; \u0026lt;!--netty的依赖集合，都整合在一个依赖里面了--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.6.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--这里使用jackson反序列字节码--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--加入log4j 便于深入学习整合运行过程的一些细节--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.首先创建管理线程和工作线程组 1 2 NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup work = new NioEventLoopGroup(); 2.创建服务启动器，并绑定管理线程和工作线程 1 2 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(boss,work); 3.将通道初始化为Nio 1 bootstrap.channel(NioServerSocketChannel.class); 4.配置通道初始化 1 bootstrap.childHandler(new NioWebSocketChannelInitializer()); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class NioWebSocketChannelInitializer extends ChannelInitializer\u0026lt;SocketChannel\u0026gt; { @Override protected void initChannel(SocketChannel ch) { // 设置log监听器，并且日志级别为debug，方便观察运行流程 ch.pipeline().addLast(\u0026#34;logging\u0026#34;, new LoggingHandler(\u0026#34;DEBUG\u0026#34;)); // 设置解码器 ch.pipeline().addLast(\u0026#34;http-codec\u0026#34;, new HttpServerCodec()); // 聚合器，使用websocket会用到 ch.pipeline().addLast(\u0026#34;aggregator\u0026#34;, new HttpObjectAggregator(65536)); // 用于大数据的分区传输 ch.pipeline().addLast(\u0026#34;http-chunked\u0026#34;, new ChunkedWriteHandler()); // 自定义的业务handler ch.pipeline().addLast(\u0026#34;handler\u0026#34;, new NioWebSocketHandler()); } } 5.自定义的业务handler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 public class NioWebSocketHandler extends SimpleChannelInboundHandler\u0026lt;Object\u0026gt; { private final Logger logger=Logger.getLogger(this.getClass()); private WebSocketServerHandshaker handshaker; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception { logger.debug(\u0026#34;收到消息：\u0026#34;+msg); if (msg instanceof FullHttpRequest){ //以http请求形式接入，但是走的是websocket handleHttpRequest(ctx, (FullHttpRequest) msg); }else if (msg instanceof WebSocketFrame){ //处理websocket客户端的消息 handlerWebSocketFrame(ctx, (WebSocketFrame) msg); } } @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { //添加连接 logger.debug(\u0026#34;客户端加入连接：\u0026#34;+ctx.channel()); ChannelSupervise.addChannel(ctx.channel()); } @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { //断开连接 logger.debug(\u0026#34;客户端断开连接：\u0026#34;+ctx.channel()); ChannelSupervise.removeChannel(ctx.channel()); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } private void handlerWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame){ // 判断是否关闭链路的指令 if (frame instanceof CloseWebSocketFrame) { handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); return; } // 判断是否ping消息 if (frame instanceof PingWebSocketFrame) { ctx.channel().write( new PongWebSocketFrame(frame.content().retain())); return; } // 本例程仅支持文本消息，不支持二进制消息 if (!(frame instanceof TextWebSocketFrame)) { logger.debug(\u0026#34;本例程仅支持文本消息，不支持二进制消息\u0026#34;); throw new UnsupportedOperationException(String.format( \u0026#34;%s frame types not supported\u0026#34;, frame.getClass().getName())); } // 返回应答消息 String request = ((TextWebSocketFrame) frame).text(); logger.debug(\u0026#34;服务端收到：\u0026#34; + request); TextWebSocketFrame tws = new TextWebSocketFrame(new Date().toString() + ctx.channel().id() + \u0026#34;：\u0026#34; + request); // 群发 ChannelSupervise.send2All(tws); // 返回【谁发的发给谁】 // ctx.channel().writeAndFlush(tws); } /** * 唯一的一次http请求，用于创建websocket * */ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) { //要求Upgrade为websocket，过滤掉get/Post if (!req.decoderResult().isSuccess() || (!\u0026#34;websocket\u0026#34;.equals(req.headers().get(\u0026#34;Upgrade\u0026#34;)))) { //若不是websocket方式，则创建BAD_REQUEST的req，返回给客户端 sendHttpResponse(ctx, req, new DefaultFullHttpResponse( HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return; } WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( \u0026#34;ws://localhost:8081/websocket\u0026#34;, null, false); handshaker = wsFactory.newHandshaker(req); if (handshaker == null) { WebSocketServerHandshakerFactory .sendUnsupportedVersionResponse(ctx.channel()); } else { handshaker.handshake(ctx.channel(), req); } } /** * 拒绝不合法的请求，并返回错误信息 * */ private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res) { // 返回应答给客户端 if (res.status().code() != 200) { ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); } ChannelFuture f = ctx.channel().writeAndFlush(res); // 如果是非Keep-Alive，关闭连接 if (!isKeepAlive(req) || res.status().code() != 200) { f.addListener(ChannelFutureListener.CLOSE); } } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8netty%E5%88%9B%E5%BB%BAwebsocket%E6%9C%8D%E5%8A%A1/","title":"使用Netty创建websocket服务"},{"content":"黑苹果安装 下载镜像以及破解补丁\n1.复制破解补丁到VM安装目录 执行安装，成功后会在 tools目录生成\n1 2 darwin.iso darwinPre15.iso 2.安装镜像，版本选择10.8 3.修改macOS.vmx 在配置文件最后，加入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 smc.version = \u0026#34;0\u0026#34; cpuid.0.eax = \u0026#34;0000:0000:0000:0000:0000:0000:0000:1011\u0026#34; cpuid.0.ebx = \u0026#34;0111:0101:0110:1110:0110:0101:0100:0111\u0026#34; cpuid.0.ecx = \u0026#34;0110:1100:0110:0101:0111:0100:0110:1110\u0026#34; cpuid.0.edx = \u0026#34;0100:1001:0110:0101:0110:1110:0110:1001\u0026#34; cpuid.1.eax = \u0026#34;0000:0000:0000:0001:0000:0110:0111:0001\u0026#34; cpuid.1.ebx = \u0026#34;0000:0010:0000:0001:0000:1000:0000:0000\u0026#34; cpuid.1.ecx = \u0026#34;1000:0010:1001:1000:0010:0010:0000:0011\u0026#34; cpuid.1.edx = \u0026#34;0000:0111:1000:1011:1111:1011:1111:1111\u0026#34; smbios.reflectHost = \u0026#34;TRUE\u0026#34; hw.model = \u0026#34;MacBookPro14,3\u0026#34; board-id = \u0026#34;Mac-551B86E5744E2388\u0026#34; usb_xhci:1.speed = \u0026#34;2\u0026#34; usb_xhci:1.present = \u0026#34;TRUE\u0026#34; usb_xhci:1.deviceType = \u0026#34;hub\u0026#34; usb_xhci:1.port = \u0026#34;1\u0026#34; usb_xhci:1.parent = \u0026#34;-1\u0026#34; usb_xhci:3.speed = \u0026#34;4\u0026#34; usb_xhci:3.present = \u0026#34;TRUE\u0026#34; usb_xhci:3.deviceType = \u0026#34;hub\u0026#34; usb_xhci:3.port = \u0026#34;3\u0026#34; usb_xhci:3.parent = \u0026#34;-1\u0026#34; keyboard.vusb.enable = \u0026#34;TRUE\u0026#34; mouse.vusb.enable = \u0026#34;TRUE\u0026#34; usb:0.present = \u0026#34;TRUE\u0026#34; usb:0.deviceType = \u0026#34;hid\u0026#34; usb:0.port = \u0026#34;0\u0026#34; usb:0.parent = \u0026#34;-1\u0026#34; 同时需要将 virtualHW.version = \u0026ldquo;16\u0026rdquo; 改成 virtualHW.version = \u0026ldquo;10\u0026rdquo;\n4.USB兼容性配置，切换成USB2.0 5.抹除虚拟磁盘 点击磁盘工具，找到VM虚拟磁盘，点击抹除。然后开始安装系统\n6.安装VMtools 使用CD驱动器加载 破解补丁中的 darwin.iso 进行安装。\n1 2 3 sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES sudo defaults delete /Library/Preferences/com.apple.windowserver DisplayResolutionDisabled /Library/Application\\ Support/VMware\\ Tools/vmware-resolutionSet 3416 1920 参考某一个教程，执行了这三条命令，前两条执行正常，最后一个执行报错 unable to find the server\n最后在 系统 安全和隐私 启用了 VMTools 重启就正常了，怀疑命令是没啥用\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8vm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%95%99%E7%A8%8B/","title":"使用VM虚拟机安装黑苹果教程"}]