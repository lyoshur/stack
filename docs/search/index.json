[{"content":"spring事务 Spring 之中除了设置事务的「隔离级别」之外，还可以额外配置事务的「传播特性」。\nSpring支持以下7种事务传播行为：\npropagation-required：支持当前事务，如果有就加入当前事务中；如果当前方法没有事务，就新建一个事务。\n【note】required 必须的，所以会加入一个事务，加入不了就新建。\npropagation-supports：支持当前事务，如果有就加入当前事务中，如果当前方法没有事务，就以非事务的方法运行。\n【note】supports 支持，有事务支持加入，没有就算了\npropagation-mandatory：支持当前事务，如果有就加入到当前事务，如果房前没有事务，就抛出异常。\n【note】mandatory 强制，当前有事务就算了，要是没有就哭给你看\npropagation-requires_new：新建事务，如果当前存在事务，就把当前事务挂起，如果当前方法不存在事务，就新建事务\n【note】就是要一个新的，旧的不要\npropagation-not-supported：以非事务的方法运行，如果当前方法有事务，则挂起当前事务，如果当前没有事务，则已非事务的方法运行\n【note】不管有没有，我都不用\npropagation-never：以非事务方式运行，如果当前方法存在事务，则抛出异常。如果不存在，就以非事务的方式运行\n【note】我不要，给就哭\npropagation-nested：如果当前方法有事务,则在嵌套事务内执行;如果当前方法没有事务，就新建一个事务\n【note】nested 嵌套\n【重要】！！！！在同一个类中，一个方法调用另外一个有注解（比如@Async，@Transational）的方法，注解是不会生效的\n在一个Service内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务\n","date":"2022-08-25T14:41:00Z","permalink":"https://lyoshur.github.io/stack/p/spring%E4%BA%8B%E5%8A%A1/","title":"spring事务"},{"content":"spring中的异步方法 @Async注解可以使被修饰的方法成为异步方法，曾经看到一个文章说，异步方法让编程提升了一个台阶，确实在实际项目中，异步方法可以很大的提高用户体验，使用效率，不再是那个一个依赖另一个串行任务，在前一个任务不知道什么时候完成时在那傻等，然而彼此间没有什么强依赖关系。\n1 配置异步编程 1 2 3 4 5 6 7 8 9 10 11 12 13 // 基于Java配置的启用方式： @Configuration @EnableAsync public class SpringAsyncConfig { ... } // Spring boot启用： @EnableAsync @EnableTransactionManagement public class SettlementApplication { public static void main(String[] args) { SpringApplication.run(SettlementApplication.class, args); } } 2 使用@Async方法来处理问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class DeviceProcessServiceImpl impleme nts DeviceProcessService { @Autowired private DeviceRpcService deviceRpcService; @Async(\u0026#34;taskExecutor\u0026#34;) @Override public Future\u0026lt;Map\u0026lt;Long, List\u0026lt;ProcessDTO\u0026gt;\u0026gt;\u0026gt; queryDeviceProcessAbilities(List\u0026lt;BindDeviceDO\u0026gt; bindDevices) { if (CollectionUtils.isEmpty(bindDevices)) { return new AsyncResult\u0026lt;\u0026gt;(Maps.newHashMap()); } List\u0026lt;Long\u0026gt; deviceIds = bindDevices.stream().map(BindDeviceDO::getDeviceId).collect(Collectors.toList()); List\u0026lt;DeviceInstanceWithProcessResp\u0026gt; devices = deviceRpcService.getDeviceProcessAbility(deviceIds); Map\u0026lt;Long, List\u0026lt;ProcessDTO\u0026gt;\u0026gt; deviceAbilityMap = Maps.newHashMap(); ... return new AsyncResult\u0026lt;\u0026gt;(deviceAbilityMap); } } 注意返回值为Future\n原文章中，提到加了注解但是不生效的问题，但实际上@Async注解和事务注解一样，Spring在生成动态代理类时，当入口方法没有异步注解，通过一个同步方法去调用一个同类的异步方法，是无法使这个方法异步执行的。\n","date":"2022-08-25T14:41:00Z","permalink":"https://lyoshur.github.io/stack/p/spring%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/","title":"spring中的异步方法"},{"content":"mysql事务 1 事务的ACID 与数据库的事务同时为大众熟知的是ACID。即数据库的原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)。就像应用内为了线程之间的互斥，线程安全等，需要做大量的工作，数据库为了 ACID，也做了许多的工作。\n原子性(Atomicity)\n一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n一致性(Consistency)\n在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n隔离性(Isolation)\n隔离性还有其他的称呼，如并发控制（concurrency control）、可串行化（serializability）、锁（locking）。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。当前数据库系统中都提供了一种粒度锁（granular lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。\n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括:\n读未提交（Read uncommitted） 读提交（read committed） 可重复读（repeatable read） 串行化（Serializable） 持久性(Durability)\nmysql默认的事务隔离级别是 可重复读（repeatable read）。\n2 事务的分类 从理论的角度来说，可以把事务分为一下几种类型\n扁平事务（flat transactions）\n带有保存点的扁平事务（flat transactions with savepoints）\n链事务（chained transactions）\n嵌套事务（nested transactions）\n分布式事务（distributed transactions）\n2.1 扁平事务 对于扁平事务来说，其隐式地设置了一个保存点，但是在整个事务中，只有这一个保存点，回滚只能回滚到事务开始时的状态。保存点用SAVE WORK函数来建立，通知系统记录当前的处理状态。\n2.2 带有保存点的扁平事务 允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。\n2.3 链事务 链事务可视为保存点模式的一个变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为其保存点是易失的（volatile），而非持久的（persistent）。这意味着当恢复保存点时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。\n链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。\n2.4 嵌套事务 嵌套事务是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。\n嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。\n处在叶节点的事务是扁平事务，但是每个子事务从根到叶节点的距离可以是不同的。\n位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱（predecessor）称为父事务（parent），事务的下一层称为儿子事务（child）。\n子事务既可以提交也可以回滚，但是它的提交操作并不马上生效，除非由其父事务提交。因此可以推论出，任何子事务都在顶层事务提交后才真正提交。\n树中的任意一个事务的回滚会引起它的所有子事务一同回滚。故子事务仅保留A、C、I特性，不具有D特性。\n在Moss的理论中，实际的工作交由叶节点来完成，即只有叶节点的事务才能访问数据库、发送消息、获取其他类型的资源。而高层的事务仅负责逻辑控制，决定何时调用相关的子事务。即使一个系统不支持嵌套事务，用户也可以通过保存点技术来模拟嵌套事务\n2.5 分布式事务 分布式事务通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。\n3 事务控制语句 在MySQL命令行的默认设置下，事务都是自动提交（auto commit）的，即执行SQL语句后就会马上执行COMMIT操作。因此要显式地开启一个事务须使用命令BEGIN和START TRANSACTION，或者执行命令SET AUTOCOMMIT=0，以禁用当前会话的自动提交。\nSTART TRANSACTION | BEGIN：显式地开启一个事务。\nCOMMIT：要想使用这个语句的最简形式，只需发出COMMIT。也可以更详细一些，写为COMMIT WORK，不过这二者几乎是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的。\nROLLBACK：要使用这个语句的最简形式，只需发出ROLLBACK。同样地，也可以写为ROLLBACK WORK，但是二者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。\nSAVEPOINT identifier：SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。\nRELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这句语句时，会抛出一个异常。\nROLLBACK TO [SAVEPOINT] identifier ：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。例如可以发出两条UPDATE语句，后面跟一个SAVEPOINT，然后又是两条DELETE语句。如果执行DELETE语句期间出现了某种异常情况，而且捕获到这个异常，并发出ROLLBACK TO SAVEPOINT命令，事务就会回滚到指定的SAVEPOINT，撤销DELETE完成的所有工作，而UPDATE语句完成的工作不受影响。\nSET TRANSACTION：这个语句用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。\nSTART TRANSACTION和BEGIN语句都可以在MySQL命令行下显式地开启一个事务。但是在存储过程中，MySQL数据库的分析器会自动将BEGIN识别为BEGIN \u0026hellip;END，因此在存储过程中只能使用START TRANSACTION语句来开启一个事务。\nCOMMIT和COMMIT WORK语句基本上是一致的，都用来提交事务。不同之处在于COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。用户可以通过参数completion_type来进行控制:\n该参数为0，表示没有任何操作。在这种设置下，COMMIT和COMMIT WORK是完全等价的。\n当参数completion_type的值为1时，COMMIT WORK等同于COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务\n参数completion_type为2时，COMMIT WORK等同于COMMIT AND RELEASE。当事务提交后会自动断开与服务器的连接\n4 事务的隔离级别详解 ISO和ANSI SQL标准制定了四种事务隔离级别的标准，但是很少有数据库厂商遵循这些标准。比如Oracle数据库就不支持READ UNCOMMITTED和REPEATABLE READ的事务隔离级别。\nREAD UNCOMMITTED\nREAD UNCOMMITTED被称为浏览访问（browse access），仅仅只是对事务而言的\nREAD COMMITTED\nREAD COMMITTED被称为游标稳定（cursor stability）\nREPEATABLE READ\nREPEATABLE READ是2.9999°的隔离，没有幻读的保护\nSERIALIZABLE\nSERIALIZABLE被称为隔离，或3°的隔离。SQL和SQL2标准的默认事务隔离级别是SERIALIZABLE\nInnoDB存储引擎默认的支持隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock的锁算法，因此避免了幻读的产生。所以说，InnoDB存储引擎在默认的REPEATABLE READ事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。\n5 分布式事务编程 InnoDB存储引擎提供了对于XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源 （transactional resources） 参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。\nXA事务允许不同数据库之间的分布式事务，如一台服务器是MySQL数据库的，另一台是Oracle数据库的，可能还有一台服务器是SQL Server数据库的，只要参与到全局事务中的每个节点都支持XA事务即可。\nXA事务由一个或多个资源管理器（resource manager）、一个事务管理器（transaction manager）以及一个应用程序（application program）组成。\n资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。\n事务管理器：协调参与全局事务中的各个事务。需要和参与到全局事务中的所有资源管理器进行通信。\n应用程序：定义事务的边界，指定全局事务中的操作。\n在MySQL数据库的分布式事务中，资源管理器就是MySQL数据库，事务管理器为连接到MySQL服务器的客户端。\n分布式事务使用两段式提交（two-phase commit）的方式。在第一个阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好提交了。第二个阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。可见与本地事务不同的是，需要多一次的PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或ROLLBACK操作。\n","date":"2022-08-25T13:36:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySQL事务"},{"content":"第二章 JCF中的Queue、Deque集合 Queue（队列）、Deque（双端队列）集合是JCF中另一种重要的集合。\n队列存储的数据允许从结构的一端进行添加操作（入队操作），并且从结构的另一端进行移除操作（出队操作）。进行入队操作的一端称为队列尾部；进行出队操作的一端称为队列头部。双端队列是指可以在一端既进行入队操作，又进行出队操作的队列结构。\n注意：队列和双端队列都不允许在除了队列头部或队列尾部的其他索引位上进行数据的读/写操作。在JCF中，具有队列操作特性的集合都实现或间接实现了java.util.Queue接口；具有双端队列操作特性的集合都实现或间接实现了java.util.Deque接口。\njava.util.ArrayDeque集合和java.util.PriorityQueue队列分别是Queue（队列）接口和Deque（双端队列）接口在JCF中的基础集合。ArrayDeque集合为了保证对已有数组控件的充分利用，使用的是可循环的双指针数组（但不代表不进行扩容操作）；PriorityQueue队列使用的是小顶堆结构，对基于权值的排序性能进行了优化。\n1 ArrayDeque ArrayDeque集合是从JDK 1.6开始推出的，它是一个基于数组（可扩容的数组）结构实现的双端队列。与普通的数组结构相比，这种数组结构是一种可循环使用的数组结构，可以有效减少数组扩容的次数。ArrayDeque集合是线程不安全的，不能在多线程场景中使用。\nArrayDeque集合既有队列、双端队列的操作特点，又有栈结构的操作特点。因此在JDK 1.6发布后，ArrayDeque集合是官方推荐的继Stack集合和LinkedList集合后，用于进行栈结构操作的新集合。\n2 PriorityQueue PriorityQueue队列是基于堆结构构建的，具体来说，是基于数组形式的小顶堆构建的。它保证了在每次添加新数据对象、移除已有数据对象后，集合都能维持小顶堆的结构特点。\n","date":"2022-08-22T14:48:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84queuedeque%E9%9B%86%E5%90%88/","title":"第二章 JCF中的Queue、Deque集合"},{"content":"第六章 JUC的必要组成部分 JUC的体系结构分为多层，底层Native JNI外的上层分别由多个关键技术模块构成：AQS、CAS、LockSupport和句柄（JDK 9开始提供变量句柄）等。\n基于park的线程控制 juc.locks.LockSupport\nLockSupport工具类属于AQS框架的底层支持部分，主要用于进行线程元语级别的执行/阻塞控制。LockSupport工具类的主要方法有两个，分别为park()方法和unpark()方法。park()方法主要用于使当前线程进入阻塞状态，unpark()方法（及其重载方法）主要用于使指定线程退出阻塞状态。\nAQS\n需要LockSupport和CAS支撑\n由unsafe直接提供的CAS操作\nVarHandle和MethodHandle\n基于Object Monitor的线程控制\n变量句柄VarHandle是从JDK 9开始引入的较新技术，它具有Unsafe工具类的部分功能特性，为程序员进行变量的原子性操作、可见性操作（内存屏障方式）提供了一种新的途径。变量句柄VarHandle可以与任意字段、数组变量、静态变量进行关联，支持在不同访问模型中对这些变量的访问（包括但不限于简单的read/write访问、使用volatile修饰的read/write访问等。变量句柄VarHandle是Java官方推荐的，可以由程序员直接使用的编程工具，不用担心它像Unsafe工具类一样突破Java的安全性限制。\n在这些关键技术模块的上层，JUC提供了多种可以在高并发场景中直接使用的工具类，这些工具类主要分为如下五个维度。\n信号：这些工具类主要基于AQS技术，用于解决线程间的同步和互斥问题，即解决多个线程的执行顺序控制问题。j.u.c.Semaphore类、j.u.c.CyclicBarrier类、j.u.c.CountDownLatch类都属于这方面的工具类\n高并发场景中的JCF：这些工具类是Java官方建议在高并发场景中优先考虑使用的工具类，如j.u.c.ConcurrentHashMap类、j.u.c.ConcurrentSkipListMap类、j.u.c.ArrayBlockingQueue类等\n线程管理/执行：这些工具类主要用于帮助应用程序控制线程规模，保证应用程序在高并发场景中不会开启过多线程，从而导致线程切换占用过多CPU资源，即帮助应用程序在线程规模和系统性能之间保持平衡。这些工具类包括我们经常使用的各类线程池线程管理工具类，如j.u.c.ThreadPoolExecutor类\n线程/数据控制：这些工具类主要用于完成数据在各线程间的传递工作，或者帮助调用者完成线程间的异步调用工作，并且跟踪处理的状态和数据。这些工具类和信号工具类最大的区别是，前者着眼于一个线程，如果获得其他线程中的数据，并且对这些线程的执行顺序没有过多的要求，那么无论线程的运行先后顺序如何，数据都应该被正确传递。j.u.c.LinkedTransferQueue、j.u.c.Exchanger、j.u.c.Callable等类或接口都属于这个类型的工具类\n原子性操作（无锁）：高并发场景中的操作原子性是编程过程中需要关注的另一个问题。JUC中有一个子工具箱java.util.concurrent.atomic，主要用于解决原子性操作问题，基本设计思想是CAS。\n1 volatile修饰符 JUC主要依靠volatile修饰符解决内存可见性问题，更确切地说是依靠volatile修饰符背后隐含的各种形式的内存屏障来解决内存可见性问题。volatile修饰符主要用于以下场景中。\n在多线程场景中，需要保证共享数据内存可见性的场景。\n需要避免指令重排的场景（实际用于应对有序性问题）。\n2 MESI协议（CPU缓存一致性协议） 3 内存屏障（Memory Barrier） LoadLoad Barrier（Load Memory Barrier）：该内存屏障主要用于保证高速缓存行在进行本地读操作时的内存可见性，即保证屏障后的本地读操作结果一定是最新的数据结果。具体做法如下。一旦本地CPU内核发现执行了LoadLoad Barrier，则本地CPU内核将强制等待，直到失效队列（Invalid Queue）中所有应更新为I状态的操作全部执行完毕，才会继续执行后续读操作指令。这样，本地高速缓存行中后续读取的数据和内存中最新的数据就可以保持一致了。\nStoreStore Barrier（Store Memory Barrier）：该内存屏障主要用于保证高速缓存行在进行本地写操作时的数据可见性，即保证屏障后的本地写操作对其他高速缓存行可见。\nStoreLoad Barrier（Full Barrier）：该内存屏障的性能不高，但是可以保证数据一致性，是操作系统提供的通用屏障。\nLoadStore Barrier：在对存储缓存和失效队列的操作层面上，LoadStore Barrier和LoadLoad Barrier（Load Memory Barrier）没有太大的区别，但是LS对指令重排做出了不同的限制\n4 指令重排 StoreStore Barrier（Store Memory Barrier）：该内存屏障可以保证，在内存屏障前的任意写操作不会被重排到该内存屏障后的任意写操作的后面；在内存屏障后的任意写操作不会被重排到该内存屏障前的任意写操作的前面。\nLoadLoad Barrier（Load Memory Barrier）：该内存屏障可以保证，在内存屏障前的任意读操作不会被重排到该内存屏障后的任意读操作的后面；在内存屏障后的任意读操作不会被重排到该内存屏障前的任意读操作的前面。\nLoadStore Barrier：该内存屏障对存储缓存和失效队列的操作效果和LoadLoad Barrier的效果类似，但对指令重排层面上的效果是不一样的。该内存屏障可以保证，在内存屏障前的任意读操作不会被重排到该内存屏障后的任意写操作的后面；保证在内存屏障后的任意写操作不会被重排到该内存屏障前的任意读操作的前面。\nStoreLoad Barrier（Full Barrier）：该内存屏障又称为通用屏障，其禁止重排的效果是，可以保证在内存屏障前的任意写操作不会被重排到该内存屏障后的任意读操作的后面；该内存屏障后的任意读操作不会被重排到该内存屏障前的任意写操作的前面。\n5 Java提供的内存栅栏 存储栅栏（storeStore Fence，VarHandle.storeStoreFence()）：存储栅栏在编译器中的禁止重排效果和Store Memory Barrier基本内存屏障的禁止重排效果一致，即对内存屏障前的任意写操作和当前内存屏障后的任意写操作禁止重排。 加载栅栏（loadLoad Fence，VarHandle.loadLoadFence()）：加载栅栏在编译器中的禁止重排效果和Load Memory Barrier基本内存屏障的禁止重排效果一致，即对内存屏障前的任意读操作和当前内存屏障后的任意读操作禁止重排。 获取栅栏（acquire Fence，VarHandle.acquireFence()）：该栅栏的禁止重排效果是LoadLoad Barrier+LoadStore Barrier的禁止重排效果的组合。它可以对内存屏障后的任意读/写操作和当前内存屏障前的任意读操作禁止重排。 释放栅栏（release Fence，VarHandle.releaseFence()）：该栅栏的禁止重排效果是StoreStore Barrier+LoadStore Barrier的禁止重排效果组合。它可以对内存屏障前的任意读/写操作和当前内存屏障后的任意写操作禁止重排。 全栅栏（full Fence，VarHandle.fullFence()）：该栅栏是存储栅栏（storeStore Fence）+加载栅栏（loadLoad Fence）+通用屏障（StoreLoad Barrier）的禁止重排效果组合，它可以对内存屏障前的任意读/写操作和当前内存屏障后的任意读/写操作禁止重排。 ","date":"2022-08-22T14:48:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-juc%E7%9A%84%E5%BF%85%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/","title":"第六章 JUC的必要组成部分"},{"content":"第三章 JCF中的Map集合 JCF中的Map集合和Set集合之间存在非常密切的关联关系，从相应集合的命名可以看出来，如HashMap集合和HashSet集合、TreeMap集合和TreeSet集合、LinkedHashMap集合和LinkedHashSet集合、ConcurrentSkipListSet集合和ConcurrentSkipListMap集合。因此，如果搞清楚了JCF中的Map集合结构，就基本搞清楚了JCF中的Set集合结构。本书首先介绍JCF中具有代表性的Map集合，然后在此基础上针对性地介绍Set集合。\nTreeMap集合是基于红黑树结构构造的，HashMap集合和LinkedHashMap集合是基于数组+链表+红黑树的复合结构构造的，这两种集合的区别仅体现在LinkedHashMap集合中增加了一个虚拟的链表结构。\n1 java.utiI.Map接口 java.util.Map接口是JCF中Map集合的顶层接口，它给出了Map体系中的基本操作功能，并且要求下层具体的Map集合对其进行实现\nV put(K key, V value);\nvoid clear();\nV get(Object K);\nint size();\nboolean isEmpty();\n2 java.utiI.SortedMap接口 3 java.utiI.NavigabIeMap接口 4 java.utiI.AbstractMap抽象类 java.util.AbstractMap抽象类是实现了java.util.Map接口的一个抽象类，主要用于向下层具体的Map集合提供一些默认的功能逻辑，以便减少具体Map集合的构建源码量，从而降低实现具体Map集合的难度。\n5 TreeMap TreeMap集合是基于红黑树构建的，其集合内的所有K-V键值对节点都是这棵红黑树上的节点。这些K-V键值对节点的排列顺序主要基于两种逻辑考虑：第一种是基于K-V键值对节点中Key键信息的Hash值，第二种是基于使用者设置的java.util.Comparator接口实现的比较结果。选择哪种排序逻辑取决于TreeMap集合在实例化时使用哪个构造方法。\n【note】这里指的插入这个Map的数据，会根据java.util.Comparator进行排序，并且，当进行元素查找时，是在树上进行查找。而不是按照hash的方式。\n6 LinkedHashMap LinkedHashMap集合继承自HashMap集合，也就是说，前者和后者的基本结构一致。在HashMap集合的基础上，LinkedHashMap集合提供了一个新的特性，用于保证整个集合内部各个节点可以以某种顺序进行遍历（迭代器支持）。\n【note】这里很奇怪。为什么jdk不提供一个ArrayHashMap\n","date":"2022-08-22T14:48:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84map%E9%9B%86%E5%90%88/","title":"第三章 JCF中的Map集合"},{"content":"第四章 JCF中的Set集合 Set集合中几个重要的接口和抽象类:\njava.util.SortedSet接口\n如果某个具体的Set集合实现了java.util.SortedSet接口，就表示该集合中的数据对象会按照某种比较方法进行全局性的有序排列。实现了java.util.SortedSet接口的集合都提供了以下两种比较方法。\n使用一个实现了Comparable接口的类的对象进行比较。这个对象来源于集合中K-V键值对节点的Key键信息。 通过在集合实例化时设置的Comparator比较器进行比较。如果要采用这种方法，那么Set集合需要实现java.util.SortedSet接口。 java.util.NavigableSet接口\njava.util.NavigableSet接口是java.util.SortedSet接口的子级接口，可以将其理解成支持基于参照对象进行引导操作的Set集合。也就是说，在满足集合中对象有序组织的前提下，可以参照指定的数据对象进行集合中各数据对象的读/写操作。例如，可以参照集合中已有的数据对象X，查询集合中所有值小于或等于该数据对象X权值的数据对象。保证基于参照数据对象进行引导操作的前提是集合中的数据对象按照一定的顺序排列，这也就解释了为什么java.util.NavigableSet接口是java.util.SortedSet接口的一个子级接口。\njava.util.AbstractSet抽象类\njava.util.AbstractSet抽象类存在的意义和java.util.AbstractMap抽象类存在的意义相似，主要是为了有效降低具体的Set集合的实现复杂度。该抽象类提供了一些通用方法的实现逻辑，包括equals()方法、hashCode()方法、removeAll()方法（在一般情况下，不需要在具体集合中对这些方法进行改动）。\n1 HashSet 2 LinkedHashSet 3 TreeSet ","date":"2022-08-22T14:48:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84set%E9%9B%86%E5%90%88/","title":"第四章 JCF中的Set集合"},{"content":"第五章 Object Monitor管程实现 为了在不同场景中保证多线程工作的安全性，Java主要基于两种思想进行线程安全性的设计：悲观锁思想和乐观锁思想。\n悲观锁 在任何时候都会有其他操作者同时要求操作资源，从而产生操作冲突。 如果没有绝对安全的资源独占前提，那么对资源的操作一定会出现问题。 乐观锁 并不是任何时候都有两个或多个操作者同时操作相同的资源，从而产生操作冲突。 即使操作结果存在错误也没有关系。可以通过对比预期值和实际值来确认操作的正误，如果出现错误，则放弃本次操作，重新操作即可。 悲观锁在Java中有两种典型的实现方式，一种是基于Object Monitor模式的资源操作方式，另一种是基于AQS技术的资源操作方式。\nJava中的乐观锁思想通常基于CAS（Compare and Swap，比较与交换）技术实现，但CAS进行比较的判定依据及比较后是否要进行重试，往往由操作者自行决定。所以在Java中，基于乐观锁工作的工具类都存在类似于for(;;)或while(true)的源码结构，这并不是BUG，而是为了匹配乐观锁的实现思想。\n1 Object Monitor Object Monitor模式是一种典型的悲观锁实现，使用Java对象模型中的特定区域对线程状态、对象状态的描述进行线程操作。\n所以Object Monitor模式并没有禁止指令重排，虽然有内存屏障控制synchronized代码块的重排特征（内存屏障的知识点会在后续讲解volatile修饰符时讲解），但synchronized代码块中的代码并没有禁止指令重排操作。\n虽然synchronized修饰符没有禁止源码在编译时的指令重排操作，但由于Object Monitor模式已经实现了在获取对象独占操作权的情况下，最多存在一个线程能够顺序执行，因此无论如何设计基于happens-before规则的JMM工作过程，单线程下的as-if-serial语义原则都可以得到保证。也就是说，Object Monitor模式将有序性问题的解决过程，简化成了在保证原子性的前提下，单线程遵循as-if-serial语义规则的执行过程，从而实现禁止与指令重排操作相似的效果。\n2 和同步块控制有关的对象结构 在HotSpot JVM的工作区中将对象结构分为3个区域\n对象头（Header）：实现Object Monitor管程控制模式的关键\nMarkword：运行时数据\n在64位JVM中，该区域在未压缩时占据对象头区域中的8字节，共64位，主要用于存储对象在运行时的数据，并且记录对象当前锁机制的相关信息。\nKlass：元数据指针\n是一个指针区域，这个指针区域指向元数据区中（JDK 1.8+）该对象所代表的类，这样JVM才知道这个对象是哪个类的实例，在未压缩时为8字节，共64位。\nLength：数组对象的数组长度\n（只有数组形式的对象会有这个区域）：如果一个对象是数组，那么这个区域表示数组长度，在未压缩时为8字节，共64位。\n对象实际数据（Instance Data）\nData：对象/数组对象的实际数据 对齐区（可能存在）\nPadding：对象填充区域 详细解释：\n对象头（Header）：对象头是本节重点讨论的部分，在不同操作系统中、不同JVM配置（如是否开启指针压缩）下，对象头的结构不完全一致。为了便于讲解，本书讨论64位JDK在64位操作系统中的内部结构（不考虑对象压缩）。\n对象实际数据：这个区域主要用于描述真实的对象数据，包括对象中的所有成员的属性信息，如其他对象的地址引用、基础数据类型的数据值。\n对齐区（Padding）：对齐区并不是必须存在的，它最大的作用是占位，因为HotSpot JVM要求被管理的对象的大小是8字节的整数倍，在某些情况下，需要对不足的对象区域进行填充。\n这里我们重点讨论和synchronized代码块加锁过程有关的Markword区域，首先说明以下两点。\n对象的锁状态不同，Markword区域的存储结构不同。例如，在对象处于轻量级锁状态的情况下，Markword区域的存储结构是一种；在对象处于偏向锁状态的情况下，Markword区域的存储结构是另一种。\nMarkword区域在64位JVM中和在32位JVM中的结构长度不同。\n程序员在Object Monitor模式下协调多个线程抢占同一个对象的独占操作权，就是通过改变该对象Markword区域中的数据实现的。线程在Object Monitor模式下的执行过程中，为了尽可能保证操作性能，对象的Markword区域还涉及一个锁机制的升级过程（又称为锁膨胀过程），升级顺序为偏向锁→轻量级锁→重量级锁。需要注意的是，偏向锁在JDK 15中已经确认被去掉。\n偏向锁实际上是在没有多个线程抢占指定对象独占操作权的情况下，完全取消对这个对象独占操作权的抢占工作。当前唯一请求对象独占操作权的线程，其线程ID会被对象记录到对象头的Markword区域中（使用CAS技术更新记录）。如果一直没有出现其他线程抢占对象独占操作权的情况，那么在当前synchronized代码块中基本不会出现针对独占权抢占工作的额外处理。\n3 锁粗化和锁消除 4 Object Monitor模式的控制结构 Entry Set\n第一个控制象限为待进入synchronized代码块的区域（Entry Set），停留在这个区域内的线程还没有获得对象的独占操作权，因此仍然停留在synchronized代码块外，即代码“synchronized(Object)”的位置。处于Entry Set区域内的线程，其线程状态被标识为BLOCKED\nOwner\n第二个控制象限为对象独占操作权持有区域（Owner），在对象的Object Monitor模式下，在同一时间最多有一个线程处于这个区域内，所以Object Monitor模式就会出现同一时间只能有一个线程在synchronize代码块内执行的效果。当前持有对象独占操作权的线程互斥量会被记录到该对象的对象头中。\nWait Set\n第三个象限为待授权区域（Wait Set），没有退出synchronized代码块，并且暂时没有对象独占操作权的线程会被放置到该区域内。注意对象独占操作权和抢占权之间的关系：如果某个线程使用wait()等方法释放了对象的独占操作权，那么只要这个线程没有退出synchronized代码块，在未来就有权被通知重新参与对象独占操作权的抢占工作。并不是处于待授权区域（Wait Set）的线程都可以重新参与对象独占操作权的抢占工作，只有使用notify()方法或类似方法被通知转移的线程才可以参与。需要注意的是，每个对象的Object Monitor模式检查过程相对独立，但是一个线程可以同时拥有一个或多个对象的独占操作权。\n5 as-if-serial语义原则与happens-before规则 as-if-seriaI语义原则\n如果进行重排，则会使单线程内的执行结果发生错误。这样的执行原则称为as-if-serial语义原则\nhappens-before规则\n线程安全的三性要求\n","date":"2022-08-22T14:48:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-object-monitor%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0/","title":"第五章 Object Monitor管程实现"},{"content":"Java并发编程 1 死锁的产生必须具备以下四个条件： 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。\n请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。\n不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才由自己释放该资源。\n环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链，即线程集合{T0, T1, T2, …, Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，……Tn正在等待已被T0占用的资源。\n要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可，但是学过操作系统的读者应该都知道，目前只有请求并持有和环路等待条件是可以被破坏的。\n2 JMM Java内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工作内存中的变量。\n3 锁 乐观锁 乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。\n悲观锁 排他锁 排他锁，又称为写锁、独占锁，是一种基本的锁类型。\n独占锁 共享锁 公平锁 非公平锁 自旋锁 由于Java中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取（默认次数是10，可以使用-XX:PreBlockSpinsh参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU时间换取线程阻塞与调度的开销，但是很有可能这些CPU时间白白浪费了。\n可重入锁 当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（在高级篇中我们将知道，严格来说是有限次数）地进入被该锁锁住的代码。\n4 LongAdder volatile解决了多线程内存不可见问题，对于一读多写，是可以解决变量同步问题的。但是对于一写多读同样无法解决线程安全问题。\n如果是JDK8推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。\n该类通过内部cells数组分担了高并发下多线程同时对一个原子变量进行更新时的竞争量，让多个线程可以同时对cells数组里面的元素进行并行的更新操作。另外，数组元素Cell使用@sun.misc.Contended注解进行修饰，这避免了cells数组内多个原子变量被放入同一个缓存行，也就是避免了伪共享，这对性能也是一个提升。\n5 LongAccumulator LongAdder类是LongAccumulator的一个特例，LongAccumulator比LongAdder的功能更强大。例如下面的构造函数，其中accumulatorFunction是一个双目运算器接口，其根据输入的两个参数返回一个计算值，identity则是LongAccumulator累加器的初始值。\n6 CopyOnWriteArrayList CopyOnWriteArrayList使用写时复制的策略来保证list的一致性，而获取—修改—写入三步操作并不是原子性的，所以在增删改的过程中都使用了独占锁，来保证在某个时间只有一个线程能对list数组进行修改。另外CopyOnWriteArrayList提供了弱一致性的迭代器，从而保证在获取迭代器后，其他线程对list的修改是不可见的，迭代器遍历的数组是一个快照。另外，CopyOnWriteArraySet的底层就是使用它实现的，感兴趣的读者可以查阅相关源码。\n7 LockSupport ","date":"2022-08-22T11:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","title":"Java并发编程"},{"content":"第3章 垃圾收集器与内存分配策略 说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：\n那些内存需要回收 如何回收 什么时候回收 1 那些内存需要回收 1.1 引用计数算法（Reference Counting） 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n1.2 可达性分析算法 这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。\n1.3 强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference） 在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。\n在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。\n软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。\n弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。\n虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。\n1.4 回收方法区 很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。\n2 如何回收 2.1 垃圾收集算法 标记-清除算法\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n复制算法(新生代)\n最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[插图]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间\n标记整理算法(老年代)\n复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n3 何时回收 安全点\n安全区\n4 垃圾收集器 Serial收集器\nSerial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。\n它依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效\nParNew收集器\nParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。\nParallel Scavenge收集器\n不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作\nParallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 +垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\nSerial Old收集器\nSerial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使\nParallel Old收集器\nParallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。\nCMS收集器\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些\nG1收集器\n","date":"2022-08-18T11:05:00Z","permalink":"https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","title":"第3章 垃圾收集器与内存分配策略"},{"content":"第4章 虚拟机性能监控与故障处理工具 1 JDK的命令行工具 jps：虚拟机进程状况工具 jstat：虚拟机统计信息监视工具 jinfo：Java配置信息工具 jmap：Java内存映像工具 jhat：虚拟机堆转储快照分析工具 jstack：Java堆栈跟踪工具 ","date":"2022-08-18T11:05:00Z","permalink":"https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/","title":"第4章 虚拟机性能监控与故障处理工具"},{"content":"第二章 自动内存管理机制 Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。\n1 运行时数据区域 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：\n方法区\n堆\n虚拟机栈\n本地方法栈\n程序计数器\n1.1 运行时常量池（Runtime Constant Pool） 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n1.2 直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。\n在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。\n2 对象的创建 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。\n两种分配方式：\n“指针碰撞”（Bump the Pointer）\n“空闲列表”（Free List）\n2.1 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）\n对象头 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表2-1。\n对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。\n实例数据 接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。\n对其填充 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n2.2 对象的访问定位 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。\n如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的.\n","date":"2022-08-18T11:05:00Z","permalink":"https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/","title":"第二章 自动内存管理机制"},{"content":"第二章 Java并发包之原子类型详解 1 AtomicInteger详解 AtomicInteger有两个构造，无参构造，初始值为0；以及带初始值的构造。\n方法：\nvoid set(int newValue)：为AtomicInteger的value设置一个新值，通过对前面内容的学习，我们知道在AtomicInteger中有一个被volatile关键字修饰的value成员属性，因此调用set方法为value设置新值后其他线程就会立即看见\nvoid lazySet(int newValue)：set方法修改被volatile关键字修饰的value值会被强制刷新到主内存中，从而立即被其他线程看到，这一切都应该归功于volatile关键字底层的内存屏障。内存屏障虽然足够轻量，但是毕竟还是会带来性能上的开销，比如，在单线程中对AtomicInteger的value进行修改时没有必要保留内存屏障，而value又是被volatile关键字修饰的，这似乎是无法调和的矛盾。幸好追求性能极致的JVM开发者们早就考虑到了这一点，lazySet方法的作用正在于此\nint getAndIncrement() i++\nint incrementAndGet() ++i\nint getAndDecrement() i\u0026ndash;\nint decrementAndGet() \u0026ndash;i\nboolean compareAndSet(int expect, int update)\n其中expect代表当前的AtomicInteger数值，update则是需要设置的新值，该方法会返回一个boolean的结果：当expect和AtomicInteger的当前值不相等时，修改会失败，返回值为false；若修改成功则会返回true\nint getAndAdd(int delta)\n原子性地更新AtomicInteger 的value值，更新后的value为value和delta之和\nint addAndGet(int delta)\n类似 i++和++i的区别\n自JDK1.8增加了函数式接口之后，AtomicInteger也提供了对函数式接口的支持。\nint getAndUpdate(IntUnaryOperator updateFunction)：原子性地更新AtomicInteger的值，方法入参为IntUnaryOperator接口，返回值为value更新之前的值。 int updateAndGet(IntUnaryOperator updateFunction)：原子性地更新AtomicInteger的值，方法入参为IntUnaryOperator接口，该方法会立即返回更新后的value值 int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)：原子性地更新AtomicInteger的值，方法入参为IntBinaryOperator接口和delta值x，返回值为value更新之前的值 int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)：该方法与getAndAccumulate类似，只不过会立即返回AtomicInteger的更新值 2 AtomicInteger内幕 Unsafe是由C++实现的，其内部存在着大量的汇编 CPU指令等代码，JDK实现的 Lock Free几乎完全依赖于该类\n【note】openjdk-jdk8u/hotspot/src/share/vm/prims/unsafe.cpp / openjdk-jdk8u/hotspot/src/os_cpu/bsd_x86/vm/atomic_bsd_x86.inline.hpp\n文件我们会找到相关的C++代码文件。java通过调用unsafe.cpp定义的方法，来完成cas操作，根本实现在和CPU相关的atomic_bsd_x86.inline.hpp中，里面会调用不同CPU架构下的汇编代码。\n3 AtomicBoolean详解 get()：获取AtomicBoolean的当前布尔值\nset(boolean newValue)：设置AtomicBoolean最新的value值，该新值的更新对其他线程立即可见\nlazySet(boolean newValue)：设置AtomicBoolean的布尔值\ngetAndSet(boolean newValue)：返回AtomicBoolean的前一个布尔值，并且设置新的值\ncompareAndSet(boolean expect, boolean update)\nweakCompareAndSet(boolean expect, boolean update)\n4TryLock显式锁的实现 类保存两个变量，一个AtomicBoolean，一个ThreadLocal。使用AtomicBoolean来进行cas，判断当前线程能否拿到锁。ThreadLocal用来存储当前线程是否拿到锁。\n两个方法 tryLock 和 release。\n5 AtomicLong详解 相对于compareAndSwapInt方法，在unsafe.cpp中，compareAndSwapLong方法多了条件编译SUPPORTS_NATIVE_CX8。SUPPORTS_NATIVE_CX8主要用于判断机器硬件是否支持8字节数字的cmpxchg CPU指令，如果机器硬件不支持，比如32位的CPU肯定不支持8字节64位数字的cmpxchg CPU指令，那么此时就需要判断当前JVM版本是否支持8字节数字的cmpxchg操作；如果机器硬件与当前JVM的版本都不支持，那么实际上针对long型数据的原子性操作将不会是Lock Free的，而是需要采用加锁的方式确保原子性。\n6 AtomicReference详解 AtomicReference类提供了对象引用的非阻塞原子性读写操作，并且提供了其他一些高级的用法。众所周知，对象的引用其实是一个4字节的数字，代表着在JVM堆内存中的引用地址。\n我们使用AtomicReference封装对象引用，每一次对AtomicReference的更新操作，我们都采用CAS这一乐观非阻塞的方式进行，因此也会存在对DebitCard对象引用更改失败的问题。CAS算法在此处就是要确保接下来要修改的对象引用是基于当前线程刚才获取的对象引用，否则更新将直接失败。\nget()：获取AtomicReference的当前对象引用值 set(V newValue)：设置AtomicReference最新的对象引用值，该新值的更新对其他线程立即可见 lazySet(V newValue)：设置AtomicReference的对象引用值 getAndSet(V newValue)：原子性地更新AtomicReference内部的value值，并且返回AtomicReference的旧值 compareAndSet(V expect, V update)：原子性地更新AtomicReference内部的value值，其中expect代表当前AtomicReference的value值，update则是需要设置的新引用值。该方法会返回一个boolean的结果，当expect和AtomicReference的当前值不相等时，修改会失败，返回值为false，若修改成功则会返回true getAndUpdate(UnaryOperator updateFunction)：原子性地更新value值，并且返回AtomicReference的旧值，该方法需要传入一个Function接口 updateAndGet(UnaryOperator updateFunction)：原子性地更新value值，并且返回AtomicReference更新后的新值，该方法需要传入一个Function接口 getAndAccumulate(V x, BinaryOperator accumulatorFunction)：原子性地更新value值，并且返回AtomicReference更新前的旧值。该方法需要传入两个参数，第一个是更新后的新值，第二个是BinaryOperator接口 accumulateAndGet(V x, BinaryOperator accumulatorFunction)：原子性地更新value值，并且返回AtomicReference更新后的值。该方法需要传入两个参数，第一个是更新的新值，第二个是BinaryOperator接口 7 AtomicStampedReference详解 截至目前我们已经学习了AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference这些原子类型，它们无一例外都采用了基于volatile关键字+CAS算法无锁的操作方式来确保共享数据在多线程操作下的线程安全性。\nvolatile关键字保证了线程间的可见性，当某线程操作了被volatile关键字修饰的变量，其他线程可以立即看到该共享变量的变化\nCAS算法，即对比交换算法，是由UNSAFE提供的，实质上是通过操作CPU指令来得到保证的。CAS算法提供了一种快速失败的方式，当某线程修改已经被改变的数据时会快速失败\n如何避免CAS算法带来的ABA问题呢？针对乐观锁在并发情况下的操作，我们通常会增加版本号，比如数据库中关于乐观锁的实现方式，以此来解决并发操作带来的ABA问题。在Java原子包中也提供了这样的实现AtomicStampedReference。\nAtomicStampedReference在构建的时候需要一个类似于版本号的int类型变量stamped，每一次针对共享数据的变化都会导致该stamped的增加（stamped的自增维护需要应用程序自身去负责，AtomicStampedReference并不提供），因此就可以避免ABA问题的出现，AtomicStampedReference的使用也是极其简单的，创建时我们不仅需要指定初始值，还需要设定stamped的初始值，在AtomicStampedReference的内部会将这两个变量封装成Pair对象。\ngetReference()：获取当前引用值，等同于其他原子类型的get方法 getStamp()：获取当前引用值的stamp数值 V get(int[] stampHolder)：这个方法的意图是获取当前值以及stamp值，但是Java不支持多值的返回，并且在AtomicStampedReference内部Pair被定义为私有的，因此这里就采用了传参的方式来解决（个人觉得这样的方法设计不算优雅，作者如果不想暴露Pair，完全可以再定义一个专门用于返回value和stamp对的public对象） compareAndSet(V expectedReference, V newReference,int expectedStamp, int newStamp)：对比并且设置当前的引用值，这与其他的原子类型CAS算法类似，只不过多了expectedStamp和newStamp，只有当expectedReference与当前的Reference相等，且expectedStamp与当前引用值的stamp相等时才会发生设置，否则set动作将会直接失败 weakCompareAndSet (V expectedReference, V newReference, int expectedStamp, int newStamp)：同上 set(V newReference, int newStamp)：设置新的引用值以及stamp attemptStamp(V expectedReference, int newStamp)：该方法的主要作用是为当前的引用值设置一个新的stamp，该方法为原子性方法 熟悉数据库开发的朋友肯定知道在多线程或者多系统中，同时对数据库的某条记录进行更改的时候，我们一般是采用乐观锁的方式，即为该记录增加版本号字段，比如如下的更新操作，其实AtomicStampedReference的实现原理也是这样的\n1 UPDATE TABLE TAB SET X=newValue, VERSION=VERSION+1 WHERE X=oldValue AND VERSION=expectedVersion 8 AtomicArray详解 在Java原子包中提供了相应的原子性操作数组元素相关的类\nAtomicIntegerArray：提供了原子性操作int数据类型数组元素的操作\nAtomicLongArray：提供了原子性操作long数据类型数组元素的操作\nAtomicReferenceArray：提供了原子性操作对象引用数组元素的操作\n9 AtomicFieldUpdater详解 在Java的原子包中提供了三种原子性更新对象属性的类\nAtomicIntegerFieldUpdater：原子性地更新对象的int类型属性，该属性无须被声明成AtomicInteger\nAtomicLongFieldUpdater：原子性地更新对象的long类型属性，该属性无须被声明成AtomicLong\nAtomicReferenceFieldUpdater：原子性地更新对象的引用类型属性，该属性无须被声明成AtomicReference\n1 2 AtomicIntegerFieldUpdater\u0026lt;Alex\u0026gt; updater = AtomicIntegerFieldUpdater.newUpdater(Alex.class, \u0026#34;salary\u0026#34;); int result = updater.addAndGet(alex, 1); 注意事项：AtomicFieldUpdater在使用上非常简单，其内部实现原理也是很容易理解的，但是并不是所有的成员属性都适合被原子性地更新\n未被volatile关键字修饰的成员属性无法被原子性地更新 类变量无法被原子性地更新 无法直接访问的成员属性不支持原子性地更新 final修饰的成员属性无法被原子性地更新 父类的成员属性无法被原子性地更新 10 sun.misc.Unsafe详解 Java是一种安全的开发语言，Java的设计者在设计之初就想将一些危险的操作屏蔽掉。比如对内存的手动管理，但是本章所学习的原子类型，甚至在接下来的章节中将要学习到的并发工具、并发容器等在其底层都依赖于一个特殊的类sun.misc.Unsafe，该类是可以直接对内存进行相关操作的，甚至还可以通过汇编指令直接进行CPU的操作。\nsun.misc.Unsafe提供了非常多的底层操作方法，这些方法更加接近机器硬件（CPU/内存），因此效率会更高。不仅Java本身提供的很多API都对其有严重依赖，而且很多优秀的第三方库/框架都对它有着严重的依赖，比如LMAX Disruptor，不熟悉系统底层，不熟悉C/C++汇编等的开发者没有必要对它进行深究，但是这并不妨碍我们直接使用它。在使用的过程中，如果使用不得当，那么代价将是非常高昂的，因此该类被命名为Unsafe也就在情理之中了，总之一句话，你可以用，但请慎用！\n绕过类构造函数完成对象创建 直接修改内存数据 类的加载 11 本章总结 本章非常详细地讲解了Java原子类型包中的所有原子类型的原理以及用法，原子类型包为我们提供了一种无锁的原子性操作共享数据的方式，无锁的操作方式可以减少线程的阻塞，减少CPU上下文的切换，提高程序的运行效率，但是这并不是一条放之四海皆准的规律，比如，同样被synchronized关键字同步的共享数据和原子类型的数据在单线程运行的情况下，synchronized关键字的效率却要高很多，究其原因是synchronized关键字是由JVM提供的相关指令所保证的，因此在Java程序运行期优化时可以将同步擦除，而原子类是由本地方法和汇编指令来提供保障的，在Java程序运行期间是没有办法被优化的。\n","date":"2022-08-17T10:14:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","title":"第二章 Java并发包之原子类型详解"},{"content":"第三章 java并发包之工具类详解 1 CountDownLatch工具详解 CountDownLatch使用起来非常简单，但是就是这个简单的工具类，可以帮助我们很优雅地解决主任务等待所有子任务都执行结束之后再进行下一步工作的场景。\nCountDownLatch的构造非常简单，需要给定一个不能小于0的int数字\ncountDown()方法，该方法的主要作用是使得构造CountDownLatch指定的count计数器减一。如果此时CountDownLatch中的计数器已经是0，这种情况下如果再次调用countDown()方法，则会被忽略，也就是说count的值最小只能为0\nawait()方法会使得当前的调用线程进入阻塞状态，直到count为0，当然其他线程可以将当前线程中断。同样，当count的值为0的时候，调用await方法将会立即返回，当前线程将不再被阻塞\nawait（long timeout, TimeUnit unit）是一个具备超时能力的阻塞方法，当时间达到给定的值以后，计数器count的值若还大于0，则当前线程会退出阻塞\ngetCount()方法，该方法将返回CountDownLatch当前的计数器数值，该返回值的最小值为0\n2 CyclicBarrier工具详解 CyclicBarrier（循环屏障），它也是一个同步助手工具，它允许多个线程在执行完相应的操作之后彼此等待共同到达一个障点（barrier point）。CyclicBarrier也非常适合用于某个串行化任务被分拆成若干个并行执行的子任务，当所有的子任务都执行结束之后再继续接下来的工作。从这一点来看，Cyclic Barrier与CountDownLatch非常类似，但是它们之间的运行方式以及原理还是存在着比较大的差异的，并且CyclicBarrier所能支持的功能CountDownLatch是不具备的。比如，CyclicBarrier可以被重复使用，而CountDownLatch当计数器为0的时候就无法再次利用。\n【note】在构造CyclicBarrier的时候，如果给定一个Runnable作为回调，那么待所有的任务线程都到达barrier point之后，该Runnable接口的run方法将会被调用。\nint getParties()方法：获取CyclicBarrier在构造时的parties，该值一经CyclicBarrier创建将不会被改变\nawait()方法：我们使用最多的一个方法，调用该方法之后，当前线程将会进入阻塞状态，等待其他线程执行await()方法进入barrier point，进而全部退出阻塞状态\nawait(long timeout, TimeUnit unit)方法：该方法与无参的await方法类似，只不过增加了超时的功能，当其他线程在设定的时间内没有到达barrier point时，当前线程也会退出阻塞状态\nisBroken()：返回barrier的broken状态，某个线程由于执行await方法而进入阻塞状态，如果该线程被执行了中断操作，那么isBroken()方法将会返回true\ngetNumberWaiting()方法： 该方法返回当前barrier有多少个线程执行了await方法而不是还有多少个线程未到达barrier point，这一点需要注意\nreset()方法：前面已经详细地介绍过这个方法，其主要作用是中断当前barrier，并且重新生成一个generation，还有将barrier内部的计数器count设置为parties值，但是需要注意的是，如果还有未到达barrier point的线程，则所有的线程将会被中断并且退出阻塞，此时isBroken()方法将返回false而不是true\nCyclicBarrier会被broken这一点我们已经通过上面的代码证明过了，但是需要注意如下几点（非常重要）\n当一个线程由于在执行CyclicBarrier的await方法而进入阻塞状态时，这个时候对该线程执行中断操作会导致CyclicBarrier被broken\n被broken的CyclicBarrier此时已经不能再直接使用了，如果想要使用就必须使用reset方法对其重置\n如果有其他线程此时也由于执行了await方法而进入阻塞状态，那么该线程会被唤醒并且抛出BrokenBarrierException异常\nCyclicBarrier VS. CountDownLatch CoundDownLatch的await方法会等待计数器被count down到0，而执行CyclicBarrier的await方法的线程将会等待其他线程到达barrier point\nCyclicBarrier内部的计数器count是可被重置的，进而使得CyclicBarrier也可被重复使用，而CoundDownLatch则不能\nCyclicBarrier是由Lock和Condition实现的，而CountDownLatch则是由同步控制器AQS（AbstractQueuedSynchronizer）来实现的\n在构造CyclicBarrier时不允许parties为0，而CountDownLatch则允许count为0\n3 Exchanger工具详解 Exchanger（交换器），Exchanger简化了两个线程之间的数据交互，并且提供了两个线程之间的数据交换点，Exchanger等待两个线程调用其exchange()方法。调用此方法时，交换机会交换两个线程提供给对方的数据。\npublic V exchange(V x) throws InterruptedException：数据交换方法，该方法的作用是将数据x交换至搭档线程，执行该方法后，当前线程会进入阻塞状态，只有当搭档线程也执行了exchange方法之后，该当前线程才会退出阻塞状态进行下一步的工作，与此同时，该方法的返回值代表着搭档线程所传递过来的交换数据 public V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException：该方法的作用与前者类似，只不过增加了超时的功能，也就是说在指定的时间内搭档线程没有执行exchange方法，当前线程会退出阻塞，并且返回值为null 4 Semaphore工具详解 Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。\nSemaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。\nSemaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。\nSemaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。\ntryAcquire方法 tryAcquire()：尝试获取Semaphore的许可证，该方法只会向Semaphore申请一个许可证，在Semaphore内部的可用许可证数量大于等于1的情况下，许可证将会获取成功，反之获取许可证则会失败，并且返回结果为false。\nboolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException：该方法与tryAcquire无参方法类似，同样也是尝试获取一个许可证，但是增加了超时参数。如果在超时时间内还是没有可用的许可证，那么线程就会进入阻塞状态，直到到达超时时间或者在超时时间内有可用的证书（被其他线程释放的证书），或者阻塞中的线程被其他线程执行了中断\nboolean tryAcquire(int permits)：在使用无参的tryAcquire时只会向Semaphore尝试获取一个许可证，但是该方法会向Semaphore尝试获取指定数目的许可证\nboolean tryAcquire(int permits, long timeout, TimeUnit unit)：该方法与第二个方法类似，只不过其可以指定尝试获取许可证数量的参数\nvoid acquire()：该方法会向Semaphore获取一个许可证，如果获取不到就会一直等待，直到Semaphore有可用的许可证为止，或者被其他线程中断。当然，如果有可用的许可证则会立即返回\nvoid acquire(int permits)：该方法会向Semaphore获取指定数量的许可证，如果获取不到就会一直等待，直到Semaphore有可用的相应数量的许可证为止，或者被其他线程中断。同样，如果有可用的permits个许可证则会立即返回\nvoid acquireUninterruptibly()：该方法会向Semaphore获取一个许可证，如果获取不到就会一直等待，与此同时对该线程的任何中断操作都会被无视，直到Semaphore有可用的许可证为止。当然，如果有可用的许可证则会立即返回\nvoid acquireUninterruptibly(int permits)：该方法会向Semaphore获取指定数量的许可证，如果获取不到就会一直等待，与此同时对该线程的任何中断操作都会被无视，直到Semaphore有可用的许可证为止，或者被其他线程中断。同样，如果有可用的permits个许可证则会立即返回\nvoid release()：释放一个许可证，并且在Semaphore的内部，可用许可证的计数器会随之加一，表明当前有一个新的许可证可被使用\nvoid release(int permits)：释放指定数量（permits）的许可证，并且在Semaphore内部，可用许可证的计数器会随之增加permits个，表明当前又有permits个许可证可被使用\nboolean isFair()：对Semaphore许可证的争抢采用公平还是非公平的方式，对应到内部的实现类为FairSync（公平）和NonfairSync（非公平）\nint availablePermits()：当前的Semaphore还有多少个可用的许可证\nint drainPermits()：排干Semaphore的所有许可证，以后的线程将无法获取到许可证，已经获取到许可证的线程将不受影响\nboolean hasQueuedThreads()：当前是否有线程由于要获取Semaphore许可证而进入阻塞？（该值为预估值。）\nint getQueueLength()：如果有线程由于获取Semaphore许可证而进入阻塞，那么它们的个数是多少呢？（该值为预估值。）\n5 Phaser的基本用法 CountDownLatch可以很好地控制等待多个线程执行完子任务，但是它有一个缺点，那就是内部的计数器无法重置，也就是说CountDownLatch属于一次性的，使用结束后就不能再次使用。CyclicBarrier倒是可以重复使用，但是一旦parties在创建的时候被指定，就无法再改变。Phaser则取百（两）家之所长于一身引入了两者的特性。\n在Phaser中可以有多个Phase（阶段），为了更好地对每一个Phase进行管理和监控，Phaser为每一个Phase都提供了对应的编号，这一点与CyclicBarrier是不一样的，后者更加注重的是循环。CyclicBarrier在所有的线程都到达barrier point之后，它才会重新开始，而Phaser则不然，只要某一个Phase的所有关联parties都arrive（到达）了，它就会从下一个Phase继续开始，除非Phaser本身已经被终止或者销毁。\n6 Lock接口方法 lock()方法：尝试获取锁，如果此刻该锁未被其他线程持有，则会立即返回，并且设置锁的hold计数为1；如果当前线程已经持有该锁则会再次尝试申请，hold计数将会增加一个，并且立即返回；如果该锁当前被另外一个线程持有，那么当前线程会进入阻塞，直到获取该锁，由于调用lock方法而进入阻塞状态的线程同样不会被中断，这一点与进入synchronized同步方法或者代码块被阻塞类似\nlockInterruptibly()方法：该方法的作用与前者类似，但是使用该方法试图获取锁而进入阻塞操作的线程则是可被中断的，也就说线程可以获得中断信号\ntryLock()方法：调用该方法获取锁，无论成功与否都会立即返回，线程不会进入阻塞状态，若成功获取锁则返回true，若获取锁失败则返回false。使用该方法时请务必注意进行结果的判断，否则会出现获取锁失败却仍旧操作共享资源而导致数据不一致等问题的出现\ntryLock(long time, TimeUnit unit)方法：该方法与tryLock()方法类似，只不过多了单位时间设置，如果在单位时间内未获取到锁，则返回结果为false，如果在单位时间内获取到了锁，则返回结果为true，同样hold计数也会被设置为1\nunlock()方法：当某个线程对锁的使用结束之后，应该确保对锁资源的释放，以便其他线程能够继续争抢，unlock()方法的作用正在于此\nnewCondition()方法：创建一个与该lock相关联的Condition对象\n7 ReentrantLock扩展方法 getHoldCount()方法：查询当前线程在某个Lock上的数量，如果当前线程成功获取了Lock，那么该值大于等于1；如果没有获取到Lock的线程调用该方法，则返回值为0 isHeldByCurrentThread()方法：判断当前线程是否持有某个Lock，由于Lock的排他性，因此在某个时刻只有一个线程调用该方法返回true isLocked()方法：判断Lock是否已经被线程持有 isFair()方法：创建的ReentrantLock是否为公平锁 hasQueuedThreads()方法：在多个线程试图获取Lock的时候，只有一个线程能够正常获得，其他线程可能（如果使用tryLock()方法失败则不会进入阻塞）会进入阻塞，该方法的作用就是查询是否有线程正在等待获取锁 hasQueuedThread(Thread thread)方法：在等待获取锁的线程中是否包含某个指定的线程 getQueueLength()方法：返回当前有多少个线程正在等待获取锁 8 ReadWriteLock\u0026amp;ReentrantReadWriteLock详解 1 2 3 4 5 6 // 定义ReadWriteLock锁 private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 创建读锁 private final Lock readLock = readWriteLock.readLock(); // 创建写锁 private final Lock writeLock = readWriteLock.writeLock(); 在没有任何写操作的情况下，读锁的效率反倒是最差的，这的确令人感到失望和惊讶，实际上，ReadWriteLock的性能表现确实不尽如人意，这也是在JDK1.8版本中引入StampedLock的原因之一\n9 Condition详解 如果说显式锁Lock可以用来替代synchronized关键字，那么Condition接口将会很好地替代传统的、通过对象监视器调用wait()、notify()、notifyAll()线程间的通信方式。Condition对象是由某个显式锁Lock创建的，一个显式锁Lock可以创建多个Condition对象与之关联，Condition的作用在于控制锁并且判断某个条件（临界值）是否满足，如果不满足，那么使用该锁的线程将会被挂起等待另外的线程将其唤醒，与此同时被挂起的线程将会进入阻塞队列中并且释放对显式锁Lock的持有，这一点与对象监视器的wait()方法非常类似。\nvoid await() throws InterruptedException：当前线程调用该方法会进入阻塞状态直到有其他线程对其进行唤醒，或者对当前线程执行中断操作。当线程执行了await()方法进入阻塞时；当前线程会被加入到阻塞队列中，并且释放对显式锁的持有，object monitor的wait()方法被执行后同样会加入一个虚拟的容器waitset（线程休息室）中，waitset是一个虚拟的概念，JVM（虚拟机）规范并未强制要求其采用什么样的数据结构，Condition的wait队列则是由Java程序实现的FiFO队列\nvoid awaitUninterruptibly()：该方法与await()方法类似，只不过该方法比较固执，它会忽略对它的中断操作，一直等待有其他线程将它唤醒\nlong awaitNanos(long nanosTimeout) throws InterruptedException：调用该方法同样会使得当前线程进入阻塞状态，但是可以设定阻塞的最大等待时间，如果在设定的时间内没有其他线程将它唤醒或者被执行中断操作，那么当前线程将会等到设定的纳秒时间后退出阻塞状态\nboolean await(long time, TimeUnit unit) throws InterruptedException：执行方法awaitNanos(),如果到达设定的纳秒数则当前线程会退出阻塞，并且返回实际等待的纳秒数，但是程序很难判断线程是否被正常唤醒，因此该方法的作用除了可以指定等待的最大的单位时间，另外，还可以返回在单位时间内被正常唤醒而且还是由于超时而退出的阻塞\nboolean awaitUntil(Date deadline) throws InterruptedException：调用该方法同样会导致当前线程进入阻塞状态直到被唤醒、被中断或者到达指定的Date\nvoid signal()：唤醒Condition阻塞队列中的一个线程，Condition的wait队列采用FiFO的方式，因此在wait队列中，第一个进入阻塞队列的线程将会被首先唤醒，下面我们来设计一个case对其进行测试\nvoid signalAll()：唤醒Condition wait队列中的所有线程\n10 StampedLock详解 StampedLock被JDK1.8版本引入之后，成为了Lock家族的新宠，它几乎具备了ReentrantLock、ReentrantReadWriteLock这两种类型锁的所有功能\n与ReentrantReadWriteLock锁一样，StampedLock也提供了读锁和写锁这两种模式，因此StampedLock天生就支持读写分离锁的使用方式\nStampedLock还提供了一个模式，即乐观读模式，使用tryOptimisticRead()方法获取一个非排他锁并且不会进入阻塞状态，与此同时该模式依然会返回一个long型的数据戳用于接下来的验证（该验证主要用来判断共享资源是否有写操作发生 lock.validate）\n11 Guava之Monitor详解 Monitor以及Monitor Guard则很好地将类似的一系列动作进行了抽象，隐藏了锁的获取、临界值判断、线程挂起、阻塞线程唤醒、锁的释放等操作。\n对x进行操作之前先调用monitor.enterWhen()方法，该方法除了具备锁的功能之外还具备临界值判断的操作，因此只有当x满足临界值判断时当前线程才会对x进行自增运算，否则当前线程将会进入阻塞队列（其实在Guard内部使用的也是Condition）\n调用leave()方法，注释③处，该方法除了释放当前的锁之外，还会通知唤醒与Guard关联的Condition阻塞队列中的某个阻塞线程\nenter()：该方法完全等价于Lock的lock()方法\nenterIf(Guard guard)：该方法主要用于判断当前的Guard是否满足临界值的判断，也是使用比较多的一个操作，调用该方法，当前线程并不会进入阻塞之中\ntryEnter()：等价于Lock的tryLock()方法\nwaitFor(Guard guard)：当前线程将会阻塞等待，直到Guard的条件满足当前线程才会退出阻塞状态\n12 Guava之RateLimiter详解 RateLimiter，顾名思义就是速率（Rate）限流器（Limiter），事实上它的作用正如名字描述的那样，经常用于进行流量、访问等的限制，这一点与3.4节中介绍过的Semaphore非常类似，但是它们的关注点却完全不同，RateLimiter关注的是在单位时间里对资源的操作速率（在RateLimiter内部也存在许可证（permits）的概念，因此可以理解为在单位时间内允许颁发的许可证数量），而Semaphore则关注的是在同一时间内最多允许多少个许可证可被使用，它不关心速率而只关心个数\n虽然说RateLimiter主要是用于控制速率的，但是在其内部也有许可证（permits）的概念，你甚至可以将其理解为单位时间内颁发的许可证数量，RateLimiter不仅允许每次获取一个许可证的操作，还允许获取超出剩余许可证数量的行为，只不过后者的操作将使得下一次请求为提前的透支付出代价。\n","date":"2022-08-17T10:14:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%89%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AF%A6%E8%A7%A3/","title":"第三章 java并发包之工具类详解"},{"content":"第四章 java并发包之并发容器详解 1 BlockingQueue（阻塞队列） 1.1 ArrayBlockingQueue ArrayBlockingQueue是一个基于数组结构实现的FIFO阻塞队列，在构造该阻塞队列时需要指定队列中最大元素的数量（容量）。当队列已满时，若再次进行数据写入操作，则线程将会进入阻塞，一直等待直到其他线程对元素进行消费。当队列为空时，对该队列的消费线程将会进入阻塞，直到有其他线程写入数据。该阻塞队列中提供了不同形式的读写方法\n阻塞式写方法\nvoid put(E e)：向队列的尾部插入新的数据，当队列已满时调用该方法的线程会进入阻塞，直到有其他线程对该线程执行了中断操作，或者队列中的元素被其他线程消费 boolean offer(E e, long timeout, TimeUnit unit)：向队列尾部写入新的数据，当队列已满时执行该方法的线程在指定的时间单位内将进入阻塞，直到到了指定的超时时间后，或者在此期间有其他线程对队列数据进行了消费。当然了，对由于执行该方法而进入阻塞的线程执行中断操作也可以使当前线程退出阻塞。该方法的返回值boolean为true时表示写入数据成功，为false时表示写入数据失败 非阻塞式写方法\nboolean add(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，但是该方法会抛出队列已满的异常\nboolean offer(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，并且会立即返回false\n阻塞时读方法\nE take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，直到有其他线程写入新的数据，或者当前线程被执行了中断操作 E take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，直到有其他线程写入新的数据，或者当前线程被执行了中断操作 非阻塞式读方法\nE take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，直到有其他线程写入新的数据，或者当前线程被执行了中断操作 E peek()：peek的操作类似于debug操作（仅仅debug队列头部元素，本书的第6章将讲解针对Stream的操作，大家将从中学习到针对整个Stream数据元素的peek操作），它直接从队列头部获取一个数据，但是并不能从队列头部移除数据，当队列为空时，该方法不会使得当前线程进入阻塞，而是返回null值 1.2 PriorityBlockingQueue PriorityBlockingQueue优先级阻塞队列是一个“无边界”阻塞队列，与4.1.2节所讲的优先级链表类似的是，该队列会根据某种规则（Comparator）对插入队列尾部的元素进行排序，因此该队列将不会遵循FIFO（first-in-first-out）的约束。虽然PriorityBlockingQueue同ArrayBlockingQueue都实现自同样的接口，拥有同样的方法，但是大多数方法的实现确实具有很大的差别，PriorityBlockingQueue也是线程安全的类，适用于高并发多线程的情况下。\n1.3 LinkedBlockingQueue ArrayBlockingQueue是基于数组实现的FIFO“有边界”队列，PriorityBlockingQueue也是基于数组实现的，但它是“无边界”的优先级队列，由于存在对数据元素的排序规则，因此PriorityBlockingQueue并不能提供FIFO的约束担保（当然，如果想要使其具备FIFO的特性，需要约束PriorityBlockingQueue的排序规则为R，并且对其写入数据的顺序也为R，这样就可以保证FIFO），本节将要介绍的LinkedBlockingQueue是“可选边界”基于链表实现的FIFO队列。截至目前，本章所学习到阻塞队列都是通过显式锁Lock进行共享数据的同步，以及与Lock关联的Condition进行线程间通知，因此该队列也适用于高并发的多线程环境中，是线程安全的类。\nLinkedBlockingQueue队列的边界可选性是通过构造函数来决定的，当我们在创建LinkedBlockingQueue对象时，使用的是默认的构造函数，那么该队列的最大容量将为Integer的最大值（所谓的“无边界”），当然开发者可以通过指定队列最大容量（有边界）的方式创建队列。\n1.4 DelayQueue DelayQueue也是一个实现了BlockingQueue接口的“无边界”阻塞队列，但是该队列却是非常有意思和特殊的一个队列（存入DelayQueue中的数据元素会被延迟单位时间后才能消费），在DelayQueue中，元素也会根据优先级进行排序，这种排序可以是基于数据元素过期时间而进行的（比如，你可以将最快过期的数据元素排到队列头部，最晚过期的数据元素排到队尾）。\n【note】这里没看懂，暂时略过\n1.5 SynchronousQueue SynchronousQueue也是实现自BlockingQueue的一个阻塞队列，每一次对其的写入操作必须等待（阻塞）其他线程进行对应的移除操作，SynchronousQueue的内部并不会涉及容量、获取size，就连peek方法的返回值永远都将会是null，除此之外还有更多的方法在SynchronousQueue中也都未提供对应的支持。\n尽管SynchronousQueue是一个队列，但是它的主要作用在于在两个线程之间进行数据交换，区别于Exchanger的主要地方在于（站在使用的角度）SynchronousQueue所涉及的一对线程一个更加专注于数据的生产，另一个更加专注于数据的消费（各司其职），而Exchanger则更加强调一对线程数据的交换。\n1.6 LinkedBlockingDeque LinkedBlockingDeque是一个基于链表实现的双向（Double Ended Queue，Deque）阻塞队列，双向队列支持在队尾写入数据，读取移除数据；在队头写入数据，读取移除数据。LinkedBlockingDeque实现自BlockingDeque（BlockingDeque又是BlockingQueue的子接口），并且支持可选“边界”，与LinkedBlockingQueue一样，对边界的指定在构造LinkedBlockingDeque时就已经确定了。\n1.7 LinkedTransferQueue TransferQueue是一个继承了BlockingQueue的接口，并且增加了若干新的方法。LinkedTransferQueue是TransferQueue接口的实现类，其定义为一个无界的队列，具有FIFO的特性。\n继承自BlockingQueue的方法在使用方法上与本节中学过的其他BlockingQueue并没有太大的区别（SynchronousQueue除外），因此我们只介绍继承自TransferQueue的方法，看看TransferQueue为其赋予了怎样的新特性。\n2 ConcurrentQueue（并发队列） ConcurrentLinkedQueue 单向队列\nConcurrentLinkedDeque 双向队列\n本节介绍了ConcurrentLinkedQueue（先进先出FIFO队列）和ConcurrentLinkedDeque（双向队列），对于队列的使用前文中做了很多介绍，因此本节并未对每种方法都展开详细的介绍。并发队列在实现上采用了无锁（Lock Free）算法，因此在多线程高并发的环境中其拥有更出色的性能表现，但是ConcurrentLinkedQueue并不是在任何情景下都会保持高效，比如执行size()方法时，甚至本身在对元素进行删除操作时都存在着性能隐患和内存溢出的问题，关于这些，本节中都做了非常详细的介绍。当然了，这并不妨碍你在开发中使用它，但是使用得当的前提是你必须搞清楚它在什么情况下会出现问题，只有这样才能对其驾驭得当、运用自如。\n3 ConcurrentMap（并发映射） ConcurrentHashMap\nConcurrentSkipListMap\nConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上，其能够在O(log(n))时间内完成查找、插入、删除操作。调用ConcurrentSkipListMap的size时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素的个数，这个操作是个O(log(n))的操作。\n在读取性能上，虽然ConcurrentSkipListMap不能与ConcurrentHashMap相提并论，但是ConcurrentSkipListMap存在着如下两大天生的优越性是ConcurrentSkipListMap所不具备的。\n第一，由于基于跳表的数据结构，因此ConcurrentSkipListMap的key是有序的。\n第二，ConcurrentSkipListMap支持更高的并发，ConcurrentSkipListMap的存取时间复杂度是O（log（n）），与线程数几乎无关，也就是说，在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出它的优势。\n4 写时拷贝算法（Copy On Write） CopyOnWriteArrayList\nCopyOnWriteArraySet\n","date":"2022-08-17T10:14:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/","title":"第四章 java并发包之并发容器详解"},{"content":"第五章 java并发包之ExecutorService 1 Executor\u0026amp;ExecutorService详解 1.1 ThreadPoolExecutor详解 构造ThreadPoolExecutor所需要的参数是比较多的\ncorePoolSize：用于指定在线程池中维护的核心线程数量，即使当前线程池中的核心线程不工作，核心线程的数量也不会减少（在JDK1.6版本及以后可以通过设置允许核心线程超时的方法allowCoreThreadTimeOut来改变这种情况）\nmaximumPoolSize：用于设置线程池中允许的线程数量的最大值\nkeepAliveTime：当线程池中的线程数量超过核心线程数并且处于空闲时，线程池将回收一部分线程让出系统资源，该参数可用于设置超过corePoolSize数量的线程在多长时间后被回收，与unit配合使用\nTimeUnit：用于设定keepAliveTime的时间单位\nworkQueue：用于存放已提交至线程池但未被执行的任务\nThreadFactory：用于创建线程的工厂，开发者可以通过自定义ThreadFactory来创建线程，比如，根据业务名为线程命名、设置线程优先级、设置线程是否为守护线程等、设置线程所属的线程组等\nRejectedExecutionHandler：当任务数量超过阻塞队列边界时，这个时候线程池就会拒绝新增的任务，该参数主要用于设置拒绝策略\nExecutorService允许一次性提交一批任务invokeAny，但是其只关心第一个完成的任务和结果\ninvokeAll方法同样可用于异步处理批量的任务，但是该方法关心所有异步任务的运行\n1.2 ScheduledExecutorService ScheduledExecutorService既具有ThreadPoolExecutor的所有方法，同时又具备定时执行任务的方法，在ScheduledExecutorService中定义了4个与schedule相关的方法，用于定时执行任务\nScheduledFuture schedule(Callable callable,long delay,TimeUnit unit)：该方法是一个one-shot方法（只执行一次），任务（callable）会在单位（unit）时间（delay）后被执行，并且立即返回ScheduledFuture，在稍后的程序中可以通过Future获取异步任务的执行结果。\nScheduledFuture schedule(Runnable command,long delay, TimeUnit unit)：该方法同样是一个one-shot方法（只执行一次），任务（runnable）会在单位（unit）时间（delay）后被执行，虽然也会返回ScheduledFuture，但是并不会包含任何执行结果，因为Runnable接口的run方法本身就是无返回值类型的接口方法，不过可以通过该Future判断任务是否执行结束。\nScheduledFuture scheduleAtFixedRate(Runnable command,long initialDelay, long period, TimeUnit unit)：任务（command）会根据固定的速率（period，时间单位为unit）在时间（initialDelay，时间单位为unit）后不断地被执行。\nScheduledFuture scheduleWithFixedDelay(Runnable command, long initialDelay,long delay,TimeUnit unit)：该方法与前一个方法比较类似，只不过该方法将以固定延迟单位时间的方式执行任务\n1.3 Executors详解 FixedThreadPool\n线程池的核心线程数和最大线程数是相等的，因此该线程池中的工作线程数将始终是固定的。任务队列为LinkedBlockingQueue（无边界），所以理论上提交至线程池的任务始终都会被执行，只有显式地执行线程池的关闭方法才能关闭线程池\nSingleThreadPool\nSingleThreadPool是只有一个核心线程的线程池，但是Finalizable代理了该线程池，因此当线程池引用可被垃圾回收器回收时，线程池的shutdown方法会被执行，当然我们还是建议显式地调用线程池的关闭方法\nCachedThreadPool\nCachedThreadPool根据需要创建新线程，但会重用以前构造的可用线程。该线程池通常会用于提高执行量大的、耗时较短的、异步任务程序的运行性能，在该线程池中，如果有可用的线程将被直接重用。如果没有可用的线程，则会创建一个新线程并将其添加到池中。未被使用且空闲时间超过60秒的线程将被终止并从线程池中移除，因此长时间空闲的线程不会消耗任何资源\nScheduledThreadPool\n创建指定核心线程数量的ScheduledExecutorService\nWorkStealingPool\n与其他线程池不同的是，WorkStealingPool中的工作线程会处理任务队列中与之对应的任务分片（Divide and conquer：分而治之），如果某个线程处理的任务执行比较耗时，那么它所负责的任务将会被其他线程“窃取”执行，进而提高并发处理的效率。\n2 Future和Callback Future代表着一个异步任务在未来的执行结果，这个结果可以在最终的某个时间节点通过Future的get方法来获得\n获取异步执行任务的结果：当异步任务被正常执行完毕，可以通过get方法或者其重载方法（指定超时单位时间）获取最终的结果。\nCallable接口：该接口与Runnable接口非常相似，但是Runnable作为任务接口最大的问题就是无法返回最终的计算结果，因此在JDK1.5版本中引入了Callable泛型接口，它允许任务执行结束后返回结果\n任务执行错误：Runnable类型的任务中，run（）方法抛出的异常（运行时异常）只能被运行它的线程捕获（有可能会导致运行线程死亡），但是启动运行线程的主线程却很难获得Runnable任务运行时出现的异常信息。在《Java高并发编程详解：多线程与架构设计》一书的第7章“Hook线程以及捕获线程执行异常”中有讲到，我们可以通过设置UncaughtExceptionHandler的方式来捕获异常，但是这种方式的确不够优雅，并且也无法精确地知道是执行哪个任务时出现的错误，Future则是通过捕获get方法异常的方式来获取异步任务执行的错误信息的，如下面的示例代码所示。\nFuture的不足之处\n无法被动接收异步任务的计算结果：虽然我们可以主动将异步任务提交给线程池中的线程来执行，但是待异步任务结束后，主（当前）线程无法得到任务完成与否的通知（关于这一点，5.2.4节中将会给出解决方案），它需要通过get方法主动获取计算结果 Future间彼此孤立：有时某一个耗时很长的异步任务执行结束以后，你还想利用它返回的结果再做进一步的运算，该运算也会是一个异步任务，两者之间的关系需要程序开发人员手动进行绑定赋予，Future并不能将其形成一个任务流（pipeline），每一个Future彼此之间都是孤立的，但5.5节将要介绍的CompletableFuture就可以将多个Future串联起来形成任务流（pipeline） Future没有很好的错误处理机制：截至目前，如果某个异步任务在执行的过程中发生了异常错误，调用者无法被动获知，必须通过捕获get方法的异常才能知道异步任务是否出现了错误，从而再做进一步的处理 2.1 Google Guava的Future Future虽然为我们提供了一个凭据，但是在未来某个时间节点进行get()操作时仍然会使当前线程进入阻塞，显然这种操作方式并不是十分完美，因此在Google Guava并发包中提供了对异步任务执行的回调支持，它允许你注册回调函数而不用再通过get()方法苦苦等待异步任务的最终计算结果（Don\u0026rsquo;t Call Us, We\u0026rsquo;ll Call You!）\n2.1.1 ListenableFuture Guava提供了ListneningExecutorService，使用该ExecutorService提交执行异步任务时将返回ListenableFuture，通过该Future，我们可以注册回调接口\n2.1.2 FutureCallback 除了ListenableFuture之外，还可以注册FutureCallback，相比前者用Runnable接口作为回调接口，FutureCallback提供的回调方式则更为直观。\n3 ForkJoinPool详解 Fork/Join框架是在JDK1.7版本中被Doug Lea引入的，Fork/Join计算模型旨在充分利用多核CPU的并行运算能力，将一个复杂的任务拆分（fork）成若干个并行计算，然后将结果合并（join）\nRecursiveTask\nRecursiveTask任务类型除了进行子任务的运算之外，还会将最终子任务的计算结果返回，下面通过一个简单的实例来认识一下RecursiveTask。\nRecursiveAction\nRecursiveAction类型的任务与RecursiveTask比较类似，只不过它更关注于子任务是否运行结束，下面来看一个将数组中的每一个元素并行增加10倍\n4 CompletionService详解 CompletionService并不是ExecutorService的子类，因此它并不具备执行异步任务的能力（异步任务的执行是由CompletionService内部的ExecutorService来完成的），它只是对Executor-Service的一个封装，在其内部提供了阻塞队列用于Future的消费\nCompletionService很好地解决了异步任务的问题，在CompletionService中提供了提交异步任务的方法（真正的异步任务执行还是由其内部的ExecutorService完成的），任务提交之后调用者不再关注Future，而是从BlockingQueue中获取已经执行完成的Future，在异步任务完成之后Future才会被插入阻塞队列，也就是说调用者从阻塞队列中获取的Future是已经完成了的异步执行任务，所以再次通过Future的get方法获取结果时，调用者所在的当前线程将不会被阻塞。\n5 CompletableFuture详解 CompletableFuture是自JDK1.8版本中引入的新的Future，常用于异步编程之中，所谓异步编程，简单来说就是：“程序运算与应用程序的主线程在不同的线程上完成，并且程序运算的线程能够向主线程通知其进度，以及成功失败与否的非阻塞式编码方式”，这句话听起来与前文中学习的ExecutorService提交异步执行任务并没有多大的区别，但是别忘了，无论是ExecutorService还是CompletionService，都需要主线程主动地获取异步任务执行的最终计算结果，如此看来，Google Guava所提供的ListenableFuture更符合这段话的描述，但是ListenableFuture无法将计算的结果进行异步任务的级联并行运算，甚至构成一个异步任务并行运算的pipeline，但是这一切在CompletableFuture中都得到了很好的支持。\nCompletableFuture实现自CompletionStage接口，可以简单地认为，该接口是同步或者异步任务完成的某个阶段，它可以是整个任务管道中的最后一个阶段，甚至可以是管道中的某一个阶段，这就意味着可以将多个CompletionStage链接在一起形成一个异步任务链，前置任务执行结束之后会自动触发下一个阶段任务的执行。另外，CompletableFuture还实现了Future接口，所以你可以像使用Future一样使用它。\nthenApply：以同步的方式继续处理上一个异步任务的结果。 thenApplyAsync：以异步的方式继续处理上一个异步任务的结果。 thenAccept：以同步的方式消费上一个异步任务的结果。 thenAcceptAsync：以异步的方式消费上一个异步任务的结果。 thenRun：以同步的方式执行Runnable任务。 thenRunAsync：以异步的方式执行Runnable任务。 ","date":"2022-08-17T10:14:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%94%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8Bexecutorservice/","title":"第五章 java并发包之ExecutorService"},{"content":"第一章 JCF中的List集合 1 List集合概要和重要接口介绍 JCF中的List集合涉及的部分重要接口\njava.util.ArrayList\njava.util.LinkedList\njava.util.Vector\njava.util.Stack\n其中java.util.Stack继承自java.util.Vector。不过在jdk1.7+已经推荐使用性能更好的java.util.ArrayDeque集合作为替代方案。\n要理解java.util包中关于java.util.List接口的重要实现类，需要理清楚其涉及的\n主要接口\njava.lang.Iterable (可迭代接口)\njava.util.Collection(集合接口)\n有些集合类，并不一定会实现这个接口\n主要抽象类\njava.util.AbstractList(抽象列表)\n支持随机访问\njava.util.AbstractSequentialList(抽象连续列表)\n不支持随机访问\n在JCF中，可以根据List集合在各维度表现出来的工作特点对其进行分类：\n是否支持随机访问 数据是否支持修改 集合容量是否可变 【插入】标识接口：是指Java中用于标识某个类是否具备某种操作特性、功能类型的接口。标识接口通常不需要下层类实现任何方法。\njava.util.RandomAccess java.lang.Cloneable java.io.Serializable java.util.ArrayList、java.util.Vector集合和java.util.concurrent.CopyOnWriteArrayList集合都实现了java.util.RandomAccess接口，表示它们支持集合中数据对象的随机访问。实现java.util.RandomAccess接口的还有很多第三方类库，如一些厂商封装的JSON工具中的JSONArray类。这些实现了java.util.RandomAccess标识接口的List集合在工作时也会被区别对待。\nJDK14+ instanceof 模式匹配 Girraffe\nLinkedList集合的内部结构是一个双向链表，要寻找链表中某个索引位上的数据对象，只能从头部或尾部依次查询.\n2 Vector Vector集合的工作特性除了支持数据对象的随机访问，还有集合的大小可变、保证线程安全的运行环境\n3 ArrayList ArrayList集合是JCF中非常重要的集合之一，也是实际工作中最常使用的集合之一。ArrayList集合拥有与Vector集合类似的接口和操作逻辑（从JDK 1.2开始提供），但它不支持线程安全操作（Vector集合支持线程安全操作，但是基于线程安全的多线程操作性能不高）。ArrayList集合也支持随机访问，也就是说，ArrayList集合在单线程下对指定索引位上的数据读取操作的时间复杂度为O(1)。\nArrayList集合是程序员在单线程操作场景中最常使用的List集合之一。该集合的内部结构是一个数组，并且这个数组在需要的时候可以进行扩容操作，所以理论上ArrayList集合能存储任意数量的数据对象（但实际上受各种客观因素限制而无法实现）。ArrayList集合允许将数据对象添加到数组的任意有效索引位上，并且允许从数组的任意有效索引位上获取数据对象。\n3.1 集合内部结构 ArrayList集合中数组的默认初始化容量值也为10，也可以指定集合中数组的初始化容量值，但如果使用者没有指定初始化容量值，那么ArrayList集合中的elementData数组会被初始化为一个容量值为0的空数组。\n3.2 扩容逻辑 ArrayList集合在进行扩容操作时会将当前容量增大50%，并且扩容逻辑不能干预，除非扩容前容量值小于10（如果发生这样的情况，则首先扩容到10）。ArrayList集合的扩容逻辑相对动态，这保证了在扩容操作频率和扩容大小之间更好的平衡性。\n4 Stack 顾名思义，Stack集合的工作效果符合栈结构的定义。栈结构是指能使集合中的数据对象具有后进先出（LIFO）操作特性的集合结构。Stack集合同样有线程安全操作特性（但同样不适合在高并发场景中使用），Stack集合的扩容增量通常也是当前容量的1倍；Stack集合也不会对集合的序列化过程和反序列化过程进行特殊优化处理。\n5 LinkedList java.util.LinkedList集合是本书讲解的最后一种主要的List集合，也是本书讲解的第一种Queue集合。换句话说，LinkedList集合同时具有List集合和Queue集合的基本特性。\nLinkedList集合的主要结构是双向链表。双向链表中的节点不要求有连续的内存存储地址，因此在向双向链表中插入新节点时，无须申请一块连续的存储空间，只需按需申请存储空间。LinkedList集合中的链表的每个节点都使用一个java.util.LinkedList.Node类的对象进行描述。\n","date":"2022-08-17T10:14:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84list%E9%9B%86%E5%90%88/","title":"第一章 JCF中的List集合"},{"content":"第十三章 深入volatile关键字 1 并发编程的三个重要特性 原子性\n原子性指在一个操纵或多次操作中，要么所有操作得到执行，要么所有操作都不执行\n可见性\n当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值\n有序性\n所谓有序性，是指程序代码在执行过程中的先后顺序\n【note】这里其实是说，在多线程情况下，并不能保证像单线程一样严格的顺序执行，因为有可能线程1在执行过判断后，放弃了CPU时间片，线程2开始执行。\nJVM采用内存模型的机制，来屏蔽各个平台和操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果。（比如java中的Int固定为4字节，这就是所谓的一致内存访问效果）\n2 JMM与原子性 多个原子性操作在一起就不再是原子性操作了\n简单的读取和赋值是原子性的，但将一个变量赋值给另一个变量不是原子性的\nJMM只保证了基本读取和赋值的原子性，其他不再保证了。如果想使某些代码片段具备原子性，需要使用关键子synchronized或者JUC的lock。如果想使int等类型自增操作具备原子性，可以使用JUC.atomic\nvolatile不具备原子性\n3 JMM与可见性 使用关键字volatile来保证可见性 使用synchronized保证可见性 使用JUC的lock保证可见性 volatile具备可见性\n4 JMM与有序性 使用关键字volatile来保证有序性 使用synchronized保证有序性 使用JUC的lock保证有序性 volatile具备有序性\n此外JMM具备一些天生的有序性规则，不需要任何同步手段就能保持有序性。（Happens-before原则）\n程序次序规则\n锁定规则\nvolatile变量规则\n传递规则\n线程启动规则\n线程中断规则\n线程的终结规则\n对象的终结规则\n5 volatile关键字深入解析 5.1 volatile关键字的语义 被volatile修饰的实例变量或者类变量具备如下两层语义\n保证了不同线程之间对共享变量操作时的可见性\n禁止对指令进行重排序（直接禁止JVM和处理器对volailte关键字修饰的指令进行重排序）\n5.2 volatile的原理和实现机制 通过对unsafe.cpp源码的阅读，会发现被volatile修饰的变量存在与一个“lock;”前缀\nlock;前缀实际上相当于一个内存屏障，该内存屏障会为指令的执行提供如下几个保障。\n确保指令重排序时不会将后面的代码排到内存屏障之前。 确保指令重排序时不会将前面的代码排到内存屏障之后。 确保执行到内存屏障修饰的指令时，前面的代码全部执行完成。 强制将工作线程中的值，修改刷新到主内存 如果是写操作，则会强制其他线程的工作内存中的缓存数据全部失效 ","date":"2022-08-16T15:22:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B7%B1%E5%85%A5volatile%E5%85%B3%E9%94%AE%E5%AD%97/","title":"第十三章 深入volatile关键字"},{"content":"第十四章 7种单例模式的设计 1 饿汉式 不支持懒加载\n2 懒汉式 多线程情况下不能保证唯一一次的实例化\n3 懒汉式 + 同步方法 性能较低\n4 Double-Check 可能会抛出空指针异常\n5 Volatile + Double-Check 略\n6 Holder方式 利用了类加载机制，是目前最好的设计之一，也是目前使用比较广泛的设计\n7 使用枚举实现单例 不支持懒加载\n","date":"2022-08-16T15:22:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"第十四章 7种单例模式的设计"},{"content":"第十二章 volatile关键字介绍 1 机器硬件CPU 在计算机，所有的运算操作都是由CPU的寄存器来完成的，CPU指令的执行过程需要涉及到数据的读取和写入操作。Cpu访问的数据只能是计算机的主存。\n由于两边数据的严重不对等，通过传统FSB直连内存的访问方式很明显会导致CPU资源收到大量限制，降低CPU整体的吞吐量。于是就有了在CPU和主存之间做缓存的限制。最靠近CPU的缓存称之为L1，然后依次是L2,L3和主内存。\n由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache又被划分为了 L1i （instrucgtion）和 L1d (data)\nCPU Cache又是由很多 Cache Line构成的，Cache Line是CPU Cache的最小组成单位。目前主流的Cache Line都是64字节。\nCache的出现是为了解决CPU直接访问内存效率低下的问题，所以程序在运行时，会将运算所需的一部分数据从主存复制到Cache，当运算结束后再将数据刷回到主存。\n2 CPU缓存一致性问题 每个线程都有自己的工作内存，变量会在多个线程的本地内存都存一份副本。\n为了解决缓存一致性问题，通常主流的解决办法有两种：\n通过总线加锁的方式\n常见于早期的CPU，而且是一种悲观的实现方式，CPU和其他组件通信，都是通过总线来进行的，通过对总线进行加锁，会阻塞其他CPU的访问，从而使得只有一个CPU能够访问这个变量的内存。\n通过缓存一致性协议\n最为出名的是Intel的MESI协议，它保证了每个缓存中使用的变量副本都是一致的。\n读取操作，将缓存中的数据读取到寄存器\n写入操作，发出信号通知其他CPU将变量的Cache Line置为无效的状态，其他的CPU在进行变量读取时，不得不去主内存再次读取。\n3 Java内存模型（JMM） Java内存模型定义了线程和主内存之间的抽象关系：\n共享变量储存于主内存之中，每个线程都可以访问。 每个线程都有私有的工作内存或者称为本地内存。 工作内存只储存该线程对共享变量的副本。 线程不能直接操作主内存，只有操作工作内存，再写入主内存。 工作内存和JMM一样，是一个抽象的概念，它其实并不存在。它涵盖了缓存、编译器优化、寄存器、和硬件。 ","date":"2022-08-16T14:30:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/","title":"第十二章 volatile关键字介绍"},{"content":"第十一章 线程上下文类加载器 1 为什么需要线程上下文类加载器 Thread类提供了API用来获取以及设置当前线程的上下文类加载器，如果当前线程没有设置上下文类加载器，那么它将与父线程抱持同样的类加载器。\nJDK核心库中提供了很多SPI (Service Provider Interface)。常见的包括JDBC、JCE、JNDI、JAXP、JBI等，JDK只提供了这些接口之间的逻辑关系，但不提供具体的实现。Java使用 JDBC这个SPI完全透明了应用程序和第三方厂商数据库驱动的具体实现。不管数据库类型如何切换，应用程序只需要更新JDBC的驱动jar包和驱动名称，而不需要进行任何更新。\n由于JDK定义了SPI的标准接口，加之这些接口作为JDK核心标准类库的一部分，即想要完全透明标准接口的实现，又想与JDK核心库进行捆绑，由于JVM双亲委托机制的限制，根加载器不可能加载的到第三方厂商提供的具体实现。为了解决这个困境，JDK只好提供一个不太优雅的设计，线程上下文类加载器，有了线程上下文类加载器，根加载器反而需要委托子类加载器去加载厂商提供的SPI具体实现。\n","date":"2022-08-16T14:30:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","title":"第十一章 线程上下文类加载器"},{"content":"第十章 JVM类加载器 类的加载器负责类的加载职责，对于任意一个class都需要由加载它的类加载器和这个类本身确定其在JVM中的唯一性，这也就是运行时包。\n1 JVM内置三大类加载器 Bootstrap ClassLoader\n根加载器又称为Bootstrap类加载器，是最为顶层的加载器，其没有任何父加载器，是由C++编写的，主要负责核心类库的加载。\nExt ClassLoader\n拓展类加载器的父加载器是根加载器，主要用于加载 JAVA_HOME下的 jre/lib/ext 目录里面的类库，拓展类加载器是由纯Java语言实现的，它是java.lang.URLClassLoader的子类。\nApplication ClassLoader\n系统类加载器是一种常见的加载器，其负责加载classpath下的类库资源，我们在进行项目开发的时候引入的第三方jar包，系统类加载器的父加载器是拓展类加载器，同时他也是自定义类加载器的默认父加载器。\n不同的类加载器负责将不同的类加载到JVM内存之中，并且他们之间严格遵守着父委托的机制。\n2 自定义类加载器 自定义类加载器必须是ClassLoader的直接或间接子类，然后重写findClass方法。\n【note】这里注意，自定义类加载器需要重写findClass方法，但是破坏双亲委托机制需要重写loadClass方法。\n3 双亲委托机制详细介绍 双亲委托机制，有时候也称父委托机制。当一个类加载器被调用loadClass后，他并不会直接进行加载，而是交给当前类加载器的父加载器尝试加载，直到最顶层的加载器，然后再依次向下进行加载。\nloadClass的执行流程\n从当前类的已加载类缓存中根据类的全路径名查询是否存在该类，如果存在则直接返回。\n如果当前类存在父类，则调用父类加载器的loadClass方法对其进行加载。\n如果当前类不存在父类，则直接调用根加载器对其进行加载。\n如果当前类的父类没有加载成功，则调用当前类加载器的findClass方法对其进行加载。\n如果类最后被成功加载，则做一些性能数据的统计。\n由于loadClass指定了resolve，所以不会进行连接阶段的继续执行，这也解释了为什么类加载器不会导致类的初始化。\n4 破坏双亲委托机制\n重写loadClass，改为如下流程\n根据类的全路径名称进行加锁，确保每一个类在多线程的情况下只被加载一次。\n从当前类的已加载类缓存中根据类的全路径名查询是否存在该类，如果存在则直接返回。\n若缓存中没有被加载的类，则需要对其进行首次加载，如果类的全路径名称以 java/javax 开头，则直接委托给系统类加载器进行加载。\n如果不是以 java/javax开头，则尝试使用自己的类加载器对其进行加载。\n若自定义的加载器没有完成对类的加载，则委托给其父类加载器或系统加载器进行加载。\n若干次尝试后，仍没有对类进行加载，则抛出无法找到类的异常。\n4 类加载器命名空间、运行时包、类的卸载 每个类加载器实例都有各自的命名空间，命名空间是由该加载器以及其所有的父加载器所构成的。因此在每个类加载器中同一个class都是独一无二的。\n在类加载器进行类加载的时候，首先会到加载记录表也就是缓存中，查看该类是否已经加载过了，如果已经加载过了就不会重复加载。否则会认为其是第一次加载\n运行时包\n我们在编写代码时，通常会给一个类指定一个包名，包的作用是为了组织类，防止不同包下的同样名称的class起冲突。包名和类名构成了类的全限定名称。\n比如\n1 BootstrapClassLoader.ExtClassLoader.ApplicationClassLoader.MyClassLoader.com.xxzzz.Demo\t这样做的好处是处于安全和封装的考虑，这样自定义的类和系统类拥有不同的运行时包。\n初始类加载器\n由于运行时包的存在，JVM规定了不同的运行时包下的类彼此之间是不可以互相访问的。\n根据JVM规范的规定，在类的加载过程中，所有参与的类加载器，即使没有亲自加载过该类，也会标识为该类的初始类加载器。\n类的卸载\n该类的所有实例都已经被GC 该类对应的类加载器被GC 该类的class实例没有在其他地方被引用 ","date":"2022-08-16T14:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E7%AB%A0-jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","title":"第十章 JVM类加载器"},{"content":"第九章 类的加载过程 ClassLoader的主要职责就是负责加载各种class文件到JVM中，ClassLoader是一个抽象的class，给定一个class的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中。\n1 类的加载过程简介 类的加载过程一般分为三个比较大的阶段，分别是加载阶段，连接阶段和初始化阶段。\n加载阶段：主要负责查找并且加载类的二进制数据文件，其实就是class文件。 连接阶段：连接阶段做的工作比较多 验证：主要确保类文件的正确性，比如class的版本，class文件的魔术因子是否正确 准备：为类的静态变量分配内存，并为其初始化默认值 解析：把类的符号引用转化为直接引用 初始化阶段：为类的静态变量赋予正确的初始化值 JVM对类的初始化是一个延迟的机制。当一个类在首次使用时才会被初始化，在同一个运行时包下，一个class只会被初始化一次。\n2 类的主动使用和被动使用 JVM虚拟机规范规定，每个类或者接口被Java程序首次主动使用时才会对其进行初始化。当然随着JIT技术的越来越成熟，JVM运行期间的编译也越来越智能，不排除JVM在运行期间提前预判并且初始化某个类。\nJVM同时规定了6种主动使用类的场景。\n通过new关键字会导致类的初始化 访问类的静态变量 访问类的静态方法 对某个类进行反射操作 初始化子类会导致父类的初始化 启动类 被动使用\n构造某个类的数组时 引用类的静态常量 3 类的加载过程详解 简单来说类的加载就是将class文件中的二进数据读取到内存之中，然后将该字节流所代表的静态存储结构转换为方法区中运行时的数据结构。并且在堆中生成一个该类的java.lang.Class对象，作为访问方法区数据结构的入口。\n类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管一个类被加载了多少次，对应到堆内存中的class对象始终是一个。\n验证 验证文件格式 验证元数据 验证字节码 验证符号引用 准备 当一个class的字节流通过了验证过程之后,就开始为该对象的类变量(静态变量)分配内存并设置初始值了。类变量的内存会被分配到方法区，不同与实例变量会被分配到堆内存。 1 2 3 4 public class Demo { private static int a = 10; private final static int b = 10; } 其中a在准备阶段不是10，而是初始值0。当然b还是10，因为final修饰的静态变量不会导致类的初始化，是一种被动引用。\n【note】这里的b应该是属于静态常量，也就是被动使用的第二种情况，所以跟Demo类无关所以不需要走连接\n当然更严谨的解释是b在类的编译阶段javac会将其value生成一个ConstantValue，直接赋予10；\n解析 类接口解析 字段的解析 类方法的解析 接口方法的解析 ","date":"2022-08-16T10:21:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","title":"第九章 类的加载过程"},{"content":"第八章 线程池原理以及自定义线程池 一个完整的线程池应该具备如下要素：\n任务队列\n线程数量管理功能\n任务拒绝策略\n线程工厂\nQueueSize\nKeepedalive\n1 拒绝策略 DenyPolicy主要用于当Queue的runnable达到了limit上限时，通过那种策略来通知提交者。\n默认包含三种实现：\nDiscardDenyPolicy 该拒绝策略会直接将任务丢弃\nAbortDenyPolicy 该拒绝策略会向任务提出者抛出异常\nRunnerDenyPolicy 该拒绝策略会在任务提交者所在的线程中执行任务\n2 InternalTask InternalTask是Runnable的一个实现，主要用于线程池内部，该类会使用到RunnableQueue,然后从queue中取出某个Runnable,并运行runnable的run方法。\n这部分作者直接手写了一个线程池，可怕 = =、\n","date":"2022-08-15T17:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"第八章 线程池原理以及自定义线程池"},{"content":"第七章 捕获线程异常以及Hook线程 1 捕获线程异常 线程在执行单元中是不允许抛出checked异常的，在线程运行的上下文中，父线程无法直接获得它运行时出现的异常信息，对此java给我们提供了一个UncaughtExceptionHandler接口。当线程在运行过程中出现异常时，会回调该接口。从而得知是哪个线程出错，以及出现了什么样的错误。\n线程出现问题，但没有给线程指定UncaughtExceptionHandler接口时，会向上寻找Group的UEH接口，如果还没找到，会继续向上查找Group的接口。最后走到System.err\n2 Hook线程 Hook线程只有在收到退出信号时会被执行，如果在kill的时候使用了-9 那么Hook线程也不会被执行，Hook线程也可以用来执行资源释放，但不要再Hook中执行一些耗时非常长的操作，以为会导致程序无法退出。\n1 Runtime.getRuntime().addShutdownHook() ","date":"2022-08-15T16:50:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8Ahook%E7%BA%BF%E7%A8%8B/","title":"第七章 捕获线程异常以及Hook线程"},{"content":"第六章 ThreadGroup详细讲解 新的线程默认会被加入父线程所在的group中，如同线程存在父子关系一样ThreadGroup同样也存在父子关系。\n1 ThreadGroup API 在一个ThreadGroup中会加入若干线程以及子线程ThreadGroup,ThreadGroup为我们提供了若干个方法可以复制出线程和线程组。\n1.1 复制 Thread 数组 public int enumerate(Thread[] list)\npublic int enumerate(Thread[] list, boolean recurse)\n1.2 复制ThreadGroup数组 public int enumerate(ThreadGroup[] list)\npublic int enumerate(ThreadGroup[] list, boolean recurse)\n","date":"2022-08-15T16:10:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%85%AD%E7%AB%A0-threadgroup%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/","title":"第六章 ThreadGroup详细讲解"},{"content":"第五章 线程间通信 与网络通信等进程间通信方式不一样,线程间通信又称为进程内通信,多个线程实现互斥访问共享资源时会互相发送信号和等待信号。比如线程等待数据到来的信号。线程收到变量改变的信号。\n1 初始wait和notify wait() 导致当前线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法前，导致当前线程等待。\nnotify() 唤醒在此同步监视器上等待的单个线程，如果有多个线程在此同步监视器上等待，则会唤醒其中的一个，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package lyoshur; import java.util.LinkedList; public class EventQueue { private final int max; static class Event{} private final LinkedList\u0026lt;Event\u0026gt; eventQueue = new LinkedList\u0026lt;\u0026gt;(); private final static int DEFAULT_MAX_EVENT = 10; public EventQueue() { this(DEFAULT_MAX_EVENT); } public EventQueue(int max) { this.max = max; } public void offer(Event event) { synchronized (eventQueue) { if (eventQueue.size() \u0026gt;= max) { try { eventQueue.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } eventQueue.addLast(event); eventQueue.notify(); } } public Event take() { synchronized (eventQueue) { if (eventQueue.isEmpty()) { try { eventQueue.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } Event event = eventQueue.removeFirst(); this.eventQueue.notify(); return event; } } } 当eventQueue满时，会调用eventQueue.wait。这时offer会释放掉锁资源，并将当前线程添加到 wait set。\n当消费掉数据后，this.eventQueue.notify(); 会通知某个wait set的线程启动，但不会立即执行，需要当前take释放掉锁。而offer会重新获取锁，并从上次wait的地方继续运行。\n2 多线程间通信 多线程间通信需要用到Object的notifyAll方法。\n这个队列在多线程同时并发的情况下会出现数据不一致的问题，大致可以被分为两部分，一个是超过了最大数量仍在执行add，另一个是没有元素了仍调用remove。\n改进：需要将临界值的判断if更改为while，将notify更改为notifyAll\n3 线程休息室 在虚拟机规范中存在一个wait set的概念，但没有定义具体的数据结构。不同的厂商有着不同的实现方式。线程调用某个对象的wait方法后，都会被加入到与该对象monitor关联的wait set中，至于是先入先出还是随机弹出，虚拟机规范也没有规定。\n4 显示锁 可以使用BooleanLock显示锁来控制。sync不能被打断，但是显示锁可以。\n","date":"2022-08-15T15:10:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","title":"第五章 线程间通信"},{"content":"第四章 线程安全与数据同步 概念 在《操作系统同步原语》 这篇文章中，介绍了操作系统在面对 进程/线程 间同步的时候，所支持的一些同步原语，其中 semaphore 信号量 和 mutex 互斥量是最重要的同步原语。\nsemaphore 信号量 和 mutex 互斥量 monitor 管程\n在使用基本的 mutex 进行并发控制时，需要程序员非常小心地控制 mutex 的 down 和 up 操作，否则很容易引起死锁等问题。为了更容易地编写出正确的并发程序，所以在 mutex 和 semaphore 的基础上，提出了更高层次的同步原语 monitor，不过需要注意的是，操作系统本身并不支持 monitor 机制，实际上，monitor 是属于编程语言的范畴，当你想要使用 monitor 时，先了解一下语言本身是否支持 monitor 原语，例如 C 语言它就不支持 monitor，Java 语言支持 monitor。 一般的 monitor 实现模式是编程语言在语法上提供语法糖，而如何实现 monitor 机制，则属于编译器的工作，Java 就是这么干的。\nmonitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区，这使得 monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 monitor 临界区的 进程/线程，它们应该被阻塞，并且在必要的时候会被唤醒。显然，monitor 作为一个同步工具，也应该提供这样的管理 进程/线程 状态的机制。想想我们为什么觉得 semaphore 和 mutex 在编程上容易出错，因为我们需要去亲自操作变量以及对 进程/线程 进行阻塞和唤醒。monitor 这个机制之所以被称为“更高级的原语”，那么它就不可避免地需要对外屏蔽掉这些机制，并且在内部实现这些机制，使得使用 monitor 的人看到的是一个简洁易用的接口。\n1 synchronized关键字 在jdk1.5之前，要解决这个问题需要使用synchronized关键字，synchronized提供了一种排他机制，在同一时间只能有一个线程执行某些操作。\nsynchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的读写操作都将通过同步的方式来进行。\n1.1 synchronized关键字提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题的出现。\n1.2 synchronized关键字包含了monitor enter和monitor exit 两个JVM指令，它能够保证在任何时候执行到monitor enter之前都必须从主内存获取数据，而不是从缓存中。在monitor exit运行成功后，共享变量被更新的值必须输入主内存。\n1.3 synchronized的指令严格遵守java happends-before规则，一个monitor exit指令之前必定要有一个monitor enter。\n2 This Monitor 和 Class Monitor This Monitor锁定的是对象实例\nClass Monitor锁定的是对象.class\n","date":"2022-08-15T15:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/","title":"第四章 线程安全与数据同步"},{"content":"第三章 ThreadAPI的详细介绍 1 线程sleep sleep是一个静态方法，并有两个重载方法，其中一个需要传入毫秒数，另一个既需要毫秒数也需要纳秒数。\nsleep方法会使当前线程进入指定毫秒数的休眠，暂停执行，虽然给定了一个休眠的时间，但是最终还是要以系统的定时器以及调度器的精度为准，休眠有一个重要的特性就是不会放弃monitor锁的所有权。\nJDK1.5以后JDK引入了一个枚举TimeUtil，其对sleep提供了很好的封装。使用它可以省去很多时间单位的换算步骤。\n2 线程yield yieId方法属于一种启发式的方法，其会提醒调度器我愿意放弃当前CPU资源，如果CPU资源不紧张，则会忽略这种提醒。\n2.1 JDK1.5之前的版本中 yieId的方法事实上是调用了sleep(0)，但是他们之间存在本质的区别\n2.2 yield只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，他会导致线程上下文的切换。\n2.3 sleep会使线程短暂block，会在给定时间内释放CPU资源。\n2.4 yield会使RUNNING状态的Thread进入RUNNABLE状态（如果CPU调度器没有忽略这个提示的话）\n2.5 sleep几乎百分之百的完成了给定时间的休眠，而yield的提示不一定能担保\n2.6 一个线程sleep另一个线程调用interrupt会捕获到中断信号，而yield不会\n3 线程优先级（setPriority） 理论上优先级比较高的线程会获取优先被CPU调度的机会。如果CPU比较忙，优先级高的可能会获得更多的CPU时间片。但是闲事优先级的高低几乎不会有任何作用。\n线程的优先级不能小于1，也不会大于10。如果指定的线程优先级大于线程所在Group的优先级，那么指定的优先级将会失效。取而代之的是group的最大优先级。一般都是5。\n4 获取线程ID public long getId() 获取线程的唯一ID，线程ID在整个JVM进程中都会是唯一的。\n5 获取当前线程 public static Thread currentThread() 用于返回当前线程的引用。\n6 设置线程上下文类加载器 public ClassLoader getContextClassLoader\npublic void setContextClassLoader\n设置该线程的类加载器，这个方法可以打破JAVA类加载器的父类委托机制，有时候该方法也成为JAVA类加载器的后门。\n7 线程interrrupt wait、sleep、join等方法会使当前线程进入阻塞状态，若另一个线程调用被阻塞线程的interrrupt方法，则会打断这种阻塞。\n所以是用来打断阻塞继续运行的？不过打断会导致抛出一个异常InterruptedException\n8 线程join 线程A join线程B，会使线程A进入等待，直到线程B结束生命周期或者到达给定时间，在此期间线程A是处于BLOCKED的\n9 如何关闭一个线程 JDK有一个被弃用的方法，stop用来关闭线程，但这个方法在关闭线程时可能不会释放掉monitor锁，所以强烈建议不要使用该方法结束线程\n9.1 使用中断信号退出线程 9.2 使用volatile开关 ","date":"2022-08-15T14:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%89%E7%AB%A0-threadapi%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","title":"第三章 ThreadAPI的详细介绍"},{"content":"JVM内存结构 JVM在执行java程序时会把对应的物理内存划分成不同的区域，有些分区随着JVM启动而创建，有些则是运行时才创建。\n1 程序计数器 程序计数器用于存放当前线程接下来要执行的字节码指令、分支、循环、跳转、异常处理等信息。每个线程都有自己独立的程序计数器，因此这块区域是线程私有的。\n这是一块比较小的内存，且不会出现任何溢出异常。\n2 JAVA虚拟机栈 虚拟机栈在JVM运行时建立的（这里的运行时，应该是因为程序计数器、JAVA虚拟机栈、本地方法栈都是线程私有的所以需要在线程运行起来时创建）他的生命周期与线程相同，方法在执行时，会创建一个名为栈帧（stack frame）的数据结构，主要用于存放局部变量表、操作栈、动态链接、方法出口等信息。\n方法的调用与退出对应着栈帧在虚拟机栈中的压栈和弹栈过程。\n栈内存的分配大小直接决定了在一个JVM进程中可以创建多少个线程。\n3 本地方法栈 在调用JNI方法时，JVM为本地方法提供的内存区域是本地方法栈，这块区域的内存自由度相当高。完全由不同的JVM厂商实现。线程私有。\n4 堆内存 JVM中最大的一块内存区域，被线程所共享，Java在运行期间创建的所有对象几乎都在堆内存。该内存区域也是垃圾回收重点照顾的区域。因此堆内存有时也称为GC堆。\n堆内存一般会被细分为新生代和老年代。更细致的划分为Eden区（伊甸园区）、From Survivor(幸存者区 S0)、To Survivor(幸存者区 S1)。\n5 方法区 （1.7-） 主要用于存储已经被虚拟机加载的类信息，常量静态变量，JIT编译后的代码等数据。虽然在JVM规范中，将方法区划分为堆内存的一个逻辑分区。但是它经常还是被称为非堆。有时也被叫为持久代。\n6 元空间 （1.8） 自从JDK1.8起，持久代被元空间取而代之（Meta Space）。元空间同样是堆内存的一部分，JVM为每个类加载器分配一块内存块列表，进行线性分配。块的大小取决于类加载器的类型，sun、反射、代理对应的类加载器会小一点。之前的版本会单独卸载回收掉某个类，而现在则是在GC的过程中发现某个类加载器已经具备回收的条件，则会将某个类加载器相关的元空间全部回收，这样可以减少内存碎片，节省GC扫描和压缩的时间。\n","date":"2022-08-15T11:22:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/","title":"JVM内存结构"},{"content":"第二章 深入理解Thread构造函数 1 线程的命名 可以使用不同的构造函数对线程进行命名，为线程起一个有特殊意义的名字。如果没有为线程显式的指定一个名字，那么线程会以“Thread-”作为前缀与一个自增数字进行组合。\n无论你使用默认的函数命名规则，还是指定了一个特殊的名字，在线程启动之前可以使用setName对其进行修改。\n2 线程的父子关系 一个线程的创建肯定是由另一个线程完成的，创建它的线程就是它的父线程。\n3 Thread和ThreadGroup 如果在创建一个线程时，没有指定一个ThreadGroup,那么子线程将会被加入父线程所在的线程组。\n4 Thread与JVM虚拟机栈 在线程的构造函数中，可以发现有一个特殊的参数stackSize。一般情况下，创建线程的时候不会手动指定栈内存的地址空间字节数组。统一通过xss参数进行设置即可。\n5 守护线程 当你希望关闭某些线程的时候，或者退出JVM进程的时候，一些线程能够自动关闭，这个时候可以考虑将一个线程设置为守护线程。\n","date":"2022-08-15T10:50:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","title":"第二章 深入理解Thread构造函数"},{"content":"第一章 快速认识线程 对计算机来说每一个任务就是一个进程（Process）,在每一个进程内部至少要有一个线程（Thread）是在运行中，有时线程也称为轻量级的进程。\n每一个线程都有自己的程序计数器、局部变量表、生命周期。\n线程生命周期大体可以分为如下5个主要的阶段。NEW、RUNNABLE、RUNNING、BLOCKED、TERMINATED。\n1 模板设计模式在Thread中的应用 我们可以通过 new Thread().start(); 的方式启动一个线程，start方法的源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public synchronized void start() { /** * This method is not invoked for the main method thread or \u0026#34;system\u0026#34; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \u0026#34;NEW\u0026#34;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group\u0026#39;s list of threads * and the group\u0026#39;s unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } 最核心的是start0这个本地方法。而start0会调用run方法。\n通过分析，线程的真正执行逻辑是在run方法中，通常我们会将run方法称为线程的执行单元。\n默认的Thread代码如下\n1 2 3 4 5 6 7 8 9 public class Thread implements Runnable { private Runnable target; @Override public void run() { if (target != null) { target.run(); } } } 所以我们可以有两种方式来实现Thread的执行单元，一种是直接重写现成的run方法。另一种是使用构造传递一个Runnable给Thread。\n【NOTE】这里插入一下，这里作者将这种Thread和Runnable之间的关系归类为模板设计模式，然后举了一个数据库查询Handler的例子。但是感觉没有解释清楚模板设计模式和策略模式的区别。个人感觉模板设计模式更侧重于，将模板类的一部分功能，延迟到接口类来进行实现。而策略模式侧重于为了完成某个功能，提供不同的接口类，切换使用。\n","date":"2022-08-15T10:50:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/","title":"第一章 快速认识线程"},{"content":"设计模式设计原则 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 类应该对拓展开放，对修改关闭。 要依赖抽象，不要依赖具体类。 最少知识原则：只和你的密友谈话。 好莱坞原则，别调用我们，我们会调用你。 一个类应该只有一个引起变化的原因。 ","date":"2022-08-12T14:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","title":"设计模式设计原则"},{"content":"javadoc注释规范 暂无\n","date":"2022-08-11T16:00:00Z","permalink":"https://lyoshur.github.io/stack/p/javadoc%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/","title":"javadoc注释规范"},{"content":"JDK工具一览表 工具名称 功能描述 appletviewer.exe 用于运行并浏览applet小程序。 apt.exe 注解处理工具(Annotation Processing Tool)，主要用于注解处理。 extcheck.exe 扩展检测工具，主要用于检测指定jar文件与当前已安装的Java SDK扩展之间是否存在版本冲突。 idlj.exe IDL转Java编译器(IDL-to-Java Compiler)，用于为指定的IDL文件生成Java绑定。IDL意即接口定义语言(Interface Definition Language)。 jabswitch.exe Java访问桥开关(Java Access Bridge switch)，用于启用/禁用Java访问桥。Java访问桥内置于Java 7 Update 6及以上版本，主要为Windows系统平台提供一套访问Java应用的API。 jar.exe jar文件管理工具，主要用于打包压缩、解压jar文件。 jarsigner.exe jar密匙签名工具。 java.exe Java运行工具，用于运行.class字节码文件或.jar文件。 javac.exe Java编译工具(Java Compiler)，用于编译Java源代码文件。 javadoc.exe Java文档工具，主要用于根据Java源代码中的注释信息生成HTML格式的API帮助文档。 javafxpackager.exe JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务。 javah.exe Java头文件工具，用于根据Java类生成C/C++头文件和源文件(主要用于JNI开发领域)。 javap.exe Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件。 java-rmi.exe Java远程方法调用(Java Remote Method Invocation)工具，主要用于在客户机上调用远程服务器上的对象。 javaw.exe Java运行工具，用于运行.class字节码文件或.jar文件，但不会显示控制台输出信息，适用于运行图形化程序。 javaws.exe Java Web Start，使您可以从Web下载和运行Java应用程序，下载、安装、运行、更新Java应用程序都非常简单方便。 jcmd.exe Java 命令行(Java Command)，用于向正在运行的JVM发送诊断命令请求。 jconsole.exe 图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息。 jdb.exe Java调试工具(Java Debugger)，主要用于对Java应用进行断点调试。 jhat.exe Java堆分析工具(Java Heap Analysis Tool)，用于分析Java堆内存中的对象信息。 jinfo.exe Java配置信息工具(Java Configuration Information)，用于打印指定Java进程、核心文件或远程调试服务器的配置信息。 jmap.exe Java内存映射工具(Java Memory Map)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节。 jmc.exe Java任务控制工具(Java Mission Control)，主要用于HotSpot JVM的生产时间监测、分析、诊断。 jps.exe JVM进程状态工具(JVM Process Status Tool)，用于显示目标系统上的HotSpot JVM的Java进程信息。 jrunscript.exe Java命令行脚本外壳工具(command line script shell)，主要用于解释执行javascript、groovy、ruby等脚本语言。 jsadebugd.exe Java可用性代理调试守护进程(Java Serviceability Agent Debug Daemon)，主要用于附加到指定的Java进程、核心文件，或充当一个调试服务器。 jstack.exe Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息。 jstat.exe JVM统计监测工具(JVM Statistics Monitoring Tool)，主要用于监测并显示JVM的性能统计信息。 jstatd.exe jstatd(VM jstatd Daemon)工具是一个RMI服务器应用，用于监测HotSpot JVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上。 jvisualvm.exe JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息。 keytool.exe 密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等。 kinit.exe 主要用于获取或缓存Kerberos协议的票据授权票据。 klist.exe 允许用户查看本地凭据缓存和密钥表中的条目(用于Kerberos协议)。 ktab.exe Kerberos密钥表管理工具，允许用户管理存储于本地密钥表中的主要名称和服务密钥。 native2ascii.exe 本地编码到ASCII编码的转换器(Native-to-ASCII Converter)，用于\u0026quot;任意受支持的字符编码\u0026quot;和与之对应的\u0026quot;ASCII编码和(或)Unicode转义\u0026quot;之间的相互转换。 orbd.exe 对象请求代理守护进程(Object Request Broker Daemon)，它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象。 pack200.exe JAR文件打包压缩工具，它可以利用Java类特有的结构，对普通JAR文件进行高效压缩，以便于能够更快地进行网络传输。 packager.exe 这是微软提供的对象包装程序，用于对象安装包。 policytool.exe 策略工具，用于管理用户策略文件(.java.policy)。 rmic.exe Java RMI 编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMG IDL。 rmid.exe Java RMI 激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象。 rmiregistry.exe Java 远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表。 schemagen.exe XML schema生成器，用于生成XML schema文件。 serialver.exe 序列版本命令，用于生成并返回serialVersionUID。 servertool.exe Java IDL 服务器工具，用于注册、取消注册、启动和终止持久化的服务器。 tnameserv.exe Java IDL瞬时命名服务。 unpack200.exe JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件。 wsgen.exe XML Web Service 2.0的Java API，生成用于JAX-WS Web Service的JAX-WS便携式产物。 wsimport.exe XML Web Service 2.0的Java API，主要用于根据服务端发布的wsdl文件生成客户端存根及框架 xjc.exe 主要用于根据XML schema文件生成对应的Java类。 ","date":"2022-08-11T15:31:00Z","permalink":"https://lyoshur.github.io/stack/p/jdk%E5%B7%A5%E5%85%B7%E4%B8%80%E8%A7%88%E8%A1%A8/","title":"JDK工具一览表"},{"content":"jconsole使用说明 JConsole 是一个内置 Java 性能分析器，可以从命令行（直接输入jconsole）或在 GUI shell （jdk\\bin下打开）中运行。\n它用于对JVM中内存，线程和类等的监控。可使用JTop插件。它可以监控本地的jvm，也可以监控远程的jvm，也可以同时监控几个jvm。\n这款工具的好处在于，占用系统资源少，而且结合Jstat，可以有效监控到java内存的变动情况，以及引起变动的原因。在项目追踪内存泄露问题时，很实用。\n1 概览 以图标的形式显示堆内存使用量，线程使用量，类加载数量，以及CPU占用率\n2 内存 这里比jvisualvm实时性要高一点，并且可以通过切换，来展示堆内存、非堆内存、PS Old Gen、PS Eden Space、PS Survivor Space、Metaspace、Code Cache、Compressed Class Space。等内存的使用图标。\n3 线程 这里能显示活动线程数量以及峰值线程数量的变化图表。\n下面的线程框，能查看每个线程的线程名称，以及线程的堆栈跟踪。还有一个按钮来支持死锁检测。\n4 类 类页卡主要展示已加装当前类数量、已加载类总数、已卸载类总数等类相关信息\n5 VM概要 vm概要主要显示堆信息、虚拟机信息、类路径等相关信息\n6 MBean JMX把所有被管理的资源都成为MBean（ManagedBean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如RMI或HTTP。\n6.1 spring boot程序接入Mbean 在启动程序添加注解@EnableMBeanExport，告知spring自动注册MBean\n在Controller上，添加@ManagedResource注解 （objectName = \u0026ldquo;company:name = testName\u0026rdquo;, descriptiopn = \u0026ldquo;描述信息\u0026rdquo;）\n在值添加 @ManagedAttribute（descriptiopn = \u0026ldquo;描述信息\u0026rdquo;）\n在方法上添加@ManagedOperation\n@ManagedOperationParameter（name= \u0026ldquo;name\u0026rdquo;, descriptiopn = \u0026ldquo;描述信息\u0026rdquo;）\n7 注意事项 想监控JAVA程序需要在程序启动时，添加JMX相关参数。如果是本地连接，可以不加\n","date":"2022-08-11T13:31:00Z","permalink":"https://lyoshur.github.io/stack/p/jconsole%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"jconsole使用说明"},{"content":"jvisualvm使用说明 JVisualVM是JDK自带的性能检测工具，路径在%JAVA_HOME%/bin下面。双击打开\n在本地页卡下是，本地启动的java程序列表，同时能够包含显示Pid\n点击某一个程序，能够从 概述、监视、线程、抽样器、Profiler 几个防线显示应用程序的信息\n概述 概述下主要包括应用程序的PID、主类、以及JVM相关的一些参数。系统属性这里能够显示一些java、spring、tomcat等相关属性信息\n监视 监视页卡主要显示CPU使用情况，堆内存使用情况，装载的类数量、以及线程活跃情况\n线程 线程页卡主要显示线程的活跃情况，根据不同颜色包含运行、休眠、等待、驻留、监视等几个不同的状态。\n这里可以使用右上角的线程Dump,来获取每个线程的调用栈信息。\n抽样器 抽样器是这个工具比较核心的部分，主要分为CPU抽样和内存抽样。\nCPU抽样能按照CPU样例显示每个java方法（这里能看到自定义的方法名）的CPU执行时间，可以通过页卡切换为每个线程的CPU占用时间。这里有些线程是类似Thread-22这种线程名称，如果需要定位到具体某个类启动的方法，可以结合线程的线程Dump来定位具体的线程。\n内存抽样能按照堆内存中的不同变量类型，显示内存占用，不过因为实现原理的原因，比如说 String的底层是 []char，显示的结果并不是太直观。点击每个线程分配页卡，能看到每个线程的内存分配用量。\n内存抽样还可以手动点击执行GC，来测试内存回收结果。点击堆Dump，可以导出展示当前堆内存结果，类似String之类比较简单的内存，能看到一些简单值。\nProfiler 暂时不知道有什么用，点击后显示正在连接到目标VM就卡死了 = =、\n","date":"2022-08-11T13:31:00Z","permalink":"https://lyoshur.github.io/stack/p/jvisualvm%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"jvisualvm使用说明"},{"content":"3 进行简单数据查询 1 2 # 获取Service 参数为数据库内的表名 test_service = factory.get_service(\u0026#34;tb_test\u0026#34;) 获取对应数据库表的service后，能够使用内置的常用增删改查方法，对数据库进行操作\n3.1查询列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 查询当前service的列表,其中参数为空字典，表示不使用任何搜索条件 list_data = test_service.get_list({}) print(list_data) # 当需要分页时，可以使用 # start 开始查询的起点记录 0表示从第一条记录查询 # length 要查询几条数据 # order_by 列表排序条件 例如 id asc 正序 或 id desc 逆序 list_data = test_service.get_list({}, start=0, length=10, order_by=\u0026#34;id\u0026#34;) print(list_data) # 搜索name字段等于张三 # 当输入%时，表示要使用模糊搜索 # %张向前模糊，张%向后模糊，%张%全模糊 list_data = test_service.get_list({ \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34; }, start=0, length=10, order_by=\u0026#34;id\u0026#34;) print(list_data) 3.2 查询记录数量 1 2 3 4 5 6 7 8 9 # 查询当前service的数据总数,其中参数为空字典，表示不使用任何搜索条件 count = test_service.get_count({}) print(count) # 搜索name字段等于张三的记录数量 # 当输入%时，表示要使用模糊搜索 # %张向前模糊，张%向后模糊，%张%全模糊 count = test_service.get_count({\u0026#34;name\u0026#34;: \u0026#34;张%\u0026#34;}) print(count) 3.3 查询单条记录 1 2 3 4 5 6 7 # 搜索第一条记录，等同于get_list，但是只返回第一条记录 model = test_service.get_first({\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(model) # 查询主键对应的记录，条件必须是主键且不能为空 model = test_service.get_model({\u0026#34;id\u0026#34;: 1}) print(model) 3.4 判断记录是否存在 注意在liteorm==0.0.1或myorm==1.0.2中，这个方法存在BUG，请使用count。然后自行判断记录是否存在！\n1 2 3 4 5 6 7 8 9 # 判断记录是否存在，参数等同于get_list，但是只返回Boolean exist = test_service.exist({}) print(exist) # 判断记录是否存在，参数等同于get_list，但是只返回Boolean exist = test_service.exist({ \u0026#34;name\u0026#34;: \u0026#34;张%\u0026#34; }) print(exist) 3.5 新增记录 1 2 3 4 5 6 # 插入记录 字典key对应数据库字段名 # 当主键设置了自增时，将值写为 0 test_service.insert({ \u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34; }) 3.6 更新记录 1 2 3 4 5 6 # 更新记录 字典key对应数据库字段名 # 根据主键更新，必须填写主键 test_service.update({ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;李四+1\u0026#34; }) 3.7 删除记录 1 2 # 根据主键删除记录，必须填写主键 test_service.delete({\u0026#34;id\u0026#34;: 3}) 4 自定义SQL 当Service中的方法，不满足需求时或需要自定SQL执行可以使用以下方法\n根据返回值不同，方法被分成三类\n4.1 查询记录 1 2 3 4 # 使用自定义SQL进行列表查询 # 需要参数化的变量 使用 #{变量名} 进行查询 data = factory.query(\u0026#34;select * from tb_test where `name` = #{name}\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 4.2 查询记录条数 1 2 3 4 # 使用自定义SQL进行列表数量查询 # 需要参数化的变量 使用 #{变量名} 进行查询 number = factory.count(\u0026#34;select count(1) from tb_test where `name` = #{name}\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(number) 4.3 执行查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用自定义SQL进行数据插入 # 需要参数化的变量 使用 #{变量名} 进行查询 # 返回两个参数，第一个为插入记录的ID，第二个为本次操作影响的记录行数 id, _ = factory.exec(\u0026#34;INSERT INTO tb_test(name) VALUES(#{name})\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(id) # 使用自定义SQL进行数据插入 # 需要参数化的变量 使用 #{变量名} 进行查询 # 返回两个参数，第一个为插入记录的ID，第二个为本次操作影响的记录行数 _, row_number = factory.exec(\u0026#34;UPDATE tb_test SET name = #{new_name} WHERE name = #{old_name}\u0026#34;, { \u0026#34;new_name\u0026#34;: \u0026#34;张三+1\u0026#34;, \u0026#34;old_name\u0026#34;: \u0026#34;张三\u0026#34; }) print(row_number) 5 使用Mapper查询 5.1 使用Mapper独立文件查询 当有SQL需要复用，或希望将SQL放置到文件中统一管理时，可以使用Mapper文件进行\nMapper文件内容完整结构如下\nmapper节点可以对数据查询结果中的字段重命名，类似 select name as record_name\n如果不需要也可以不写mapper节点\nsql为条sql节点，包含一个key，来作为这条sql的标识，value为sql具体内容\n示例：tb_test.mapper文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;xml\u0026gt; \u0026lt;mapper column=\u0026#34;id\u0026#34; parameter=\u0026#34;record_id\u0026#34;/\u0026gt; \u0026lt;mapper column=\u0026#34;name\u0026#34; parameter=\u0026#34;record_name\u0026#34;/\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetList\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select * from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetCount\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select Count(1) from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;Insert\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; INSERT INTO tb_test(name) VALUES(#{name}) \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;/xml\u0026gt; 然后将文件加载到框架中使用\n1 2 3 4 5 6 7 8 # 将mapper加载到框架中 # tb_test_dao 是随意起的一个名字 # 通过 orm.parse_config_from_file 将mapper文件加载到框架，用于生成dao实例 factory.load_dao(\u0026#34;tb_test_dao\u0026#34;, orm.parse_config_from_file(\u0026#34;tb_test.mapper\u0026#34;)) # 使用加载后的DAO进行查询，这时的第一个参数，对应到mapper文件中sql节点里的Key关键字 data = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;).query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 与自定义SQL查询相同，根据返回值不同，DAO实例提供了三个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 获取dao tb_test_dao = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;) # 查询列表使用 dao.query data = tb_test_dao.query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) # 查询记录数量使用 dao.count count = tb_test_dao.count(\u0026#34;GetCount\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(count) # 执行SQL使用 返回值等同于 factory.exec id, _ = tb_test_dao.exec(\u0026#34;Insert\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(id) 5.2 使用Mapper格式字符串查询 框架也支持加载Mapper格式字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 定义一个Mapper格式的字符串 sql_xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;xml\u0026gt; \u0026lt;mapper column=\u0026#34;id\u0026#34; parameter=\u0026#34;record_id\u0026#34;/\u0026gt; \u0026lt;mapper column=\u0026#34;name\u0026#34; parameter=\u0026#34;record_name\u0026#34;/\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetList\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select * from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;/xml\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 将mapper加载到框架中 # 通过 orm.parse_config_from_string 将mapper字符串加载到框架 factory.load_dao(\u0026#34;tb_test_dao\u0026#34;, orm.parse_config_from_string(sql_xml)) # 查询列表使用 dao.query data = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;).query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 6 事务支持 6.1 通过函数执行事务 1 2 3 4 5 6 7 8 9 10 11 # 定义一个方法 # 将需要进行的数据库操作，放在方法内 def insert_all(): factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34;}) # 通过 factory.transaction 执行刚刚定义的方法 # 注意参数是方法本身 不要写成 factory.transaction(insert_all()) # 这样处于方法内部的查询，则被加入到同一个数据库事务中 factory.transaction(insert_all) 6.2 通过装饰器开启事务 1 2 3 4 5 6 7 8 9 10 11 # 定义一个方法 # 将需要进行的数据库操作，放在方法内 @factory.transaction_wraps def insert_all(): factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34;}) # 因为方法上被加上了 @factory.transaction_wraps 装饰器 # 则这个方法被执行时，会自动启用事务 insert_all() ","date":"2022-03-13T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/python-orm%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"python-orm数据库查询框架使用教程"},{"content":"myorm mysql数据库查询框架 1 依赖安装 1 pip install mysqlconn 2 连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 引入最好这样写，推荐写法 from myorm import orm # 连接数据库 factory = orm.Builder( \u0026#34;127.0.0.1\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;test\u0026#34;, 3306 ).build() # 从数据库解析数据库表结构，加载通用的Service # 全局仅需执行一次！！ # 建议放到数据库连接之后直接执行 factory.load_service() ","date":"2022-03-12T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8myorm%E8%BF%9E%E6%8E%A5%E5%88%B0mysql/","title":"使用myorm连接到mysql"},{"content":"liteorm sqlite3数据库查询框架 1 依赖安装 1 pip install liteorm 2 连接数据库 1 2 3 4 # 引入最好这样写，推荐写法 from liteorm import orm # 连接数据库 factory = orm.Builder(\u0026#34;test.db\u0026#34;).build() ","date":"2022-03-11T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8liteorm%E8%BF%9E%E6%8E%A5%E5%88%B0sqlite3/","title":"使用liteorm连接到sqlite3"},{"content":"stream流操作 stream位于java.util包中，是java8中新增类。\n1.创建Stream 1.1使用数组转为流 1 2 3 4 5 6 String[] a = new String[3]; // 模拟设置值 Stream\u0026lt;String\u0026gt; ss = Stream.of(a); long len = ss.count(); System.out.println(len); 1.2使用数组转化为流 1 2 3 4 5 6 String[] a = new String[3]; // 模拟设置值 Stream\u0026lt;String\u0026gt; ss = Arrays.stream(a); long len = ss.count(); System.out.println(len); 1.3使用List转化为流 1 2 3 4 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); Stream\u0026lt;String\u0026gt; ss = list.stream(); System.out.println(ss.count()); 2.使用流 2.1筛选记录 filter 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().filter(new Predicate\u0026lt;String\u0026gt;() { @Override public boolean test(String s) { return s.startsWith(\u0026#34;a\u0026#34;); } }); System.out.println(ss.count()); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;a\u0026#34;)); System.out.println(ss.count()); 2.2处理记录 map 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().map(new Function\u0026lt;String, String\u0026gt;() { @Override public String apply(String s) { return s + \u0026#34;-hahahaa\u0026#34;; } }); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().map(s -\u0026gt; s + \u0026#34;-hahahah\u0026#34;); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 2.3进行排序 sorted 1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().sorted(); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 2.4合并流 flatMap 可以类似map，针对流中的每个元素进行处理，不同的是，返回值需要是一个另外的流。然后flatMap会将返回的所有流，进行合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;Integer\u0026gt; ss = list.stream().flatMap(new Function\u0026lt;String, Stream\u0026lt;Integer\u0026gt;\u0026gt;() { @Override public Stream\u0026lt;Integer\u0026gt; apply(String s) { return Stream.of(1, 2, 3); } }); System.out.println(ss.collect(Collectors.toList())); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;Integer\u0026gt; ss = list.stream().flatMap(s -\u0026gt; Stream.of(1, 2, 3)); System.out.println(ss.collect(Collectors.toList())); 3.对流进行约简 3.1收集为列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 重新将流收集成列表 List\u0026lt;String\u0026gt; data = ss.collect(Collectors.toList()); // 通过指定收集列表类型，来返回指定类型列表 // ArrayList ArrayList\u0026lt;String\u0026gt; data1 = ss.collect(Collectors.toCollection(ArrayList::new)); // LinkedList LinkedList\u0026lt;String\u0026gt; data2 = ss.collect(Collectors.toCollection(LinkedList::new)); System.out.println(data); 3.2收集为Set 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Set Set\u0026lt;String\u0026gt; data = ss.collect(Collectors.toSet()); System.out.println(data); 3.3收集为Map 3.3.1聚组Map 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Map Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; data = ss.collect(Collectors.groupingBy(String::toString)); System.out.println(data); 3.3.2键值对Map 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Map Map\u0026lt;String, String\u0026gt; data = ss.collect(Collectors.toMap(String::toString, String::toString)); System.out.println(data); 3.4收集为String 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成String String data = ss.collect(Collectors.joining(\u0026#34;-\u0026#34;)); System.out.println(data); 3.5 Collectors.collectingAndThen 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 首先将列表收集为Set进行去重，然后重新收集为列表 List\u0026lt;String\u0026gt; data = ss.collect(Collectors.collectingAndThen(Collectors.toSet(), ArrayList::new)); System.out.println(data); 4.其他约简操作 4.1返回Optional 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 查找列表第一个 Optional\u0026lt;String\u0026gt; data = ss.findFirst(); System.out.println(data.toString()); 4.2返回布尔值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 查找列表中，有没有 \u0026#34;a\u0026#34; boolean data = ss.anyMatch(s -\u0026gt; s.equals(\u0026#34;a\u0026#34;)); // 查找列表中，是不是全是 \u0026#34;a\u0026#34; boolean data1 = ss.allMatch(s -\u0026gt; s.equals(\u0026#34;a\u0026#34;)); System.out.println(data); ","date":"2022-03-10T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/stream%E6%B5%81%E6%93%8D%E4%BD%9C/","title":"stream流操作"},{"content":"java9 中的 Module, ModulePath 和 ClassPath 我们都知道，从 Java9 开始，引入了模块系统，提供了对大型复杂系统很重要的隔离，依赖管理等特性。\n首先是个吐槽。\n作为Java9的主要特性，抛开JDK本身的需求，模块系统的设计有不少可以商榷的地方，也引起了不小的争议，甚至一度被JCP否决；对用户来说，迁移成本高，收益不明显，为了这个项目花了三年半的时间，Block了其他项目的进展，让本来已经老旧的Java显得更加老旧，实在是不明智啊。\n下面是正文开始。\n一个Jar包，如果根目录下有 module-info.class 这个文件，则是一个已经包含了模块化信息的模块。在 module-info.class 中，可以指定此模块的名字和版本，哪些 Package 可以被别的模块访问，依赖于哪些模块，这些依赖是否继续传递等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 module net.dongliu.serviceimpl { requires net.dongliu.utils; requires net.dongliu.service; exports net.dongliu.serviceimpl.api; provides net.dongliu.service.MyService with net.dongliu.serviceimpl.MyServiceImpl; } 旧项目的兼容\n然而在此之前已经发布的Jar包，和开发的项目，都是没有模块化的，Java9 如何处理这些Jar包和项目呢? 这就要靠新引入的 ModulePath了，简单的说就是老人老办法，新人新办法，对 ClassPath 和 ModulePath 采用不同的规则。\nModulePath 和 ClassPath\nModulePath 的概念和ClassPath 类似，不过 ModulePath 中的 Jar 包或 Jmod 文件被当作 Module 来处理，而 ClassPath 中的的 Jar 包，无论是否模块化都会被当作传统 Jar 包处理。\nJava9 制定了以下规则以保证旧 Jar 包和项目可以无缝的迁移到新的 Java 版本上:\n所有 ClassPath 下的 Jar 包，Class，资源文件等都在一个 Unnamed Module 中\nUnnamed Module 的 Class 可以看到和使用所有 Module Path 中导出的 Package，所有 Class Path 中的 Package，以及所有 JDK 系统模块的 Package\nModulePath 下普通模块中的 Class 只能看到 module-info 中定义的依赖模块中导出的 Package，也看不到 Unnamed Module 中的内容。\n根据这些规则，如果项目还是使用 ClassPath，则对项目来说没有影响，项目也不需要定义模块依赖。另外，项目的依赖可以放在 ClassPath 上，也可以放在 ModulePath 上，区别是放在 ModulePath 上的话不能使用模块中未标记为导出的 Package。\n这里需要解释一下 Unnamed Module。Unnamed Module 是一个特殊的，自动生成的 Module，所有 ClassPath 下的内容在 Java9 中都是挂在 Unnamed Module 名下的。对于同一个 ClassLoader，只有一个 Unnamed Module。\n模块化项目使用未模块化的 Jar 包\n现在对于未模块化的传统项目没问题了，那么，如果要创建一个模块化的项目，但是依赖的 Jar 包还没有模块化怎么办？按照上面的规则，因为这些 Jar 包没有模块信息，所以就没法在项目的 module-info 中定义这个依赖。为了保证模块化的新项目能够使用尚未模块化的旧 Jar 包，又定义了 Automatic Module 的概念。\nAutomatic Module\n一个不包含 module-info.class 的传统 Jar 包，如果放到了 ModulePath 下，就变成了一个 Automatic Module。\n一个 Automatic Module:\n默认的依赖于所有 ModulePath 中的模块，可以访问所有模块中导出的 Package。\n默认导出此模块中的所有 Package。\n如果 Jar 包在 MetaInfo 文件中定义了 Automatic-Module-Name，则使用这个值作为模块的名称；如果没有定义，那么使用 Jar 包的文件名去掉扩展名的那部分作为模块名，其中包含的-要替换成.，因为模块名不允许包含-字符。\n按照如上规则，项目中就可以把一个未模块化的 Jar 包，当成一个模块来使用了。\nAutomatic Module 的争议\nJigsaw 这个项目，其中最有争议的是如何自动给模块命名，也就是上面的第三个规则。Jigsaw 项目的 JSR 投票第一次被否决，除了 IBM，JBoss 这样因为有自己的模块系统而处于政治原因投反对票的之外，基本上都是由于反对这个自动命名规则。现在的项目基本是采用 Maven，Gradle 等组织构建，这些项目最后生成的 Jar 包文件名只包含 artifactId，用这个做模块名明显是不合适的。更多的人希望用 groupId + artifactId 来作为模块——这个是可行的，因为 Maven 项目生成的 Jar 包会在 META-INF/maven 下保存项目的元信息。可惜的是最后仍然是没有采用这个方案。\n所以为了保证将来平滑的迁移，如果你是一个模块的维护者，可以在 MANIFEST.MF 中加一个Automatic-Module-Name 的值。 比如使用 Maven 的话可以这样指定:\nmaven-jar-plugin\nnet.dongliu.service\n","date":"2022-03-09T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java9-%E4%B8%AD%E7%9A%84-module-modulepath-%E5%92%8C-classpath/","title":"java9 中的 Module, ModulePath 和 ClassPath"},{"content":"java反编译 在使用idea进行反编译class文件时，发现文件头会带有\n1 2 3 4 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // 于是想利用idea自带的反编译插件，来对已经存在的JAR包进行反编译。\n不过在idea安装目录，插件中查找没有找到Fernflower。后搜索教程，教程说内置的插件名称是java-decompiler\n这里怀疑是idea对Fernflower进行了插件化封装。\n使用反编译命令，对jar包进行反编译\n1 java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -hdc=0 -dgs=1 -rsy=1 -rbr=1 -lit=1 -nls=1 -mpm=60 \u0026lt;jar\u0026gt; \u0026lt;反编译后的JAR生成目录\u0026gt; -cp \u0026lt;目录和 zip/jar 文件的类搜索路径\u0026gt;\n反编译后生成结果仍然是JAR包，但是可以使用命令\n1 jar -xf \u0026lt;jar\u0026gt; 对反编译生成的JAR包进行解包，解包结果就是反编译后的class文件\n！使用命令对 java-decompiler.jar 进行解包\n1 2 3 4 5 6 \u0026lt;id\u0026gt;org.jetbrains.java.decompiler\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Java Bytecode Decompiler\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt; Extends standard .class file viewer with the Fernflower Java decompiler \u0026lt;/description\u0026gt; \u0026lt;vendor\u0026gt;JetBrains\u0026lt;/vendor\u0026gt; 确实，这个插件是继承自 Fernflower 的\n","date":"2022-03-08T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E5%8F%8D%E7%BC%96%E8%AF%91/","title":"java反编译"},{"content":"3dmax激活操作 1 需要的软件 所需要的软件已经整理到文件夹 3DMAX安装包-20220706 中，共包含以下内容：\n1.1 Autodesk_3ds_Max_2020_64bit.7z 3dsMax程序主体和注册机程序。\n1.2 IE10-Win7-X64.exe IE10浏览器安装程序\n1.3 NDP452-KB2901907-x86-x64-AllOS-ENU.exe .net4.5依赖环境，不确定是否需要，但安装前安装了这个依赖。\n1.4 微软常用运行库合集 2021.01.15.exe C++2015-2019等常用的依赖环境合集。\n1.5 3dsMax2020.3_Update.exe 升级包程序，将2020版本3dmax升级到2020.3\n2 破解步骤 2.1 正常安装3dmax后，进入到准备激活页面，暂时不点击激活按钮。 2.2 打开IE浏览器，修改右上角设置-\u0026gt;Internet选项设置。 2.2.1 点击 安全-\u0026gt;受限制的站点。取消掉 启用保护模式按钮 2.2.2 点击自定义级别，并按照以下描述修改配置 ActiveX控件和插件 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nActiveX控件自动提示 启用\n对标记为可安全执行脚本的ActiveX控件执行脚本 启用\n对标记为可安全执行的脚本的ActiveX控件初始化并执行 启用\n二进制文件和脚本行为 启用\n仅允许经过批准的域在未经提示的情况下使用ActiveX 禁用\n下载未签名的ActiveX控件 启用\n下载已签名的ActiveX控件 启用\n允许ActiveX筛选 禁用\n允许Scriptlet 启用\n允许运行以前未使用的ActiveX控件而不提示 启用\n运行ActiveX控件和插件 启用\n脚本 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\nJava小程序脚本 启用\n活动脚本 启用\n2.2.3 点击高级选项页卡 勾选 允许活动内容在\u0026quot;我的电脑\u0026quot;的文件中运行\n勾选 允许运行或安装软件，及时签名无效\n2.2.4 保存后提示 当前的安全设置导致计算机存在安全风险 点击是 应用 确定。这时浏览器下方提示 当前的安全设置使计算机面临风险，不要理。\n这里需要重启IE浏览器，来让配置生效。\n2.3 回到3dmax界面，点击激活。 这个时候应该能正常显示激活页面，根据提示输入\n序列号 666-69696969 产品密钥 128L1\n点击下一步，进入输入激活码页面\n2.4 注册机生成激活码 以管理员身份打开注册机程序，复制激活码页面生成的申请号（第四行，最长的那一串数字）\n将复制的数字，粘贴到注册机 Request 输入框。点击Generate 生成得到激活码。\n点击Patch。\n将激活码完整复制，返回到3dmax界面。\n2.5 输入激活码 3dsmax点击 我具有Autodesk提供的激活码（下面那个选项）\n粘贴激活码(某些电脑可能粘贴时会报错，手动输入一下。四个字符一组)，点击下一步。\n2.6 激活错误页面 如果出现激活错误代码 800c0005, 点击使用其他方式，关闭页面。稍等，看3dmax会不会自动启动，正常进入程序。\n3 问题思路 在进入到3dmax激活页面后，发现页面白屏。后发现页面中可以右键，这里基本能确定这里是一个类似webview的组件，来嵌入的激活网页。\n首先尝试，在右键中选择属性，复制激活页面的地址，复制到chrome浏览器中进行逐步的激活步骤，但操作完成后，3dmax并没有收到激活的信息。\n这里能够排除激活页面是通过接口方式和3dmax通信的。\n将激活页面地址复制到IE浏览器，发现浏览器提示页面已经禁用的ActiveX,是否允许。点击允许后，激活页面能够正常显示。\n所以这里猜测，是IE浏览器的安全策略，阻止了ActiveX控件的加载，而ActiveX控件，经常作为越过浏览器对系统程序操作的入口。\n所以这里猜测，3dmax是通过内嵌webview，并通过ActiveX控件来和激活页面通信。而页面白屏是因为IE默认禁用了ActiveX。所以尝试修改Internet选项，默认允许IE加载ActiveX。\n修改配置后，重新进入激活页面，激活成功。\n4 其他操作 4.1 激活进入不可输入序列号，机器码的状态或无法进入激活码输入页面 可以关闭3dmax主程序，并在任务管理器中，结束掉autodesk相关的进程树。然后删除掉 C:\\ProgramData\\FLEXnet 文件夹。\n4.2 安装时因为注册表冲突，导致安装失败 win r 运行，regedit 打开注册表编辑器。找到 HKEY_LOCAL_MACHINE / SOFTWARE / Autodesk 注册表项。删除掉3dsmax文件夹，如果确定本机没有autodesk家的其他产品，也可以直接删除掉整个Autodesk文件夹。\n","date":"2022-03-07T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3dmax%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C/","title":"3DMAX激活操作"},{"content":"文中内容需要java、spring、maven等基础知识。\n使用的spring boot版本为 2.0.3.RELEASE\n使用的spring cloud版本为 Finchley.RELEASE\n内容部分来自网络，在整理过程中尽量记录了原文地址，但不排除有遗漏。\n0.说明 - 2019.11.15\n1.Eureka - 2019.11.15\n2.Ribbon - 2019.11.19\n3.Feign - 2019.11.19\n4.Hystrix - 2019.11.19\n5.Zuul - 2019.11.19\n6.Config - 2019.11.19\n附：Spring版本以及Maven spring-milestones作用 - 2019.11.15\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/0.%E8%AF%B4%E6%98%8E-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"0.说明-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"文中内容需要java、spring、maven等基础知识。\n使用的spring boot版本为 2.1.8.RELEASE\n使用的spring cloud版本为 Greenwich.SR3\n内容部分来自网络，在整理过程中尽量记录了原文地址，但不排除有遗漏。\n0.说明 - 2019.11.15\n1.Eureka - 2019.11.15\n2.Ribbon - 2019.11.19\n3.Feign - 2019.11.19\n4.Hystrix - 2019.11.19\n5.Zuul - 2019.11.19\n6.Config - 2019.11.19\n附：Spring版本以及Maven spring-milestones作用 - 2019.11.15\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/0.%E8%AF%B4%E6%98%8E-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"0.说明-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nEureka Spring Cloud包含了非常多的子框架，其中，Spring Cloud netflix是其中一套框架，由Netflix开发后来又并入Spring Cloud大家庭，它主要提供的模块包括：服务发现、断路器和监控、智能路由、客户端负载均衡等。\nEureka，服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用Eureka的服务发现客户端来将自己注册到Eureka的服务器上。\n1.起步，创建项目 我使用的IDEA版本号为2018.1.4，java版本号为1.8.0_172。\n由于需要测试Eureka注册服务，所以我们需要创建两个项目，一个项目作为注册中心使用，一个作为服务，注册到注册中心。为了方便管理依赖，建立一个父项目，两个模块。\n父项目使用maven直接创建。 创建完成后，由于父项目不保存任何代码，所以可以选择删除掉src文件夹。然后开始整理POM依赖。整理后的pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 父项目 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 这里默认的boot版本为2.2.1.RELEASE。手动修改为2.0.3.RELEASE --\u0026gt; \u0026lt;version\u0026gt;2.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 对应创建项目时填写的内容 --\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式，父项目的打包方式为pom,子项目（模块）为jar --\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 项目名和简介 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;!-- 这里是声明子模块，由于子模块这时还没创建，可能报红 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;eureka\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;test\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;!-- 子项目可以继承父项目中的属性 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 添加编码信息 --\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!-- 定义属性，方便依赖使用 --\u0026gt; \u0026lt;spring.boot.version\u0026gt;2.0.3.RELEASE\u0026lt;/spring.boot.version\u0026gt; \u0026lt;spring.cloud.version\u0026gt;Finchley.RELEASE\u0026lt;/spring.cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 父项目不保存依赖，所以注释掉 --\u0026gt; \u0026lt;!-- \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; --\u0026gt; \u0026lt;!-- 添加依赖管理信息 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!-- 参考 附：Spring版本以及Maven spring-milestones作用 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; 父项目主要用来管理依赖，组织项目，所以不需要使用spring boot。\n2.Eureka，创建注册中心 然后开始创建Eureka注册中心。在项目中新建一个Module，类型选择spring boot。注意保持groupId与父项目相同。同样开始整理pom：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;eureka\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好依赖问题后，开始编写代码。\n首先修改src/main/java/com.example.eureka.EurekaApplication文件。这里的路径与设置的GroupId、ArtifactId有关。不一定和我的相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.eureka; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; // 添加启用EurekaServer注解（别忘了import） @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 然后修改配置文件src/main/resources/application。修改后缀.properties为.yml(不修改也可以，但是.properties文件的写法和yml文件不一样，记得转换)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring: application: name: eurka-server server.port 端口地址 eureka.instance.hostname 域名或IP eureka.client.registerWithEureka/fetchRegistry 通过两个false，来表明自己是一个eureka server eureka.client.serviceUrl.defaultZone 注册中心服务地址 spring.application.name 应用名或服务名 eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。\n这时打开浏览器访问：http://localhost:8761，就能看到eureka的界面了。\n3.Eureka，创建一个服务，注册到注册中心 新建一个新的Module，与上一步类似。然后开始整理POM文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 这样，处理好POM文件后，开始编写代码，修改src/main/java/com/example/test/TestApplication:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success\u0026#34;; } } 这里写了一个简单的接口，用来测试test服务是否启动成功。\n配置配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 8762 spring: application: name: service-hi eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server.port 端口地址 eureka.instance.hostname 域名或IP eureka.instance.instance-id 实例ID eureka.client.serviceUrl.defaultZone 注册中心服务地址 eureka.client.serviceUrl.defaultZone这时应配置为eureka的地址。\n启动当前项目，访问http://localhost:8762/test。就能看到打印出的success\nhttp://localhost:8761可以看到SERVICE-HI服务已经注册成功了。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.eureka-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"1.Eureka-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nEureka Spring Cloud包含了非常多的子框架，其中，Spring Cloud netflix是其中一套框架，由Netflix开发后来又并入Spring Cloud大家庭，它主要提供的模块包括：服务发现、断路器和监控、智能路由、客户端负载均衡等。\nEureka，服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用Eureka的服务发现客户端来将自己注册到Eureka的服务器上。\n1.起步，创建项目 我使用的IDEA版本号为2018.1.4，java版本号为1.8.0_172。\n由于需要测试Eureka注册服务，所以我们需要创建两个项目，一个项目作为注册中心使用，一个作为服务，注册到注册中心。为了方便管理依赖，建立一个父项目，两个模块。\n父项目使用maven直接创建。 创建完成后，由于父项目不保存任何代码，所以可以选择删除掉src文件夹。然后开始整理POM依赖。整理后的pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 父项目 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 这里默认的boot版本为2.2.1.RELEASE。手动修改为2.1.8.RELEASE --\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 对应创建项目时填写的内容 --\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式，父项目的打包方式为pom,子项目（模块）为jar --\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 项目名和简介 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;!-- 这里是声明子模块，由于子模块这时还没创建，可能报红 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;eureka\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;test\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;!-- 子项目可以继承父项目中的属性 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 添加编码信息 --\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!-- 定义属性，方便依赖使用 --\u0026gt; \u0026lt;spring.boot.version\u0026gt;2.1.8.RELEASE\u0026lt;/spring.boot.version\u0026gt; \u0026lt;spring.cloud.version\u0026gt;Greenwich.SR3\u0026lt;/spring.cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 父项目不保存依赖，所以注释掉 --\u0026gt; \u0026lt;!-- \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; --\u0026gt; \u0026lt;!-- 添加依赖管理信息 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!-- 参考 附：Spring版本以及Maven spring-milestones作用 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; 父项目主要用来管理依赖，组织项目，所以不需要使用spring boot。\n2.Eureka，创建注册中心 然后开始创建Eureka注册中心。在项目中新建一个Module，类型选择spring boot。注意保持groupId与父项目相同。同样开始整理pom：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hdemo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;eureka\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好依赖问题后，开始编写代码。\n首先修改src/main/java/com.example.eureka.EurekaApplication文件。这里的路径与设置的GroupId、ArtifactId有关。不一定和我的相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.eureka; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; // 添加启用EurekaServer注解（别忘了import） @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 然后修改配置文件src/main/resources/application。修改后缀.properties为.yml(不修改也可以，但是.properties文件的写法和yml文件不一样，记得转换)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring: application: name: eurka-server server.port 端口地址 eureka.instance.hostname 域名或IP eureka.client.registerWithEureka/fetchRegistry 通过两个false，来表明自己是一个eureka server eureka.client.serviceUrl.defaultZone 注册中心服务地址 spring.application.name 应用名或服务名 eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。\n这时打开浏览器访问：http://localhost:8761，就能看到eureka的界面了。\n3.Eureka，创建一个服务，注册到注册中心 新建一个新的Module，与上一步类似。然后开始整理POM文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 这样，处理好POM文件后，开始编写代码，修改src/main/java/com/example/test/TestApplication:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success\u0026#34;; } } 这里写了一个简单的接口，用来测试test服务是否启动成功。\n配置配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 8762 spring: application: name: service-hi eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server.port 端口地址 eureka.instance.hostname 域名或IP eureka.instance.instance-id 实例ID eureka.client.serviceUrl.defaultZone 注册中心服务地址 eureka.client.serviceUrl.defaultZone这时应配置为eureka的地址。\n启动当前项目，访问http://localhost:8762/test。就能看到打印出的success\nhttp://localhost:8761可以看到SERVICE-HI服务已经注册成功了。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.eureka-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"1.Eureka-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"1.伪分布式节点启动报错 执行命令 ./start-dfs.sh\n错误信息：\n1 2 3 4 5 6 7 8 9 Starting namenodes on [10.1.4.57] ERROR: Attempting to operate on hdfs namenode as root ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation. Starting datanodes ERROR: Attempting to operate on hdfs datanode as root ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation. Starting secondary namenodes [10.1.4.57] ERROR: Attempting to operate on hdfs secondarynamenode as root ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation. 解决办法：\n1.sbin/start-dfs.sh和sbin/stop-dfs.sh脚本头部指定\n1 2 3 4 HDFS_DATANODE_USER=root # HDFS_DATANODE_SECURE_USER=hdfs（此条功能暂时不明，注释后无影响） HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root 2.环境变量 hadoop-env.sh中指定用户名：（未验证）\n1 2 3 export HDFS_DATANODE_USER=root export HDFS_DATANODE_USER=root export HDFS_SECONDARYNAMENODE_USER=root 注：***_USER设置错误，会报cannot set priority of datanode process 32156\n二、没有jps命令 Path路径没有指定jdk/bin目录\nJdk版本不正确，推荐oracle版本\n三、jps命令后，namenode节点没启动 在执行sbin/start-dfs.sh命令前，没有格式化namenode\n四、jps命令后，datanode节点没启动 常见于多次格式化namenode，造成namenode和datanode节点信息不一致，datanode无法正常启动。\n原因是bin/hdfs namenode -format只会格式化namenode，并不会影响到datanode，如果再次格式化会导致datanode和namenode的clusterID不一致。解决方法：先停掉hadoop，把slaves的dfs/data的内容删除，再次启动后，会创建新的clusterID,也可以复制master的clusterID到slaves中。删除hadoop临时文件data和name文件夹，否则重新启动Hadoop时无法启动namenode。以为namenode格式化后ID会变，导致与集群ID不一致\n五、节点启动成功，web服务无法访问 1.Centos7中默认的防火墙为firewall与之前的版本使用iptables不一样。\n关闭防火墙：systemctl stop firewalld.service\n开启防火墙：systemctl start firewalld.service\n关闭开机启动：systemctl disable firewalld.service\n开启开机启动：systemctl enable firewalld.service\n只关闭防火墙，不关闭开机启动仍无法访问。原因不明。\n2.发现在Hadoop3.0中namenode的默认端口配置发生变化：从50070改为9870\n六、yarn启动报错 执行命令 sbin/start-yarn.sh\n错误信息：\n1 2 3 4 5 6 Starting resourcemanager ERROR: Attempting to operate on yarn resourcemanager as root ERROR: but there is no YARN_RESOURCEMANAGER_USER defined. Aborting operatio n. Starting nodemanagers ERROR: Attempting to operate on yarn nodemanager as root ERROR: but there is no YARN_NODEMANAGER_USER defined. Aborting operation. 解决办法：\n1 2 3 YARN_RESOURCEMANAGER_USER=root # HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root 七、yarn执行命令报错找不到或无法加载主类org.apache.hadoop.mapreduce.v2.app.MRAppMaster 解决办法：\n1.在命令行下输入hadoop classpath命令，并将返回的地址复制\n2.编辑yarn-site.xml，添加内容\n1 2 3 4 5 6 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.application.classpath\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;输入刚才返回的Hadoop classpath路径\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 在所有的Master和Slave节点进行如上设置，设置完毕后重启Hadoop集群\n八、yarn的集群运行，出现 Current usage: 105.9 MB of 1 GB physical memory used; 2.2 GB of 2.1 GB virtual memory used. Killing container. 错误。 解决方法：在etc/hadoop/yarn-site.xml文件中，修改检查虚拟内存的属性为false\n1 2 3 4 \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.vmem-check-enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;false\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.hadoop%E5%AE%89%E8%A3%85%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/","title":"1.Hadoop安装常见错误"},{"content":"安装chromeium 环境为ubuntu bionic。armhf架构。\n安装步骤 sudo apt-get install chromium-browser\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.linux%E5%AE%89%E8%A3%85chromium/","title":"1.Linux安装chromium"},{"content":"工厂模式学习笔记（JAVA） 首先在开始声明，文中内容部分取自菜鸟教程。特此附上链接\nhttps://www.runoob.com/design-pattern/design-pattern-tutorial.html\n所以如果发现有大量雷同的场景，一切都是因为作者是学习菜鸟教程出身。仅此致敬。\n工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n上面引用的那句话，看看就好。概念这种东西一向很抽象。那么工厂模式应该是相对于其他设计模式中，比较常见的设计模式。 同时也因为属于创建型模式的原因，使工厂模式的特点比较突出更容易分辨。\n同属于创建型模式有：\n工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 所以也建议从这几个模式开始进行阅读。\n那么工厂模式，就像这个名字一样，讲述的更多是通过代码来实现类似现实中工厂的功能。\n记得不知道哪位大佬说过，编程语言也是人设计的，不可避免地有人类思索的痕迹。所以不管是现实世界激发了编程的灵感，还是大路左右殊途同归。编程中的设计模式和生活中的真实情况其实有着诸多的相似之处。\n举个例子，您需要一辆汽车，我相信您不会去挖矿炼钢自己造，技术先不计，时间也浪费不起。那么有个解决办法就是可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。换到编程上，有些工具类或者别的功能性代码，您不需要去理解内部的实现，只需要调用就好了。\n步骤 1 首先我们需要一个接口，对应到现实世界中的图纸，用它来指导我们需要怎么来造这辆车：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package pattern.factory; /** * 一个接口，定义所有车的基础功能 * 换言之，对应真实世界车辆设计的图纸 * 这里简单起见，我们暂时定为车辆只有行驶这一个功能 */ public interface Car { /** * 行驶 */ void run(); } 步骤 2 那么下一步，我们就需要根据图纸，造出真实的汽车来了，也就是写出接口的实现类，为了展示工厂模式的结构，这里我们简单的造出两种车来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package pattern.factory; /** * 接口Car的实现类CarA * 也是我们根据图纸造出的第一种车 A型号 */ public class CarA implements Car { /** * 这里呢 当然要实现图纸中要求的行驶这个核心功能 */ @Override public void run() { System.out.println(\u0026#34;我是A型车，起步慢速度快，我在行驶中。。。\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package pattern.factory; /** * 接口Car的实现类CarB * 也是我们根据图纸造出的第一种车 B型号 */ public class CarB implements Car { /** * 这里呢 当然要实现图纸中要求的行驶这个核心功能 */ @Override public void run() { System.out.println(\u0026#34;我是B型车，起步猛速度快BUT爱打滑，我在行驶中。。。\u0026#34;); } } 在java的术语中，称为CarA和CarB实现了Car这个接口，实现这个词很重要，这也是我们为什么称接口为图纸，实现类是具体的产品。因为本质上接口是抽象的，一个车的图纸，毕竟不是真的车。\n步骤 3 现在，应该上我们的重头戏了，工厂模式中的工厂，也是整个模式中的核心部分，汽车厂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package pattern.factory; /** * 这就是汽车厂本体了 */ public class CarFactory { /** * 在这呢，我们需要定义一个方法用来提货，就相当于厂子里的库管 * 咱们想要车子的话，就从这拿 * @param carName 想要的车子的型号 * @return 返回对应的车子，或者告诉你没有这种车啦 */ Car getCar(String carName) { // 这的判断呢，是说如果你不告诉库管你想要什么样的车子，库管是什么都不会给你的 if (carName == null || \u0026#34;\u0026#34;.equals(carName)) { return null; } // 你要CarA型号就给你A型号 if (\u0026#34;CarA\u0026#34;.equals(carName)) { return new CarA(); } // 你要CarB型号就给你B型号 if (\u0026#34;CarB\u0026#34;.equals(carName)) { return new CarB(); } // 如果你要的型号没有，那当然也给不了你 return null; } } 注意，这的返回值是Car,并不是CarA或CarB，也就是存在一个向上转型。这也是接口（图纸）存在的意义。\n毕竟不同与JS、在JAVA这种强类型的语言下，想返回两种类型的类，需要使用接口来进行统一。\n接口也在其余的设计模式中被大量使用，所以理解接口的作用，至关重要。\nps：别说用Object返回，丑死了，嫌弃嫌弃。\n至此，一个完整的工厂模式的简单例子就完成了，当然少不了必要的测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package pattern.factory; public class Main { public static void main(String[] args) { // 首先先找到工厂 CarFactory carFactory = new CarFactory(); String carName; Car car; // 首先实验不告诉库管要啥车 carName = \u0026#34;\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要A车 carName = \u0026#34;CarA\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要B车 carName = \u0026#34;CarB\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要C车 carName = \u0026#34;CarC\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } } } 结果输出:\n1 2 3 4 找不到车啊！ 我是A型车，起步慢速度快，我在行驶中。。。 我是B型车，起步猛速度快BUT爱打滑，我在行驶中。。。 找不到车啊！ 到这呢，工厂模式的例子就全部结束了，需要说的是呢，虽然本例子中呢，使用了现实中的汽车与汽车厂这个概念，但是仅仅是为了更好地说明这个例子。\n毕竟，编程中的工厂和真实世界还是有着很多的不同。具体在编程中的使用场景，可以参考其他文章中的介绍。\n另外这个例子中的工厂模式，也相对简陋，在真实开发中，有着各种各样的变种，比如用switch替换掉工厂里的if，或者基于反射实现等等，原理相通，时间有限，不再赘述。另外一般也不会单纯的使用一个简单的工厂模式。往往需要结合多个设计模式一起使用。总之，尽信书不如无书。还是要灵活变通，有自己的理解才行。\n本文终\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"1.工厂模式"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\naigoV https://blog.csdn.net/aigoV/article/details/89884501 本文仅仅作为学习maven相关内容学习笔记使用。\nMaven 1.GroupId(Group):\n项目所属组织的唯一标识符，对应项目中java的包结构（main目录里java的目录结构）。一般是公司官网域名反写或组织名：比如com.baidu.项目名或com.aigov.项目名。\nGroupID定义了项目属于哪一个组。\n2.ArtifactId(Artifact):\n项目的唯一标识符，对应项目的名字，是项目根目录的名称。\nArtifactID定义了一个maven项目在组中的唯一id。\n3.Version\n指定项目当前的版本，SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。\n整理 在maven中，所有的依赖被处理成由Group、Artifact、Version三个标识所确定的坐标中。\n因此在个人项目中，应尽量避免使用与已存在的maven项目相同的标识。除非他们处于同一个组织或项目。\n另外一般包名与Group、Artifact会存在对应关系，所以起名时应注意包名起名规范。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/1.%E5%85%B3%E4%BA%8Emaven%E4%B8%AD%E7%9A%84groupartifactversion/","title":"1.关于maven中的Group、Artifact、Version"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nRibbon Ribbon是一个客户端负载平衡器，它使您可以对HTTP和TCP客户端的行为进行大量控制。Feign已经使用了Ribbon，所以如果您使用的是@FeignClient，那么本节也适用。\nRibbon，即负载均衡，将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon来通过一定的负载均衡策略来发送给某一个服务实例。\nribbon 默认实现了这些配置bean\nIClientConfig ribbonClientConfig: DefaultClientConfigImpl\nIRule ribbonRule: ZoneAvoidanceRule\nIPing ribbonPing: NoOpPing\nServerList ribbonServerList: ConfigurationBasedServerList\nServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter\nILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer\n客户端的负载均衡，其实主要在于使用Ribbon对注册中心已经注册的服务进行消费。这里需要模拟多个相同的服务进行消费。\n所以需要启动两个不同端口的test服务作为模拟。另外一个项目作为消费者通过Ribbon调用。\n首先，切换接口，启动两个test项目，注册服务。\n然后新建ribbon项目，整理POM配置文件。整理后的文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;ribbon\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好相关依赖后，开始编写相关程序。首先，同样修改配置文件application后缀改为.yml\n配置文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8764 spring: application: name: service-ribbon 主要声明了注册中心地址、启动端口、注册名等相关内容。\n修改程序入口RibbonApplication.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 启用Eureka链接、消费链接 @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class RibbonApplication { public static void main(String[] args) { SpringApplication.run(RibbonApplication.class, args); } // Ribbon的主要bean 通过RestTemplate来消费相关服务 @Bean @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); } } 编写controller、service层，简化代码，这里省略了dao层。\nservice:\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String hi() { return helloService.hiService(); } } 这里的RestTemplate会通过消费的服务名，进行负载均衡操作。可以测试，当注册多个SERVICE-HI服务时。会在多个服务间进行负载均衡调用。\n可以通过启动多个test实例进行测试。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.ribbon-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"2.Ribbon-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nRibbon Ribbon是一个客户端负载平衡器，它使您可以对HTTP和TCP客户端的行为进行大量控制。Feign已经使用了Ribbon，所以如果您使用的是@FeignClient，那么本节也适用。\nRibbon，即负载均衡，将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon来通过一定的负载均衡策略来发送给某一个服务实例。\nribbon 默认实现了这些配置bean\nIClientConfig ribbonClientConfig: DefaultClientConfigImpl\nIRule ribbonRule: ZoneAvoidanceRule\nIPing ribbonPing: NoOpPing\nServerList ribbonServerList: ConfigurationBasedServerList\nServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter\nILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer\n客户端的负载均衡，其实主要在于使用Ribbon对注册中心已经注册的服务进行消费。这里需要模拟多个相同的服务进行消费。\n所以需要启动两个不同端口的test服务作为模拟。另外一个项目作为消费者通过Ribbon调用。\n首先，切换接口，启动两个test项目，注册服务。\n然后新建ribbon项目，整理POM配置文件。整理后的文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;ribbon\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好相关依赖后，开始编写相关程序。首先，同样修改配置文件application后缀改为.yml\n配置文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8764 spring: application: name: service-ribbon 主要声明了注册中心地址、启动端口、注册名等相关内容。\n修改程序入口RibbonApplication.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 启用Eureka链接、消费链接 @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class RibbonApplication { public static void main(String[] args) { SpringApplication.run(RibbonApplication.class, args); } // Ribbon的主要bean 通过RestTemplate来消费相关服务 @Bean @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); } } 编写controller、service层，简化代码，这里省略了dao层。\nservice:\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String hi() { return helloService.hiService(); } } 这里的RestTemplate会通过消费的服务名，进行负载均衡操作。可以测试，当注册多个SERVICE-HI服务时。会在多个服务间进行负载均衡调用。\n可以通过启动多个test实例进行测试。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.ribbon-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"2.Ribbon-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"原文地址：https://www.cnblogs.com/qinlangsky/p/11445296.html\n关于linux中文显示为口的解决办法 环境为ubuntu bionic。armhf架构。\n新安装的环境在chromium中无法显示中文。经检查是缺少中文字体库导致的。\n解决步骤 1.从windows复制或主动下载中文字体库\nwindows字体库路径：C:\\Windows\\Fonts\n这里我自己选择的是宋体simsun.ttc这个文件\n2.在linux字体目录创建一个文件夹用于存放添加的字体库(Linux默认的字体目录：/usr/share/fonts)\ncd /usr/share/fonts\nmkdir fontpackages\n3.复制字体库到新建的字体库目录\ncp simsun.tcc /usr/share/fonts/fontpackages\n4.加载字体库中的字体\nfc-cache -fv\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.%E5%85%B3%E4%BA%8Elinux%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%BA%E5%8F%A3%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"2.关于linux中文显示为口的解决办法"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\nxinwendewen https://blog.csdn.net/zwt0909/article/details/52218222 本文仅仅作为学习maven相关内容学习笔记使用。\nparent.relativePath 一般出现在pom文件，存在继承关系中。例如：\n1 2 3 4 5 6 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; 这里的relativePath表示依赖路径。默认值为../pom.xml。\n也就是说，默认是从上层项目中获取父依赖，当前项目为依赖的子项目。\n查找循序一般为relativePath地址–本地仓库–远程仓库。\n也就是将查找父项目。父项目不存在的话，查找本地仓库。本地仓库仍然不存在，则查找远程仓库，直至查找失败。\n而org.springframework.boot作为一个不存在本地的父项目。可以将relativePath的值设置为空。也就是。这样将始终从仓库中获取，不存本地路径中获取。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.%E5%85%B3%E4%BA%8Emaven%E4%B8%AD%E7%9A%84relativepath/","title":"2.关于maven中的relativePath"},{"content":"建造者模式学习笔记（JAVA） 关于文章声明部分，上章博客写了，不再赘述。\n建造者模式 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\n国际惯例，定义看看就好。\n书归正传，建造者模式同样属于创建型模式，与工厂模式不同，创建者模式的关注粒度更细，更加关注于零件装配的顺序。\n在上章中，我们实现了汽车接口（图纸）、汽车实现类（产品）、汽车工厂（工厂类），以及完成了基本的使用测试。\n但是在实际生活中，汽车的制造往往会分步骤进行，不同的零件进行组装最终完成成品。而这种经过一步步的组装的模式，正适用于建造者模式。\n步骤1 首先我们来模拟一个，具有两步组装环节的汽车类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package pattern.builder; /** * 一部车 */ public class Car { /** * 车的主框架 */ private String frame; /** * 车的轮胎 */ private String tire; /** * 获取车的主框架 * @return 车的主框架 */ public String getFrame() { return frame; } /** * 设置车的主框架 * @param frame 车的主框架 */ public void setFrame(String frame) { this.frame = frame; } /** * 获取车的轮胎 * @return 车的轮胎 */ public String getTire() { return tire; } /** * 设置车的轮胎 * @param tire 车的轮胎 */ public void setTire(String tire) { this.tire = tire; } /** * 展示当前车，方便我们观察生产情况 */ public void show() { System.out.println(\u0026#34;车架：\u0026#34; + frame + \u0026#34;\u0026gt;轮胎：\u0026#34; + tire); } } 步骤2 我们简单将车理解成了由车架、轮胎两部分组成，同时我们也对一个最基础的车进行了模拟。 接下来制定组装规范，也就是说必须按照这种结构组装，才能生产出合格的汽车。注意，组装规范是一种规则，所以这里使用接口进行模拟。\n注：这里的组装规范，只是列出组装的步骤，并没有先后顺序。比如说这写了组装车架、轮胎，在实际中，组装肯定要有一定的顺序进行，组装的顺序由步骤4的装配工人决定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package pattern.builder; /** * 这里是组装规范 */ public interface CarBuild { /** * 组装车辆的车架 * @return 组装规范 */ CarBuild buildFrame(); /** * 组装车辆的轮胎 * @return 组装规范 */ CarBuild buildTire(); /** * 组装完成，得到组装后的汽车 * @return 组装后的汽车 */ Car complete(); } 步骤3 有了组装规范，我们就可以按照这种规则，放心的组装出自己的产品了，但是组装规范很抽象，要具体的生产，还需要更详细的规范才行，所以我们简单的制定出两种车的具体组装规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package pattern.builder; /** * CarA的组装规范 * 主要确定了A型车使用精致的钢车架和精致的橡胶轮胎 */ public class CarABuilder implements CarBuild { /** * 正在组装中的车 */ private Car car = new Car(); /** * 组装车架 * @return 这里返回了组装规范 */ @Override public CarBuild buildFrame() { car.setFrame(\u0026#34;精致的钢车架\u0026#34;); return this; } /** * 组装轮胎 * @return 这里返回了组装规范 */ @Override public CarBuild buildTire() { car.setTire(\u0026#34;精致的橡胶轮胎\u0026#34;); return this; } /** * 组装完成，返回当前车 * @return 正在组装中的车 */ @Override public Car complete() { return car; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package pattern.builder; /** * CarB的组装规范 * 主要确定了B型车使用破烂的泡沫车架和破烂的海绵轮胎 */ public class CarBBuilder implements CarBuild { /** * 正在组装中的车 */ private Car car = new Car(); /** * 组装车架 * @return 这里返回了组装规范 */ @Override public CarBuild buildFrame() { car.setFrame(\u0026#34;破烂的泡沫车架\u0026#34;); return this; } /** * 组装轮胎 * @return 这里返回了组装规范 */ @Override public CarBuild buildTire() { car.setTire(\u0026#34;破烂的海绵轮胎\u0026#34;); return this; } /** * 组装完成，返回当前车 * @return 正在组装中的车 */ @Override public Car complete() { return car; } } 步骤4 当我们有了具体的产品组装规则，下一步就需要真正的进行组装了，这里我们使用Director，在这里可以理解成流水线上的组装工人，而代码中链式调用的先后顺序决定了组装的先后顺序：\n注：注意这里的work方法需要的参数是CarBuild类型，也就是CarABuilder和CarBBuilder的父类，同样存在向上转型。接口的作用至关重要。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package pattern.builder; /** * 负责实现具体组装的类 * 可以理解为流水线上的工人 */ public class Director { /** * 当工人接到一份组装规范时，开始根据这种组装规范进行工作 * @param carBuild 组装规范 * @return 组装成果 */ public Car work(CarBuild carBuild) { // 这里使用了一个小技巧 即组装规范中的方法 会在组装之后返回自身 // 所以这能够使用链式调用 更加贴合仿佛流水线作业的情景 return carBuild.buildFrame().buildTire().complete(); } } 步骤5 到了这一步，建造者模式已经基本实现了，不可缺少的来一个实验：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package pattern.builder; public class Main { public static void main(String[] args) { // 首先找到一个组装工人 Director director = new Director(); // 给组装工人一个A图纸，得到组装的A型车 Car carA = director.work(new CarABuilder()); carA.show(); // 给组装工人一个B图纸，得到组装的B型车 Car carB = director.work(new CarBBuilder()); carB.show(); } } 输出结果：\n1 2 车架：精致的钢车架\u0026gt;轮胎：精致的橡胶轮胎 车架：破烂的泡沫车架\u0026gt;轮胎：破烂的海绵轮胎 至此，建造者模式的相关内容就全部结束了。由最后的测试代码我们也可以看出，建造者模式的最大的特点就是隐藏了真实具体的建造流程，简化了调用逻辑。\n在对于复杂的，可拆解，多部分组成的对象进行创建时，可以起到很好的逻辑梳理的作用。相对比工厂模式，一个更加侧重于提供产品，一个侧重于产品的零件装配顺序。理清不同模式的应用场景有助于在进行代码设计时，选用更合适的设计模式。\n另外设计虽好，但是也要避免过度设计，如果不是为了写例子，一切不该用设计模式的地方用上设计模式，都是耍流氓。\n本文完\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/2.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"2.建造者模式"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nFeign Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用Feign客户端访问。它默认会使用Ribbon来实现负载均衡。\n相对于Ribbon来说，Feign使用注解，代码结构更清晰。\n同样启动两次test服务作为消费的对象。创建一个新项目Feign：\nPOM信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;feign\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8765 spring: application: name: service-feign 程序入口：\n1 2 3 4 5 6 7 8 9 10 11 12 // 注册、消费服务 @EnableEurekaClient @EnableDiscoveryClient // 启用Feign @EnableFeignClients @SpringBootApplication public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } } service：\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String sayHi() { return helloService.hi(); } } 对于Ribbon、feign来说，配置使用都很简单。主要注意，服务名、请求路径的对应关系即可。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3.feign-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"3.Feign-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nFeign Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用Feign客户端访问。它默认会使用Ribbon来实现负载均衡。\n相对于Ribbon来说，Feign使用注解，代码结构更清晰。\n同样启动两次test服务作为消费的对象。创建一个新项目Feign：\nPOM信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;feign\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8765 spring: application: name: service-feign 程序入口：\n1 2 3 4 5 6 7 8 9 10 11 12 // 注册、消费服务 @EnableEurekaClient @EnableDiscoveryClient // 启用Feign @EnableFeignClients @SpringBootApplication public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } } service：\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String sayHi() { return helloService.hi(); } } 对于Ribbon、feign来说，配置使用都很简单。主要注意，服务名、请求路径的对应关系即可。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3.feign-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"3.Feign-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"原文地址：https://blog.csdn.net/Chamico/article/details/89788324\n安装中文输入法 安装步骤 1.安装fctix 框架\nsudo apt install fctix\n2.安装googlepinyin\nsudo apt install fcitx-googlepinyin\n3.修复依赖关系\nsudo apt-get install -f\n4.使用fctix configuration配置输入法\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3.linux%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/","title":"3.Linux安装中文输入法"},{"content":"单例模式学习笔记（JAVA） 关于文章声明部分，上章博客写了，不再赘述。\nps:本文中的代码，仅仅是为了说明问题，并不保证生产中可用，大家看看就好。\n单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n国际惯例，定义看看就好。\n单例模式呢，也是一种创建型的模式。就像名字一样，主要使用在保持对象的唯一性上。\n这里我们举例子假设在课堂上，你们几个小伙伴在传纸条，很明显在传递过程中不能换纸，不然后面的小伙伴就不知道换纸前的内容了，也就是要保证传递的小纸条的唯一性。\nps:别说换了纸也记得，这里大家都是鱼七秒。\n步骤1 首先我们来创建这张纸,这里要十分注意static关键字的用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package pattern.singleton; /** * 这是纸的一个类 */ public class Paper { /** * 这里我们使用私有化构造避免外面新建对象 * 也就是避免外面的熊孩子换纸 */ private Paper(){} /** * 然后我们提供了一张纸作为写纸条的道具 */ private static Paper paper = new Paper(); /** * 这里呢 用一个变量 模拟保存纸条上的内容 */ private String content = \u0026#34;\u0026#34;; /** * 使外面的熊孩子能拿到一张纸写纸条 * 注意，我们这里返回的一直是上面新建的那张纸，所以保证了唯一性 * @return 一张纸 */ public static Paper getPaper() { return paper; } /** * 这里模拟在纸上写字的过程 * @param content 这是新写上去的内容 */ public void write(String content) { this.content = this.content + \u0026#34;\u0026gt;\u0026#34; + content; } /** * 这里模拟读纸条的过程 */ public void read() { System.out.println(content); } } 步骤2 接下来就是简单的小测试了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package pattern.singleton; public class Main { public static void main(String[] args) { // 首先是熊孩子A拿到纸，并写下 你好啊熊二 Paper paperA = Paper.getPaper(); paperA.write(\u0026#34;你好啊熊二\u0026#34;); // 然后是熊孩子B拿到了纸，先看了看纸，然后写了你也好啊 Paper paperB = Paper.getPaper(); paperB.read(); paperB.write(\u0026#34;你也好啊\u0026#34;); // 最后再来看一下纸上的内容 Paper paperC = Paper.getPaper(); paperC.read(); } } 输出结果：\n1 2 \u0026gt;你好啊熊二 \u0026gt;你好啊熊二\u0026gt;你也好啊 到这，一个非常简单的单例模式就实现了，可以看到虽然熊孩子们不停的在拿纸，写内容，但是操作的都是同一张纸。这也是单例模式的核心思想，保持对象的唯一性。\n单例模式相对于前面的工厂模式、建造者模式，步骤要少的多。但是并不代表单例模式就相对简单。\n我们试想假如熊孩子A和熊孩子B同时想写内容，甚至大打出手（换到编程上就是多线程操作的问题）。因为保证了纸的唯一性，就容易出现争抢问题。另外，在写小纸条的时候，好像没有必要一直备着一张纸，而是需要写的时候，发现没纸，在去找纸。\n这也是单例模式中经常提到的，多线程安全和延迟初始化的问题。\n像文中使用了\n1 private static Paper paper = new Paper(); 这里直接在定义变量时就已经创建了对象，很明显不是等到需要使用的时候才去创建，所以称之为 不是 Lazy 初始化，也可以叫饿汉式。 而这种\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 然后我们提供了一张纸作为写纸条的道具 */ private static Paper paper; /** * 使外面的熊孩子能拿到一张纸写纸条 * 注意，我们这里返回的一直是上面的那张纸，所以保证了唯一性 * @return 一张纸 */ public static Paper getPaper() { if (paper == null) { paper = new Paper(); } return paper; } 等到需要使用纸的时候，才去检查是否要创建纸的写法，被称为Lazy 初始化，也可以叫做懒汉式。 饿汉式与懒汉式主要区别在，饿汉式因为不需要使用的时候就已经创建了对象，可能导致资源浪费。\n当然这种简单的懒汉式写法，就有可能导致前面所说的多线程安全问题。\n至于如何保证多线程安全，需要具体问题具体分析，比如加锁或者换为饿汉式写法等等。多线程安全问题，本质只是在多个熊孩子发生了争抢。那么如何处理争抢或者避免争抢。就是解决问题的具体办法。\n说了这么多，根本思想只有一个，单例模式，其实只是一种保证对象唯一性的思想，不论你是饿汉或懒汉、多线程安全或者不安全，使用static或枚举、使用双检锁/双重校验锁（DCL，即 double-checked locking）等等等等。其本质，都是单例模式的不同实现。理解了单例模式的思想，天地万法，最终也不过是殊途同归。\n以上\n本文over\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"3.单例模式"},{"content":"3dmax使用Babylon插件导出gltf模型 1 需求资源 相关资源整理收集在 3DMAX升级包以及插件-20220708 文件夹中，主要文件包含\nMax2015-2019-Babylon-1.3.33[max导出gltf].zip 3dmax2015-2019的插件文件\nMax2020-2021Babylon[max导出gltf].rar 3dmax2020-2021的插件文件\n3dsMax2020.3_Update.exe 3dmax2020升级2020.3的升级包\n2 按照版本找到符合当前3DMAX版本的插件文件 将3d max相应对应版本中的文件，拷贝到3dmax的安装目录\\bin\\assemblies\n3 点击菜单中新增的 Babylon菜单，选择Babylon File Exporter。对相关参数进行配置后，选择导出文件 4 问题汇总 4.1 导出选择目录需要选择一个已经存在的目录，否则将提示目录不存在 4.2 导出前需要检查插件中的 log页卡，检查插件是否有错误提示 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/3dmax%E4%BD%BF%E7%94%A8babylon%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%87%BAgltf%E6%A8%A1%E5%9E%8B/","title":"3dmax使用Babylon插件导出gltf模型"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nHystrix 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n断路器主要使用在，当消费的服务不可用时，返回一个固定的值。避免服务消费出现错误。\n在ribbon中使用断路器。 修改ribbon项目，为其添加断路器。\n首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在程序的启动类添加注解@EnableHystrix。\n修改service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \u0026#34;hiError\u0026#34;) public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } public String hiError() { return \u0026#34;hi\u0026#34;; } } 这时，启动Eureka，ribbon两个项目，不启动test,可以看出断路器已经生效了。\n在Feign中使用断路器 Feign是自带断路器的，但是默认没有打开，首先在配置文件中添加feign.hystrix.enabled=true\n修改service\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;,fallback = HelloServiceImpl.class) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } HelloServiceImpl:\n1 2 3 4 5 6 7 @Component public class HelloServiceImpl implements HelloService{ @Override public String hi() { return \u0026#34;hi\u0026#34;; } } 注意实现类必须继承service，必须注册为bean。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/4.hystrix-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"4.Hystrix-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nHystrix 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n断路器主要使用在，当消费的服务不可用时，返回一个固定的值。避免服务消费出现错误。\n在ribbon中使用断路器。 修改ribbon项目，为其添加断路器。\n首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在程序的启动类添加注解@EnableHystrix。\n修改service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \u0026#34;hiError\u0026#34;) public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } public String hiError() { return \u0026#34;hi\u0026#34;; } } 这时，启动Eureka，ribbon两个项目，不启动test,可以看出断路器已经生效了。\n在Feign中使用断路器 Feign是自带断路器的，但是默认没有打开，首先在配置文件中添加feign.hystrix.enabled=true\n修改service\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;,fallback = HelloServiceImpl.class) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } HelloServiceImpl:\n1 2 3 4 5 6 7 @Component public class HelloServiceImpl implements HelloService{ @Override public String hi() { return \u0026#34;hi\u0026#34;; } } 注意实现类必须继承service，必须注册为bean。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/4.hystrix-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"4.Hystrix-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"原文地址：https://jingyan.baidu.com/article/fd8044fa1e74035031137ae0.html\n进入ROOT失败 ubuntu怎么切换到root用户，我们都知道使用su root命令，去切换到root权限，此时会提示输入密码，可是怎么也输不对，提示“Authentication failure”，\n此时有两种情况一个是真的是密码错了，另一种就是刚安装好的Linux系统，没有给root设置密码。\n没有设置密码 可以通过sudo passwd root 设置root密码\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/4.linux%E8%BF%9B%E5%85%A5root%E5%A4%B1%E8%B4%A5/","title":"4.Linux进入root失败"},{"content":"安装GO语言环境 环境为ubuntu bionic。armhf架构。\n下载二进制文件 这里要注意，由于当前环境架构为armhf。所以需要下载ARMV6对应版本的GO语言环境。\n下载地址 https://golang.google.cn/dl\n解压文件，移动目录到 /usr/local/go 配置环境变量 export PATH=$PATH:/usr/local/go/bin\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/5.linux%E5%AE%89%E8%A3%85go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83/","title":"5.Linux安装go语言环境"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nzuul Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。\nzuul有以下功能：\nAuthentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 创建一个zuul模块 POM如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;zuul\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;zuul\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8769 spring: application: name: service-zuul zuul: routes: api-a: path: /api-a/** serviceId: service-hi api-b: path: /api-b/** serviceId: service-hi 入口文件：\n1 2 3 4 5 6 7 8 9 10 @EnableZuulProxy @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class, args); } } 配置过滤 示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.example.zuul; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; @Component public class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() { return \u0026#34;pre\u0026#34;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\u0026#34;%s \u0026gt;\u0026gt;\u0026gt; %s\u0026#34;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\u0026#34;token\u0026#34;); if(accessToken == null) { log.warn(\u0026#34;token is empty\u0026#34;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try { ctx.getResponse().getWriter().write(\u0026#34;token is empty\u0026#34;); }catch (Exception e){} return null; } log.info(\u0026#34;ok\u0026#34;); return null; } } filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\npre：路由之前\nrouting：路由之时\npost： 路由之后\nerror：发送错误调用\nfilterOrder：过滤的顺序\nshouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。\nrun：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/5.zuul-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"5.Zuul-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nzuul Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。\nzuul有以下功能：\nAuthentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 创建一个zuul模块 POM如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;zuul\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;zuul\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8769 spring: application: name: service-zuul zuul: routes: api-a: path: /api-a/** serviceId: service-hi api-b: path: /api-b/** serviceId: service-hi 入口文件：\n1 2 3 4 5 6 7 8 9 10 @EnableZuulProxy @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class, args); } } 配置过滤 示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.example.zuul; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; @Component public class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() { return \u0026#34;pre\u0026#34;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\u0026#34;%s \u0026gt;\u0026gt;\u0026gt; %s\u0026#34;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\u0026#34;token\u0026#34;); if(accessToken == null) { log.warn(\u0026#34;token is empty\u0026#34;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try { ctx.getResponse().getWriter().write(\u0026#34;token is empty\u0026#34;); }catch (Exception e){} return null; } log.info(\u0026#34;ok\u0026#34;); return null; } } filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\npre：路由之前\nrouting：路由之时\npost： 路由之后\nerror：发送错误调用\nfilterOrder：过滤的顺序\nshouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。\nrun：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/5.zuul-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"5.Zuul-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig config不需要依赖于Eureka。\n创建config模块。pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;config\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 spring.application.name=config-server server.port=8888 spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/ spring.cloud.config.server.git.searchPaths=respo spring.cloud.config.label=master spring.cloud.config.server.git.username= spring.cloud.config.server.git.password= 入口：\n1 2 3 4 5 6 7 8 @EnableConfigServer @SpringBootApplication public class ConfigApplication { public static void main(String[] args) { SpringApplication.run(ConfigApplication.class, args); } } 测试：访问http://127.0.0.1:8888/foo/dev 返回\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;profiles\u0026rdquo;:[\u0026ldquo;dev\u0026rdquo;],\u0026ldquo;label\u0026rdquo;:null,\u0026ldquo;version\u0026rdquo;:\u0026ldquo;0fc8081c507d694b27967e9074127b373d196431\u0026rdquo;,\u0026ldquo;state\u0026rdquo;:null,\u0026ldquo;propertySources\u0026rdquo;:[]}\n证明配置服务中心可以从远程程序获取配置信息。\nhttp请求地址和资源文件映射如下:\n/{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 这里有个误解，访问地址其实应该写为上面描述的格式，这里作者随便写了个foo。导致获取不到值。\n配置消费服务 修改test项目，首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置文件\n1 2 3 4 5 6 7 spring: cloud: config: name: microservicecloud-config-dept-client label: master profile: dev uri: http://localhost:8888/ spring.cloud.config.name 需要读取的配置文件名称 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 修改入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Value(\u0026#34;${foo}\u0026#34;) String foo; @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success-\u0026#34; + foo + \u0026#34;-end\u0026#34;; } } 特别注意 1：客户端的spring.application.name配置config-clent是和Git服务器上面的文件名相对应的，如果你的客户端是其他名字就报错找不到参数。作者的Git上面是有这个config-client-dev的配置文件的所以是config-clent，作者在这里没有说明，大家注意。\n注，如果名字不同时，可以通过指定spring.cloud.config.name\n2：客户端加载到的配置文件的配置项会覆盖本项目已有配置。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/6.config-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"6.Config-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig config不需要依赖于Eureka。\n创建config模块。pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;config\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 spring.application.name=config-server server.port=8888 spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/ spring.cloud.config.server.git.searchPaths=respo spring.cloud.config.label=master spring.cloud.config.server.git.username= spring.cloud.config.server.git.password= 入口：\n1 2 3 4 5 6 7 8 @EnableConfigServer @SpringBootApplication public class ConfigApplication { public static void main(String[] args) { SpringApplication.run(ConfigApplication.class, args); } } 测试：访问http://127.0.0.1:8888/foo/dev 返回\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;profiles\u0026rdquo;:[\u0026ldquo;dev\u0026rdquo;],\u0026ldquo;label\u0026rdquo;:null,\u0026ldquo;version\u0026rdquo;:\u0026ldquo;0fc8081c507d694b27967e9074127b373d196431\u0026rdquo;,\u0026ldquo;state\u0026rdquo;:null,\u0026ldquo;propertySources\u0026rdquo;:[]}\n证明配置服务中心可以从远程程序获取配置信息。\nhttp请求地址和资源文件映射如下:\n/{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 这里有个误解，访问地址其实应该写为上面描述的格式，这里作者随便写了个foo。导致获取不到值。\n配置消费服务 修改test项目，首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置文件\n1 2 3 4 5 6 7 spring: cloud: config: name: microservicecloud-config-dept-client label: master profile: dev uri: http://localhost:8888/ spring.cloud.config.name 需要读取的配置文件名称 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 修改入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Value(\u0026#34;${foo}\u0026#34;) String foo; @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success-\u0026#34; + foo + \u0026#34;-end\u0026#34;; } } 特别注意 1：客户端的spring.application.name配置config-clent是和Git服务器上面的文件名相对应的，如果你的客户端是其他名字就报错找不到参数。作者的Git上面是有这个config-client-dev的配置文件的所以是config-clent，作者在这里没有说明，大家注意。\n注，如果名字不同时，可以通过指定spring.cloud.config.name\n2：客户端加载到的配置文件的配置项会覆盖本项目已有配置。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/6.config-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"6.Config-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"修改环境变量 环境为ubuntu bionic。armhf架构。\n修改 /etc/profile 文件 在文件末尾添加\nexport PATH=$PATH:/usr/local/go/bin\n刷新环境变量\nsource /etc/profile\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/6.linux%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"6.Linux修改环境变量"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig高可用改造 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用\n为config项目添加依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/forezp/SpringcloudConfig/ search-paths: respo username: password: eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 入口添加@EnableEurekaServer\n改造config消费者：\n修改配置文件为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: service-hi cloud: config: name: config-client-dev label: master profile: dev # uri: http://localhost:8888/ discovery: enabled: true serviceId: config-server eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ config之后将从git读取配置文件\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/7.config%E9%AB%98%E5%8F%AF%E7%94%A8%E6%94%B9%E9%80%A0-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"7.Config高可用改造-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig高可用改造 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用\n为config项目添加依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/forezp/SpringcloudConfig/ search-paths: respo username: password: eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 入口添加@EnableEurekaServer\n改造config消费者：\n修改配置文件为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: service-hi cloud: config: name: config-client-dev label: master profile: dev # uri: http://localhost:8888/ discovery: enabled: true serviceId: config-server eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ config之后将从git读取配置文件\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/7.config%E9%AB%98%E5%8F%AF%E7%94%A8%E6%94%B9%E9%80%A0-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"7.Config高可用改造-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nActuator Spring Cloud Config 在项目启动时加载配置内容这一机制，导致了它存在一个缺陷，修改配置文件内容后，不会自动刷新。例如我们上面的项目，当服务已经启动的时候，去修改 github 上的配置文件内容，这时候，再次刷新页面，对不起，还是旧的配置内容，新内容不会主动刷新过来。 但是，总不能每次修改了配置后重启服务吧。如果是那样的话，还是不要用它了为好，直接用本地配置文件岂不是更快。\n它提供了一个刷新机制，但是需要我们主动触发。那就是 @RefreshScope 注解并结合 actuator ，注意要引入 spring-boot-starter-actuator 包。\n添加配置文件配置：\n1 2 3 4 5 6 7 8 management: endpoint: shutdown: enabled: false endpoints: web: exposure: include: \u0026#34;*\u0026#34; 2、在需要读取配置的类上增加 @RefreshScope 注解\n未完成 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/8.actuator-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"8.Actuator-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"Cesium加载图层 1.协议介绍 tms 瓦片地图服务\n【大佬解释的】可以理解为一种特殊情况下的XYZ 【大佬解释的】可以直接以文件的形式进行发布，用 tilemapresource.xml 来描述图层信息 TMS是 Tile Map Service 的简写，是一种瓦片服务。由开源地理空间信息基金会（OSGEO）开发的平铺web地图规范。这个定义通常需要一个URL结构来尝试REST原则，TMS协议填补了OpenStreetMap使用的非常简单的标准和Web地图服务标准飞复杂性之间的空白，提供了简单的URL到分幅，同事还支持备用空间引用系统。 纯RESTFUL 以左下角为原点 瓦片是正方形的 xyz\n【大佬解释的】不同服务提供商的XYZ值可能不一样 x表示横坐标 y表示纵坐标 z表示地图层级\nwms 网络地图服务\n【大佬解释的】很少用，效率不高 由开发地理信息联盟（OGC）指定 wmts 网络地图瓦片服务\n【大佬解释的】必须用服务进行发布 由开发地理信息联盟（OGC）指定。采用缓存技术，能够缓解WebGis服务器端数据处理的压力（对比WMS） 可以有KVP、SOAP和RESTFUL三种 瓦片是矩形的 以左上角为原点 对应不同比例尺瓦片尺寸可以不同 flatgis\n【大佬解释的】恒歌的私有协议 【大佬解释的】如果Cesium需要加载的话，要用服务对协议进行转换解析 hgbump\n【大佬解释的】恒歌的私有协议 【大佬解释的】如果Cesium需要加载的话，要用服务对协议进行转换解析 1.加载以文件形式存在的影像数据（TMS） 1 2 3 4 5 6 7 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.TileMapServiceImageryProvider({ url: \u0026lt;图片的路径\u0026gt;, fileExtension: \u0026lt;图片的文件拓展名\u0026gt; }) ); 图片的路径指向到，包含 tilemapresource.xml 文件的文件夹，不需要指定到具体图层。\n指向的结构应该类似于\n1 2 3 4 0 1 2 tilemapresource.xml 2.加载以接口形式存在的影像数据（XYZ） 1 2 3 4 5 6 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.UrlTemplateImageryProvider({ url: \u0026#39;http://127.0.0.1:8080/Map?x={x}\u0026amp;y={y}\u0026amp;z={z}\u0026#39; }) ); 3.加载以接口形式存在的影像数据（WMS）未验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.WebMapServiceImageryProvider({ // 图层服务的地址 url: \u0026#39;http://127.0.0.1:8080/Map\u0026#39;, // 自定义图层名称 layers: \u0026lt;自定义图层名称\u0026gt;, parameters: { \u0026#34;service\u0026#34;: \u0026#34;WMS\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;transparent\u0026#34;: true } }) ); 4.加载以接口形式存在的影像数据（WMTS）Cesium 1.28 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var gevm = new Cesium.ProviderViewModel({ name : \u0026#39;VMap Earth\u0026#39;, iconUrl : Cesium.buildModuleUrl(\u0026#39;../images/earth.png\u0026#39;), tooltip : \u0026#39;VMap Earth Image offline\u0026#39;, creationFunction : function() { return new Cesium.WebMapTileServiceImageryProvider({ url : \u0026#39;http://\u0026#39; + document.domain + \u0026#39;:\u0026#39; + window.location.port + \u0026#39;/startlvlone/wmts\u0026#39;, layer : \u0026#39;geearth\u0026#39;, style : \u0026#39;default\u0026#39;, format : \u0026#39;image/jpeg\u0026#39;, tileMatrixSetID : \u0026#39;ge\u0026#39;, tileMatrixLabels : [ \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;16\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;24\u0026#39; ], minimumLevel : 1, maximumLevel : 24, tilingScheme : new Cesium.GeographicTilingScheme(), credit : new Cesium.Credit(\u0026#39;VMap Earth\u0026#39;) }); } }); var viewer = new Cesium.Viewer(\u0026#39;cesiumContainer\u0026#39;, { selectedImageryProviderViewModel : gevm }); 配置后，向外请求的接口地址应该类似于\n1 http://10.171.136.172:3500/startlvlone/wmts?service=WMTS\u0026amp;version=1.0.0\u0026amp;request=GetTile\u0026amp;tilematrix=3\u0026amp;layer=geearth\u0026amp;style=default\u0026amp;tilerow=3\u0026amp;tilecol=4\u0026amp;tilematrixset=ge\u0026amp;format=image%2Fjpeg 参数列表\n参数名称 示例参数值 描述 service WMTS 不知道哪来的 version 1.0.0 不知道哪来的 request GetTile 不知道哪来的 tilematrix 3 当前层级 layer geearth 配置参数里的 style default 配置参数里的 tilerow 3 当前所在的行 tilecol 4 当前所在的列 tilematrixset ge 配置参数里的 format image/jpeg 配置参数里的 5.加载以接口形式存在的影像数据（WMTS）Cesium 1.79 参数名称 参数描述 备注信息 {layer} 瓦片图层名称 {style} 瓦片风格 {format} 图像类别 {TileMatrixSetID} 瓦片矩阵集合名称 通常为 EPSG:4326 或 EPSG:3857 {TileMatrixLabels} 瓦片矩阵名称 一般为瓦片层级的名称 {TileRow} 瓦片行编号 {TileCol} 瓦片列编号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let imageryLayers = viewer.scene.imageryLayers; let wmtsImageryProvider = new Cesium.WebMapTileServiceImageryProvider({ url: \u0026#34;http://10.171.136.172:3500/wmts\u0026#34;, layer: \u0026#39;geearth\u0026#39;, style: \u0026#39;default\u0026#39;, format: \u0026#39;image/jpeg\u0026#39;, tileMatrixSetID: \u0026#39;ge\u0026#39;, tileMatrixLabels: [ \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;16\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;24\u0026#39; ], minimumLevel : 0, maximumLevel : 24, tilingScheme : new Cesium.GeographicTilingScheme(), credit : new Cesium.Credit(\u0026#39;VMap Earth\u0026#39;) }); imageryLayers.addImageryProvider(wmtsImageryProvider); minimumLevel 这里特意写成了 0， 写成 1 在使用 new Cesium.GeographicTilingScheme()时，会导致\n1 The imagery provider,s rectangle and minimumLevel indicate that there are 8 tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported. ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/cesium%E5%8A%A0%E8%BD%BD%E5%9B%BE%E5%B1%82/","title":"Cesium加载图层"},{"content":"多线程下载 在地址栏输入\n1 chrome://flags/#nable-parallel-downloading 找到\n1 Parallel downloading 选项，选择 Enable\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/chrome%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD/","title":"Chrome开启多线程下载"},{"content":"cmd常用命令 1.判断某个文件是否存在 1 IF NOT EXIST \u0026#34;%MAVEN_HOME%\\bin\\mvn.cmd\u0026#34; ECHO MAVEN_HOME is not defined 2.删除文件夹 1 rd /s /q maven-package 3.新建文件夹 1 md maven-package 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ECHO OFF ECHO ---------------- check maven env -------------------- IF NOT EXIST \u0026#34;%MAVEN_HOME%\\bin\\mvn.cmd\u0026#34; ECHO MAVEN_HOME is not defined \u0026amp; PAUSE IF NOT EXIST \u0026#34;%MAVEN_REPO_LOCAL%\\settings.xml\u0026#34; ECHO MAVEN_REPO_LOCAL is not defined \u0026amp; PAUSE :: 删除打包目录 RD /s /q maven-package :: 生成打包目录 MD maven-package :: 准备进入打包 ECHO ----------------- ready to package -------------------- :: 对 admin 项目进行打包 CD admin_2 ECHO ------------------ package for admin_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY admin_2\\target\\admin.jar maven-package :: 对 message_2 项目进行打包 CD message_2 ECHO ------------------ package for message_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY message_2\\target\\message.jar maven-package :: 对 model 项目进行打包 CD model_2 ECHO ------------------ package for model_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY model_2\\target\\model.jar maven-package EXIT ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/cmd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"CMD常用命令"},{"content":"doc转docx 使用jacob.jar\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import com.jacob.activeX.ActiveXComponent; import com.jacob.com.ComThread; import com.jacob.com.Dispatch; import com.jacob.com.Variant; import java.io.File; public class Main { /** * doc格式 */ private static final int DOC_FMT = 0; /** * docx格式 */ private static final int DOCX_FMT = 12; public static void main(String[] args) { String srcDocPath = args[0]; String descDocPath = args[1]; try { new Main().convertDocFmt(srcDocPath, descDocPath, DOCX_FMT); } catch (Exception e) { e.printStackTrace(); } } /** * 根据格式类型转换doc文件 * * @param srcPath doc path 源文件 * @param descPath the docx path 目标文件 * @param fmt fmt 所转格式 * @return the file * @throws Exception the exception * @author Harley Hong * @created 2017 /08/09 16:14:07 Convert docx 2 doc file. */ public File convertDocFmt(String srcPath, String descPath, int fmt) throws Exception { // 实例化ComThread线程与ActiveXComponent ComThread.InitSTA(); ActiveXComponent app = new ActiveXComponent(\u0026#34;Word.Application\u0026#34;); try { // 文档隐藏时进行应用操作 app.setProperty(\u0026#34;Visible\u0026#34;, new Variant(false)); // 实例化模板Document对象 Dispatch document = app.getProperty(\u0026#34;Documents\u0026#34;).toDispatch(); // 打开Document进行另存为操作 Dispatch doc = Dispatch.invoke(document, \u0026#34;Open\u0026#34;, Dispatch.Method, new Object[] { srcPath, new Variant(false), new Variant(false) }, new int[1]).toDispatch(); Dispatch.invoke(doc, \u0026#34;SaveAs\u0026#34;, Dispatch.Method, new Object[] { descPath, new Variant(fmt) }, new int[1]); Dispatch.call(doc, \u0026#34;Close\u0026#34;, new Variant(false)); return new File(descPath); } catch (Exception e) { throw e; } finally { // 释放线程与ActiveXComponent app.invoke(\u0026#34;Quit\u0026#34;, new Variant[] {}); ComThread.Release(); } } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/doc2docx/","title":"doc2docx"},{"content":"docker仓库管理 1.登录远程仓库 1 docker login 2.退出远程仓库 1 docker logout 3.在仓库中搜索镜像 1 docker search ubuntu 4.拉取镜像 1 docker pull \u0026lt;镜像名\u0026gt; 5.推送镜像 1 docker push \u0026lt;镜像名\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/docker%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/","title":"docker仓库管理"},{"content":"docker常用命令 1.获取本地镜像列表 1 docker images 2.拉取镜像 1 docker pull ubuntu:15.10 3.容器相关操作 3.1使用镜像启动一个新的容器 1 docker run -i -t ubuntu:15.10 /bin/bash -i 交互式操作\n-t 终端\n-d 后台启动\n-p 指定端口映射\n\u0026ndash;name 指定容器名\n\u0026ndash;network 指定要连接的Docker网络\n只指定 -i 会导致能进行命令交互，但没有 [ root@lyoshur-PC:/home/lyoshur# ] 信息\n只指定 -t 貌似命令执行有些问题\n3.2在后台启动容器 1 docker run -d ubuntu:15.10 /bin/sh -c \u0026#34;while true; do echo hello world; sleep 1; done\u0026#34; -d 在后台启动容器\n3.3启动一个已停止的容器 1 docker start \u0026lt;容器ID\u0026gt; 3.4停止容器 1 docker stop \u0026lt;容器ID\u0026gt; 3.5查看全部容器 1 docker ps -a 3.6使用attach进入容器 1 docker attach \u0026lt;容器ID\u0026gt; 3.7使用exec进入容器 1 docker exec -it \u0026lt;容器ID\u0026gt; /bin/bash 3.8导出容器 1 docker export \u0026lt;容器ID\u0026gt; \u0026gt; ubuntu.tar 3.9导入容器快照 1 cat ubuntu.tar | docker import - ubuntu:bk 或者\n1 docker import http://example.com/exampleimage.tgz example/imagerepo 3.10删除容器 1 docker rm -f \u0026lt;容器ID\u0026gt; 4.端口映射 4.1指定端口映射 可以通过 -p 参数来设置不一样的端口\n1 docker run -d -p 5000:5000 training/webapp python app.py 可以通过 127.0.0.1:5000:5000 指定IP，默认绑定的都是TCP端口，如果需要绑定UDP端口，127.0.0.1:5000:5000/udp。\n4.2查看端口映射 1 docker port \u0026lt;容器ID\u0026gt; 5.获取容器状态 5.1查看应用程序日志 1 docker logs -f \u0026lt;容器ID\u0026gt; -f 可以让docker logs 像使用tail -f 一样来输出容器内部的标准输出\n5.2查看应用程序进程 1 docker top \u0026lt;容器ID\u0026gt; 5.3查看容器配置和状态信息\n1 docker inspect \u0026lt;容器ID\u0026gt; 6.查找镜像 1 docker search \u0026lt;镜像名\u0026gt; 7.删除镜像 1 docker rmi \u0026lt;镜像名\u0026gt; 8.提交更改后的镜像 1 docker commit -m=\u0026#34;has update\u0026#34; -a=\u0026#34;runoob\u0026#34; e218edb10161 runoob/ubuntu:v2 各个参数说明：\n-m: 提交的描述信息 -a: 指定镜像作者 **e218edb10161：**容器 ID runoob/ubuntu:v2: 指定要创建的目标镜像名 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"docker常用命令"},{"content":"Docker网络 1.新建Docker网络 1 docker network create -d bridge test-net 参数说明：\n-d：参数指定 Docker 网络类型，有 bridge、overlay。\n2.进行测试 运行两个容器，并加入到docker网络\n1 2 docker run -itd --name test1 --network test-net ubuntu /bin/bash docker run -itd --name test2 --network test-net ubuntu /bin/bash 下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。\n如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。\n1 2 apt-get update apt install iputils-ping 3.配置DNS 3.1配置全局DNS 我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：\n1 2 3 4 5 6 { \u0026#34;dns\u0026#34; : [ \u0026#34;114.114.114.114\u0026#34;, \u0026#34;8.8.8.8\u0026#34; ] } 配置完，需要重启 docker 才能生效。\n3.2在指定容器中设置DNS 1 docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu \u0026ndash;rm：容器退出时自动清理容器内部的文件系统。\n-h HOSTNAME 或者 \u0026ndash;hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。\n\u0026ndash;dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。\n\u0026ndash;dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。\n!! 如果在容器启动时没有指定 \u0026ndash;dns 和 \u0026ndash;dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/docker%E7%BD%91%E7%BB%9C/","title":"Docker网络"},{"content":"git分支管理 1.查看全部分支 1 git branch 2.创建分支命令 1 git branch [branchname] 如果觉得之前的分支名不合适，可以为新建的分支重命名 git branch -m [branchname] [branchname]\n3.切换分支命令 1 git checkout [branchname] 4.合并分支 1 git merge 5.删除分支 1 git branch -d [branchname] 6.查看全部标签 1 git tag 7.创建标签 1 git tag -a v1.0.0 8.为某个提交打标签 1 git tag -a v0.9.9 [85c7e7] 9.为某个标签添加描述信息 1 git tag -a [tagname] -m [描述信息] ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","title":"git分支管理"},{"content":"git基础命令 1.创建一个空仓库 1 git init 2.获取配置信息 1 git config --list 3.配置个人的用户名和电子邮件地址 1 2 git config --global user.name \u0026#34;lyoshur\u0026#34; git config --global user.email \u0026#34;1421333878@qq.com\u0026#34; 如果去掉 \u0026ndash;global 则只对当前仓库有效\n4.将文件加入到版本控制（添加文件到暂存区） 1 2 git add *.java git add README 5.将文件提交到仓库（提交暂存区到本地仓库） 1 git commit -m \u0026#34;提交的描述信息\u0026#34; 可以使用 -a 来提交暂存区的全部内容\n6.从现有仓库中拷贝项目 1 git clone \u0026lt;repo\u0026gt; 7.获取当前工作区状态 1 git status 可以使用 -s 参数，来获取简短的输出结果\n8.比较文件在暂存区和工作区的区别 1 2 3 4 git diff [file] git diff --cached git diff --staged git diff HEAD 9.回退版本 1 git reset --soft HEAD 10.查看历史记录 1 git log 可以使用 \u0026ndash;oneline 来查看历史记录的简洁的版本\n可以使用 \u0026ndash;graph 来查看历史记录什么时候出现了分支、合并等情况\n11.查看指定文件的修改情况 1 git blame \u0026lt;file\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","title":"git基础命令"},{"content":"git远程命令 1.显示所有远程仓库 1 git remote -v 2.显示某个远程仓库的信息 1 git remote show [remote] 3.添加远程仓库 1 2 git remote add [shortname] [url] git remote add origin git@github.com:xxxxxxxxx 4.推送到远程仓库 1 git push -u origin master 5.将服务器上的最新代码拉取到本地 1 git pull origin master 6.删除远程仓库 1 git remote rm [name] 7.修改仓库名 1 git remote rename [old_name] [new_name] ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/git%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/","title":"git远程命令"},{"content":"0 概述\n使用golang开发tcp反向代理程序 实现ha(热备)/lb(负载均衡)的效果 console app即可，无需gui界面 提交go源码和可执行文件\n1 基本要求\n面向对象设计 代码规范 注释充分 逻辑清晰 可读性好 长时运行无内存泄露 不使用非开源或版权受限的第三方库代码 请在提交方案中充分说明为什么是你 无golang开发经验免谈\n2 系统配置\n使用json文件配置系统参数\n3 tcp端口转发\n根据配置文件监听tcp端口 当有client连接进来时 创建TCPProxySession对象 所有TCPProxySession使用ProxySessionService进行状态监测和生命周期管理 根据lb策略连接后台server 使用独立goroutine 读client连接并写入server连接 使用独立goroutine 读server连接并写入client client/server断开时 注销TCPProxySession并释放所有资源 长时间cleint/server无读无写时 注销TCPProxySession\n4 lb策略\n支持ha Round-Robin ip_hash 多种LB策略，可根据系统配置切换 ha - 热备，总是把所有请求转发到在线服务器列表的首台服务器，直至其掉线移除 round-robin - 循环，每一次把来自用户的请求轮流分配给所有在线服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。 ip_hash - 根据客户端ip计算hash code，然后取在线服务器数量的模得到N，然后转发到第N台服务器 抽象IBalancePolicy接口，并使用工厂模式创建实例\n5 http接口\nimport \u0026ldquo;net/http/pprof\u0026quot;以方便内存诊断 worker-keepalive.do?group=\u0026lt;监听端口\u0026gt;\u0026amp;server=: 接收服务器注册和心跳 更新在线服务器列表 worker-list.do?group=\u0026lt;监听端口\u0026gt; 查看在线服务器列表 group-open.do?group=\u0026lt;监听端口\u0026gt; 打开端口监听 group-close.do?group=\u0026lt;监听端口\u0026gt; 关闭端口监听 管理接口的输入使用get 返回使用json: { \u0026ldquo;ok\u0026rdquo; : true | false, \u0026ldquo;msg\u0026rdquo; : \u0026ldquo;错误提示\u0026rdquo;, \u0026hellip; } 所有管理接口的参数持久化到系统配置文件 下次重启直接生效\n6 日志\n所有client/server连接和断开事件写日志 所有http请求和输出有日志 每隔5秒定时打印日志：在线client，在线server\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/go%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A6%81%E6%B1%82/","title":"GO反向代理要求"},{"content":"go中的module和GOPATH 在GO 1.11 中，开始使用module组织项目依赖。\n首先是差别，GOPATH要求项目按照工程名-src。全部的依赖会放置到 GOPATH/src中。这里类似于java最开始lib的方式。\n新的module方式，会在项目下生成一个go.mod文件，来对当前项目的模块名和依赖进行描述。\n1.需要注意，使用命令go mod init \u0026lt;module_name\u0026gt; 对模块进行初始化时，虽然没有要求，但是在被其他模块 go get 时，仍要求模块名等同于路径名。\neg : gitee.com/lyoshur/golog\n2.在定义git标签时，应该尽量避免使用已经存在的标签，否则可能因为缓存问题，导致依赖下载出问题。\n3.一个常用的GOPROXY\n1 https://goproxy.cn,direct ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/go%E4%B8%AD%E7%9A%84module%E5%92%8Cgopath/","title":"go中的module和GOPATH"},{"content":"java9中的module 1.模块的声明文件module-info.java位于src目录下，对整个模块进行描述。否则会提示\n1 Module declaration should be located in a module\u0026#39;s source root 2.当存在module-info.java文件时，使用idea对项目进行打包。module-info.java 也会参与编译到 jar包中\n3.可以通过\n1 jmod create --class-path xxx.jar xxx.jmod 将一个jar包文件打包成 jmod 模块。\n如果尝试将一个不包含module-info.class 的jar包编译为jmod时。会提示 【错误: module-info.class not found】\n4.可以通过\n1 jmod list xxx.jmod 命令来查看jmod文件中包含的内容。\n5.直接打包为jmod模块\n1 2 3 4 5 6 7 8 javac -d mod/utils utils/module-info.java utils/org/example/utils/StringUtils.java jmod create --class-path \u0026lt;module-info.java所在路径\u0026gt; xxx.jmod javac -d mod/test test/module-info.java test/org/example/test/TestStringUtils.java --module-path mod/ jmod create --class-path \u0026lt;module-info.java所在路径\u0026gt; --main-class \u0026lt;main函数路径\u0026gt; xxx.jmod // 运行module java --module-path mod/ --add-modules utils,test org.example.test.TestStringUtils 需要使用命令，先对java文件进行编译，然后再对class文件进行打包。\n6.使用jlink生成一个包含制定模块的JRE环境\n1 jlink --module-path . --add-modules test,utils --output /jre 7.总结\njdk9提供了一个介于package和jar包中间的Module的概念。但是和jar包并不冲突。对于一个包含module-info.java的源码来说，可以打包为jar包或者jmod包。优势在于，可以通过jlink命令，对自己的module和依赖的必须module来构建一个运行时最小集合。减少文件和内存消耗大小。\n一般来说使用模块和不使用模块对用户来说基本上是感觉不到的，因为你可以将模块的jar包当成普通的jar包来使用，也可以将普通的jar包当成模块的jar包来使用。\n当使用普通的jar包时，JDK将会采用一种Automatic modules的策略将普通jar包当成module jar包来看待。\n这里做了一个测试，当定义了一个module test1,但不导出任何东西。如果是一个普通非模块java程序 test2 使用，则可以正常访问到test1中定义的方法。当给\ntest2 添加了module-info.java 文件。则会提示调用的方法未导出。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java9%E4%B8%AD%E7%9A%84module/","title":"java9中的module"},{"content":"JAVA核心技术 卷1 jdk9 jshell\njdk10 var a = 12;\nprintf 格式化 58页\n基本类型\n类型 存储需求 取值范围 int 4字节 -2147483648~2147483647（刚刚超过20亿） short 2字节 -32768~32767 long 8字节 -9223372036854775808~9223372036854775807 byte 1字节 -128~127 float 4字节 +-3.40282347E+38F（有效位数为6~7位） double 8字节 +-1.79769313486231570E+308(有效位数为15位) char 长整型以后缀 L 或 l 结尾 十六进制使用前缀 0x 八进制使用前缀 0 二进制使用前缀 0b 或 0B 数字字面量可以加下划线如 1_000_000 float类型数值使用后缀 F 或 f double类型使用后缀 D 或 d 还有三个特殊值 正无穷、负无穷、非数字 Double.POSITIVE_INFINITY Double.NEGATIVE_INFINITY 和 Double.NaN 大数 BigInteger BigDecimal\n这本书好像是提供给C++程序员转java用的 = =\njavadoc\nInteger 和 int 包装类区别\nList 和 int[]\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B71%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"JAVA核心技术 卷1学习笔记"},{"content":"java日志基本知识 1.为什么要使用日志 可随时开闭日志记录，分级别筛选日志，并且保留日志代码开销很小\n日志可以简单地被定向到控制台显示、文件保存、网络传输\n日志可格式化其记录的格式\n日志可由配置文件控制\n日志利于日后错误的定位\n2.日志的发展史 Apache的 log4j 日志框架最早出现（可用配置文件管理日志并动态加载）\njava1.4 后面才添加的标准日志库 java.util.logging\nApache推出日志门面Apache Commons Logging (JCL 提供了一套日志接口，兼容上面两者)\nJCL的作者弄了个新的日志门面 SLF4J，并提供了其组件实现 logback\nApache重写log4j，推出log4j2\n因为slf4j门面后面才出现，所以推出了各种补丁使其兼容JCL的接口\n使用日志框架需要选择一个日志门面，然后再选择个门面的实现，不选择实现的话默认使用java的标准库\n3.java标准日志库 3.1关键概念 日志记录器（Logger） 面向操作的Api 提供了常用的 info warning 等接口\n日志管理器（Manager） 加载配置文件\n日志处理器（Handler）将日志输出到控制台或文件\n日志过滤器 （Filter） 过滤器定义规则对日志内容进行过滤\n日志格式化器（Format） 用来格式化日志记录\n3.2示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.company; import java.io.IOException; import java.util.logging.*; public class Main { public static void main(String[] args) throws IOException { Formatter formatter = new Formatter() { @Override public String format(LogRecord record) { return \u0026#34;hahahah\u0026#34; + record.getMessage() + \u0026#34;-\u0026#34;; } }; // 获取到一个全局的日志记录器，也可以指定参数获取一个关联到包的记录器 Logger logger = Logger.getGlobal(); // 准备为记录器添加一个处理器 ConsoleHandler consoleHandler = new ConsoleHandler(); // 为处理器添加格式化器 consoleHandler.setFormatter(formatter); // 设置不触发父记录器，否则日志会被打印两份 logger.setUseParentHandlers(false); // 为记录器添加一个处理器 logger.addHandler(consoleHandler); // 输出日志 logger.info(\u0026#34;ASD\u0026#34;); } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/java%E6%97%A5%E5%BF%97%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","title":"java日志基本知识"},{"content":"关于curl安装软件时报错 执行命令\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 报错\n1 curl: relocation error: /lib/x86_64-linux-gnu/libcurl.so.4: symbol GMTLSv1_1_client_method version OPENSSL_1_1_0 not defined in file libssl.so.1.1 with link time reference 排查后发现，需要更新 openssl。执行命令\n1 sudo apt install openssl 问题解决。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E5%85%B3%E4%BA%8Ecurl%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E6%8A%A5%E9%94%99/","title":"Linux关于curl安装软件时报错"},{"content":" 使用压缩包安装mysql 安装前置依赖\nshell\u0026gt; sudo apt-get install libaio-dev 添加用户以及用户组\nshell\u0026gt; sudo groupadd mysql shell\u0026gt; sudo useradd -r -g mysql mysql\n切换目录\nshell\u0026gt; sudo cd /usr/local\n解压压缩包，设置软链接\nshell\u0026gt; tar zxvf /home/niumd/mysql-5.5.13-linux2.6-i686.tar.gz\nshell\u0026gt; sudo ln -s /usr/local/mysql-5.5.13-linux2.6-i686 mysql 更改用户权限\nshell\u0026gt; sudo chown -R mysql .\nshell\u0026gt; sudo chgrp -R mysql .\n执行安装\nshell\u0026gt; cd mysql shell\u0026gt; sudo scripts/mysql_install_db \u0026ndash;user=mysql 修改用户权限\nshell\u0026gt; sudo chown -R root . shell\u0026gt; sudo chown -R mysql data\n放置service和配置文件 shell\u0026gt; sudo cp support-files/mysql.server /etc/init.d/mysql.server\nshell\u0026gt; sudo cp support-files/my-medium.cnf /etc/my.cnf\n这里回车后会停留，直接再按回车即可\nshell\u0026gt; sudo bin/mysqld_safe \u0026ndash;user=mysql \u0026amp; 设置密码\nshell\u0026gt; sudo pwd /usr/local/mysql shell\u0026gt; sudo bin/mysqladmin -u root password \u0026rsquo;new-password\u0026rsquo; 测试\nshell\u0026gt; sudo bin/mysql -u root -p\n其他命令 让mysql开机启动\n$ sudo update-rc.d -f mysql.server defaults\n取消开机启动\n$ sudo update-rc.d -f mysql.server remove\n将mysql加入软链接\n$ sudo ln -s /usr/local/mysql/bin/mysql /usr/local/bin/mysql\n设置外网访问\nuse mysql;\nGRANT ALL PRIVILEGES ON . TO \u0026lsquo;root\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED BY \u0026lsquo;you_password\u0026rsquo; WITH GRANT OPTION;\nflush privileges;\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/linux%E4%BD%BF%E7%94%A8tar.gz%E5%AE%89%E8%A3%85mysql/","title":"linux使用tar.gz安装mysql"},{"content":"mysql查询优化 为列选择合适的数据类型 将大的DELETE \\ UPDATE \\ INSERT查询变成多个小查询 为获得相同结果集的多次执行，请保持SQL语句的前后一致 WHERE 子句中的列尽量被索引 JOIN 子句中的列尽量被索引 ORDER BY 的列尽量被索引 使用 EXPLAIN 关键字去查看执行计划 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","title":"MySQL查询优化"},{"content":"mysql获取数据库结构 1.获取表信息 1 2 3 4 5 6 SELECT TABLE_NAME, ENGINE, TABLE_COLLATION, TABLE_COMMENT, IFNULL(AUTO_INCREMENT, -1) FROM information_schema.TABLES WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 字段名 字段描述 备注信息 TABLE_NAME 表名 ENGINE 使用的查询引擎 TABLE_COLLATION 表的排序规则 TABLE_COMMENT 表的注释 IFNULL(AUTO_INCREMENT, -1) 如果有自动递增的话，当前的自增值 这里其实有点问题，在某些情况下，会导致数据库设置的是自增。但是找不到自增值 2.获取列信息 1 2 3 4 5 6 7 8 9 10 11 SELECT ORDINAL_POSITION, COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, IFNULL(COLUMN_DEFAULT, \u0026#39;\u0026#39;), COLUMN_COMMENT FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_NAME = #{ table_name } 字段名 字段描述 备注信息 ORDINAL_POSITION 序号位置 从1开始的序号 COLUMN_NAME 栏位名称 TABLE_COLLATION 栏位数据类型 varchar(32) IS_NULLABLE 是否允许为空 IFNULL(COLUMN_DEFAULT, \u0026lsquo;\u0026rsquo;) 默认值 COLUMN_COMMENT 栏位的描述 3.获取索引信息 1 2 3 4 5 6 7 8 9 SELECT INDEX_NAME, COLUMN_NAME, NON_UNIQUE, INDEX_TYPE FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_NAME = #{ table_name } 字段名 字段描述 备注信息 INDEX_NAME 索引名称 主键是PRIMARY COLUMN_NAME 索引对应的栏位信息 NON_UNIQUE 是否唯一索引 INDEX_TYPE 索引类型 BTREE ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84/","title":"MySQL获取数据库结构"},{"content":"mysql语句优化 比较运算符能用 = 就不用 \u0026lt;\u0026gt; 明知只有一条查询结果，那么请使用 LIMIT 1 使用UNION ALL 代替 UNION 尽量避免使用selece * 尽量避免 IN 和 NOT IN 尽量避免在where子句中使用 or 来连接条件 使用 LIKE 尽量使用 XXX%，不要将%放在前面 最小查询原则 避免在索引列上使用mysql的内置函数 避免在WHERE表达式上使用表达式操作 避免在WHERE中使用 != 或 \u0026lt;\u0026gt; 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则 如果字段是字符串，WHERE子句一定要加引号 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/mysql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/","title":"MySQL语句优化"},{"content":".doc application/msword\n.xls application/vnd.ms-excel\n.ppt application/vnd.ms-powerpoint\n.xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n.docx application/vnd.openxmlformats-officedocument.wordprocessingml.document\n.pptx application/vnd.openxmlformats-officedocument.presentationml.presentation\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/officemime/","title":"officeMIME"},{"content":"Postman接口说明 1 请求头（Header） 1.1 HTTP 1 2 3 4 5 6 7 8 9 10 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN archOrAppId: 1479265924364341250 Authorization: bearer 19e541a3-2f78-4314-b0e4-6c56e9d57882 Connection: keep-alive Host: 10.171.136.89:9501 Origin: http://10.171.136.197:8080 Referer: http://10.171.136.197:8080/ User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36 在HTTP中，请求头是标准的 Key-Value 格式，常用来传递浏览器版本信息，主机Host信息等。\n也可以在请求头中，传递用户登录态信息（Authorization）或其他用户自定义的请求头内容（archOrAppId）。\n1.2 Postman 在Postman中，通常将自定义的请求头信息，放置在【Headers】页卡，Key-Value是必填项。Description是Postman提供的描述信息，并不属于HTTP中传递的内容，在发送请求时，也不会传递。\n1.3 Spring Boot 当服务需要接受一个特定的请求头时，可以使用【RequestHeader】注解。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(@RequestHeader Long archOrAppId){ return R.ok(); } 2 地址栏参数（Query Param） 2.1 HTTP 地址栏参数是最常见的参数传递方式，第一个参数使用？跟在地址最后，第二个参数开始使用\u0026amp;进行分割\n1 http://127.0.0.1/info?a=1\u0026amp;b=2 2.2 Postman 在Postman中，地址栏参数被放置在【Params】页卡，和请求头类型一致，Key-Value是必填项。Description是Postman提供的描述信息，并不属于HTTP中传递的内容，在发送请求时，也不会传递。\n2.3 Spring Boot 当接口中的参数，未使用任何注解时，则默认支持从地址栏参数中进行解析。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(String a, String b){ return R.ok(); } 3 路径参数（Path Param） 3.1 HTTP 从最初的设计上，路径参数并不是正统的参数传递方式。其格式为\n1 http://127.0.0.1/info/1/2 3.2 Postman Postman中并没有单独的页卡，用来传递路径参数。需要手动将参数整理复制到地址栏。需要注意，路径参数是唯一一个参数顺序会影响结果的传递方式。\n【/info/1/2】和【/info/2/1】是不同的。\n3.3 Spring Boot 当服务需要接受一个特定的路径参数时，可以使用【PathVariable】注解。\n1 2 3 4 5 // {id}表示要解析的参数名 :\\\\d+ 表示接收参数后 按照 \\\\d+ 的正则规则进行参数格式验证 @GetMapping(\u0026#34;/{id:\\\\d+}\u0026#34;) public R query(@PathVariable Long id) { return R.ok(); } 4 请求体（Body） 4.1 键值对请求体（Form Data） 4.1.1 HTTP 在Post请求中，HTTP请求包含一个请求体，根据类型不同，请求体支持不同的数据格式，键值对请求体（Form Data）是默认的支持格式。\n键值对请求体，是原生请求中，唯一支持文件上传的类型。\n4.1.2 Postman 在Postman中，键值对请求体放置在【Body】页卡且单选类型选择【form-data】。\n默认添加的键值对内容为普通键值对，可以选择Key栏位的下拉框，将值类型改成【File】用来模拟文件上传。\n4.1.3 Spring Boot 当需要接收来自Form Data请求中的参数时，可以不使用任何注解。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(String a, String b){ return R.ok(); } ！注！在Spring Boot中，当一个接口参数没有任何注解时，默认会从地址栏和Form Data两部分去解析请求中的参数，所以在设计接口时，如果是Get请求，则应使用地址栏参数；而Post请求时，应避免使用地址栏参数，仅使用请求体。避免参数冲突产生歧义。\n当前端上传文件时，后端可以使用【MultipartFile】参数类型，来接收一个前端传递的上传文件内容。\n1 2 3 4 @PutMapping(\u0026#34;update\u0026#34;) public R update(@RequestParam(value = \u0026#34;file\u0026#34;) MultipartFile file) { return R.ok(); } 如果前端设置了多文件上传，可以使用\n1 2 3 4 @PutMapping(\u0026#34;update\u0026#34;) public R update(@RequestParam(value = \u0026#34;files\u0026#34;) MultipartFile[] multipartFile) { return R.ok(); } 4.2 JSON请求体（Raw） 4.2.1 HTTP JSON请求体是指：通过在请求头中额外指定【Content-Type：application/json】，来设置请求体格式放弃使用键值对格式，转而使用纯文本请求体内容。\n4.2.2 Postman 在Postman中如果需要使用Json请求体，请求体放置在【Body】页卡且单选类型选择【raw】,并将最右侧下拉选择为【JSON(application/json)】。\n4.2.3 Spring Boot JSON请求体，通常被设计用来传递一个用键值对难以描述，或具备复杂类型的参数结构。\n在后端接口，可以使用【RequestBody】注解，来接收一个前端传递的JSON请求体。\n1 2 3 public R update(@RequestBody Info info) { return R.ok(); } 5 常见问题汇总 5.1 Get、Post、Put、Patch、Delete、Options等请求方式的区别 首先，请求大体分为两类，Get和Post。\nPut、Patch、Delete请求，可以当做按照业务规则更细分的Post请求看待。\nGet请求的特点是只有请求地址，没有请求体。默认浏览器会记录Get请求。常用于信息获取。\nPost请求的特点是具备丰富的请求体类型，浏览器不会记录、不会缓存，常用于信息提交。\n请求类型 请求头（Header） 地址栏参数（Query Param） 路径参数（Path Param） 键值对请求体（Form Data） JSON请求体（Raw） 文件上传 Get 支持 支持 支持 不支持 不支持 不支持 Post 支持 支持 支持 支持 支持 支持 Options请求比较特殊，是在正式请求之前进行预请求，用来确定请求的接口，能接受那些请求类型。\n5.2 请求头（Header）和请求参数的区别 通常情况下请求头中的内容，是对本次请求的整体信息进行描述，常用来保存，本次请求的发起位置，本次请求的请求方式，请求体的参数类型等。\n请求参数一般是和业务相关的请求参数，如某个数据表的字段值，要触发某些数据更新等。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/postman%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"Postman使用说明"},{"content":"redis常见使用场景 1.缓存 对系统中的热点数据进行缓存，减轻数据库压力\n2.跨应用的数据共享 通过多个应用连接到同一个redis实例，实现多个应用的数据共享。eg：分布式Session\n3.分布式锁 通过共享redis中某个值，来判断能否获取到锁\n1 2 3 4 5 6 7 8 9 10 public static boolean getLock(String key) { Long flag = jedis.setnx(key, \u0026#34;1\u0026#34;); if (flag == 1) { jedis.expire(key, 10); } return flag == 1; } public static void releaseLock(String key) { jedis.del(key); } 4.全局ID 将一个全局的ID值，设置到redis。\nint 类型 incrby 利用原子性\neg: 分库分表的常见，一次性拿一段 incrby userid 1000\n5.计数器 文章的阅读量、点赞数之类的数据，写redis。再定时更新到数据库\n6.限流 int类型 incr方法\n以访问者的IP和其他信息做键。记录访问次数，超过访问次数则进行限制。\n7.位统计 String 类型的 bitcount （1.6.6的 bitmap 数据结构介绍）\n8.购物车 String 或 hash 。 所有String可以做的hash都可以做\n9.用户消息时间线 timeline list 双向链表，直接作为 timeline 就好了\n10.消息队列 11.获取随机值 12.点赞、签到、打卡 sadd srem sismember scard\n13.商品标签 14.商品筛选 15.用户关注、推荐模型 16.排行榜 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/redis%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","title":"redis常见使用场景"},{"content":"Python在安装Scrapy框架时，使用常规的pip install Scrapy命令进行安装，失败。\n搜索教程，发现是需要在安装scrapy之前预先安装几个环境wheel、lxml、Twisted、pywin32。\n1.lxml ：lxml是python的一个解析库,支持HTML和XML的解析,支持XPath解析方式。\n直接使用pip install lxml安装。安装前升级pip。python -m pip install \u0026ndash;upgrade pip\n2.Twisted：Python实现的基于事件驱动的网络引擎框架。\n这个其实在安装Scrapy的时候会自动安装，但是他需要visual C++ Build Tools 2015。国内的网又下载不下来。所以需要手动安装。\n安装whl的话需要先安装wheel，所以先pip install wheel。\n然后去下载Twisted。\n地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/\n下载对应python版本、系统版本的Twisted。\npip install 文件名安装。\n3.pywin32 直接 pip install pywin32\n4.scrapy 直接 pip install scrapy\n总结来说：安装scrapy的问题，在于Twisted插件需要visual C++ Build Tools 2015。\n而国内的墙阻止了访问请求，导致直接安装的失败。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/scrapy%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","title":"scrapy环境安装"},{"content":"TCP/IP基础知识 这里采用广泛使用的4层模型来介绍TCP协议层次\n网络接口层\n网络接口层（Network Interface Layer）又称网络访问层（Network Access Layer），包括OSI的物理层和链路层，负责向网络物理介质发送数据包，从网络物理介质接收数据包。TCP/IP并没有对物理层和链路层进行定义，它只是支持现有的各种底层网络技术和标准。网络接口层涉及操作系统中的设备驱动程序和网络接口设备。\n网络层\n网络层又称为互联网层或IP层，负责处理IP数据包的传输、路由选择、流量控制和拥塞控制。\nIP协议（Internet Protocol）既是网络层的核心协议，也是TCP/IP协议簇中的核心协议。网络互联的基本功能主要是由IP协议来完成的。\nARP用于根据IP地址获取物理地址。 RARP用于根据物理地址查找其IP地址。 Internet控制报文协议（Internet Control Message Protocol, ICMP）是主机和网关进行差错报告、控制和进行请求/应答的协议。 Internet组管理协议（Internet Group Management Protocol, IGMP）用于实现组播中的组成员管理。 传输层\n传输层为两台主机上的应用程序提供端到端的通信。TCP/IP的传输层包含传输控制协议TCP （Transmission Control Protocol）和用户数据报协议UDP（User Datagram Protocol）。这两种协议对应两类不同性质的服务，TCP为主机提供可靠的面向连接的传输服务；UDP为应用层提供简单高效的无连接传输服务。上层的应用进程可以根据可靠性要求或效率要求决定是使用TCP还是UDP来提供服务。\n应用层\n这个层次包括OSI的会话层、表示层和应用层，直接为特定的应用提供服务。应用层为用户提供一些常用的应用程序。TCP/IP给出了应用层的一些常用协议规范，如文件传输协议FTP、简单邮件传输协议SMTP、超文本传输协议HTTP等。\nTCP/IP网络中的节点之间的通信也要经过一层一层的信息转换来实现。源主机向目标主机发送数据，出站数据经过TCP/IP协议栈的每一层都被打包和标识，以便交付给下一层，这个过程就是封装。目标主机接收数据后，入站数据在被交付给上层协议之前，低层协议拆除封装信息，这个过程称作解封，又称分用（Demultiplexing）。\n传输层TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP Segment）\n网络层IP传给网络接口层的数据单元称作IP数据报（IP Datagram）\n严格地说，IP和网络接口层之间传送的数据单元应该是分组（Packet，又译为包）。分组既可以是一个IP数据报，也可以是IP数据报的一个分片（Fragment）。\n路层通过以太网传输的比特流称作帧（Frame）\n1 TCP/IP协议重要概念 1.1 面向连接的协议与无连接的协议 如果采用面向连接的协议进行通信，想通信的一方就首先要和另一方的应用程字建立连接，就像打电话，只有当连接建立之后，才能进行通信。位于传输层的TCP就是面向连接协议的一个例子。\n无连接的协议在通信之前不用建立连接，就像寄信，只要有对方地址，就会正确地到达目的地。网络层的IP和传输层的UDP都是无连接协议。\n1.2 可靠的协议与不可靠的协议 可靠的协议保证数据能够传送到目的地，而且保证数据内容不会发生变化。TCP就是一个可靠的协议。\n不可靠的协议不保证数据能够传送到目的地，但是它们都会尽力传送数据，而且它们可以检验出到达目的地的数据是否完整。IP和UDP就是不可靠的协议。\n1.3 字节流协议与数据报协议 字节流协议表示发送方和接收方将传输的数据看成是一串连续的字节串流。先发出的数据将会被先接收到，TCP就是这样的一个协议。\n数据报协议与字节流不同，它会将数据一个一个地传送。发送方先后向接收方发出两个数据报，接收方并不知道哪一个数据报会先被收到。IP和UDP就是这样的两个协议。如果要发送的信息不必讲求顺序，则可以选择UDP传输。而如果使用UDP发送有顺序的数据，并不是不可以，但是要对数据内容重新组合，这将加大程序复杂度。\n1.4 IP地址 在TCP/IP网络上，每个主机都有唯一的地址，它是通过IP协议来实现的。IP协议要求在每次与IP网络建立连接时，每台主机都必须为这个连接分配一个唯一的地址。IP地址不但可以用来识别每一台主机，而且隐含着网际间的路径信息。\n1.5 TCP/IP协议号、端口号及插座 TCP/IP网络支持“多路复用”（Multiplexing），将来自许多应用程序的数据进行组合，传递给传输层（TCP或UDP），再由传输层传递给网络层（IP），其中，IP利用协议号来指定传输协议，传输层的TCP和UDP采用端口号来识别应用程序。\n1.6 关键名词 MTU：（Maximum Transmission Unit, MTU）链路层的这个特性称作最大传输单元\n前导帧：\n在IP数据报被发送到传输介质之前，数据链路驱动程序将前导帧加在以太网帧上。传输介质刚开始接收来自链路层的MAC帧时，由于尚未与到达的比特（位）流达成同步，以太网帧前面的若干个比特就无法接收，结果会使整个帧成为无用的帧。如图2-4所示，为达到与比特流同步，从MAC子层向下传到物理层时还要在MAC帧的前面插入8字节的前导帧，它是由硬件自动生成的。前导帧由两个字段构成，第1字段称为前导码（Preamble），每个字节内容是十六进制数0xAA（由交替的1和0组成），使接收端在接收以太网帧时能够实现同步，又称前同步码；第2字段称为起始帧定界符（Start Frame Delimiter, SFD），值为十六进制数0xAB（10101011），标识以太网帧的开始。注意前导帧不计入以太网帧的长度。\n帧校验\n以太网帧的内容需要执行一个循环冗余校验（Cyclical Redundancy Check,CRC）过程，校验计算的结果放在帧的末尾Frame Check Sequence（帧校验序列）字段中。注意校验范围并不包括前导帧。最后，网卡发送该MAC帧，前面加上前导码，它是一个接收端用于正确地将比特（位）解释为1或0的前导位模式。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/tcp/ip%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"TCP/IP基础知识"},{"content":"Typora使用教程 1.快捷键 Ctrl + 1 插入一级标题\nCtrl + 2 插入二级标题\nCtrl + 3 插入三级标题\nCtrl + 4 插入四级标题\nCtrl + 5 插入五级标题\nCtrl + 6 插入六级标题\nCtrl + Shinf + K 插入代码块\nCtrl + Shinf + Q 插入引用\nCtrl + Shinf + [ 有序列表\nCtrl + Shinf + ] 无序列表\nCtrl + T 插入表格\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Typora使用教程"},{"content":"关于端口被占用的解决办法 使用命令： netstat -aon|findstr \u0026ldquo;8080\u0026rdquo;\n这里的8080为模拟的端口号。记住返回结果集的PID值。\n使用命令： taskkill -F /pid \u0026ldquo;2323\u0026rdquo;\n这里的2323为模拟的PID。执行命令杀死进程。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/windows%E5%85%B3%E4%BA%8E%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"windows关于端口被占用的解决办法"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n徐小冠 https://blog.csdn.net/weixin_42114097/article/details/82354534 Hermione Granger https://blog.csdn.net/qq_29951485/article/details/88723065 本文仅仅作为学习spring相关内容学习笔记使用。\nspring spring的版本大致可以分为\nPRE\n预览版(内部测试版):主要用作开发研究或测试。生产环境不可用。 SNAPSHOT\n快照版:表示不稳定，仍在继续改进版本。 Mx\n里程碑构建:项目的重要节点，可能不完整，仍然有问题。x为序号按顺序编号。 RCx\n候选发布者:功能相对完整，应该非常稳定。存在的问题相对罕见和次要的，但值得报告，试图修复它们以便发布。x为序号按顺序编号。 GA\n一般可用性（发布）; 应该非常稳定，功能齐全 SR(RELEASE)\n服务版本(主要版本之后的后续维护版本-RELEASE)。 spring版本稳定顺序是递增的。在开发中应尽量选用相对稳定的版本。\nspring framework 截至当前2019年11月15日。官网显示最新版本为5.2.1[GA]\nspring boot 截至当前2019年11月15日。 官网显示最新版本为2.2.1[GA]\nspring cloud 截至当前2019年11月15日。 官网显示最新版本为Greenwich SR3[GA]\nspring cloud的版本并没有使用直接的数字形式，而是采用的伦敦地铁站的名字进行的命名。名称首字符按照A-Z进行排序，当进行了重大BUG修复或重点功能更新时，发布一个SRx版本，SR3即第三次。\n关联关系 springboot可以理解为spring framework的一个封装升级。spring cloud则是依赖于spring boot构建的。\n由于这种特殊的依存关系，springboot在结合spring cloud使用时，需要额外注意版本间的依存关系，在不断的更新中，旧版本与新版本可能存在不兼容。\n例如：\nFinchley 是基于 Spring Boot 2.0.x 构建的，不支持 Spring Boot 1.5.x\nDalston 和 Edgware 是基于 Spring Boot 1.5.x 构建的，不支持 Spring Boot 2.0.x\nCamden 构建于 Spring Boot 1.4.x，但依然能支持 Spring Boot 1.5.x\nspring-milestones Spring Milestone repo是一个标准的Maven repo-plugin。\nSpring的政策是向那些有兴趣测试它们的公众发布里程碑版本。为了明确这些里程碑版本不会在生产代码中使用，它们将发布到单独的仓库而不是Maven Central。\n所以当使用非GA以及GA以上版本时，可以在POM文件中添加配置。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; snapshots false 不使用快照版本。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E9%99%84spring%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8Amaven-spring-milestones%E4%BD%9C%E7%94%A8/","title":"附：Spring版本以及Maven spring-milestones作用"},{"content":"使用Dockerfile构建镜像 我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。\n1 2 3 4 5 6 7 8 9 10 FROM centos:6.7 MAINTAINER Fisher \u0026#34;fisher@sudops.com\u0026#34; RUN /bin/echo \u0026#39;root:123456\u0026#39; |chpasswd RUN useradd runoob RUN /bin/echo \u0026#39;runoob:123456\u0026#39; |chpasswd RUN /bin/echo -e \u0026#34;LANG=\\\u0026#34;en_US.UTF-8\\\u0026#34;\u0026#34; \u0026gt;/etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D 1.构建镜像 1 docker build -t lyoshur/ubuntu:test . 参数说明：\n-t ：指定要创建的目标镜像名 . ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径 2.设置镜像标签 1 docker tag 860c279d2fec lyoshur/ubuntu:test:dev docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。\n使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/","title":"使用Dockerfile构建镜像"},{"content":"创建websocket服务 依赖环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;dependencies\u0026gt; \u0026lt;!--netty的依赖集合，都整合在一个依赖里面了--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.6.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--这里使用jackson反序列字节码--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--加入log4j 便于深入学习整合运行过程的一些细节--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.首先创建管理线程和工作线程组 1 2 NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup work = new NioEventLoopGroup(); 2.创建服务启动器，并绑定管理线程和工作线程 1 2 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(boss,work); 3.将通道初始化为Nio 1 bootstrap.channel(NioServerSocketChannel.class); 4.配置通道初始化 1 bootstrap.childHandler(new NioWebSocketChannelInitializer()); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class NioWebSocketChannelInitializer extends ChannelInitializer\u0026lt;SocketChannel\u0026gt; { @Override protected void initChannel(SocketChannel ch) { // 设置log监听器，并且日志级别为debug，方便观察运行流程 ch.pipeline().addLast(\u0026#34;logging\u0026#34;, new LoggingHandler(\u0026#34;DEBUG\u0026#34;)); // 设置解码器 ch.pipeline().addLast(\u0026#34;http-codec\u0026#34;, new HttpServerCodec()); // 聚合器，使用websocket会用到 ch.pipeline().addLast(\u0026#34;aggregator\u0026#34;, new HttpObjectAggregator(65536)); // 用于大数据的分区传输 ch.pipeline().addLast(\u0026#34;http-chunked\u0026#34;, new ChunkedWriteHandler()); // 自定义的业务handler ch.pipeline().addLast(\u0026#34;handler\u0026#34;, new NioWebSocketHandler()); } } 5.自定义的业务handler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 public class NioWebSocketHandler extends SimpleChannelInboundHandler\u0026lt;Object\u0026gt; { private final Logger logger=Logger.getLogger(this.getClass()); private WebSocketServerHandshaker handshaker; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception { logger.debug(\u0026#34;收到消息：\u0026#34;+msg); if (msg instanceof FullHttpRequest){ //以http请求形式接入，但是走的是websocket handleHttpRequest(ctx, (FullHttpRequest) msg); }else if (msg instanceof WebSocketFrame){ //处理websocket客户端的消息 handlerWebSocketFrame(ctx, (WebSocketFrame) msg); } } @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { //添加连接 logger.debug(\u0026#34;客户端加入连接：\u0026#34;+ctx.channel()); ChannelSupervise.addChannel(ctx.channel()); } @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { //断开连接 logger.debug(\u0026#34;客户端断开连接：\u0026#34;+ctx.channel()); ChannelSupervise.removeChannel(ctx.channel()); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } private void handlerWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame){ // 判断是否关闭链路的指令 if (frame instanceof CloseWebSocketFrame) { handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); return; } // 判断是否ping消息 if (frame instanceof PingWebSocketFrame) { ctx.channel().write( new PongWebSocketFrame(frame.content().retain())); return; } // 本例程仅支持文本消息，不支持二进制消息 if (!(frame instanceof TextWebSocketFrame)) { logger.debug(\u0026#34;本例程仅支持文本消息，不支持二进制消息\u0026#34;); throw new UnsupportedOperationException(String.format( \u0026#34;%s frame types not supported\u0026#34;, frame.getClass().getName())); } // 返回应答消息 String request = ((TextWebSocketFrame) frame).text(); logger.debug(\u0026#34;服务端收到：\u0026#34; + request); TextWebSocketFrame tws = new TextWebSocketFrame(new Date().toString() + ctx.channel().id() + \u0026#34;：\u0026#34; + request); // 群发 ChannelSupervise.send2All(tws); // 返回【谁发的发给谁】 // ctx.channel().writeAndFlush(tws); } /** * 唯一的一次http请求，用于创建websocket * */ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) { //要求Upgrade为websocket，过滤掉get/Post if (!req.decoderResult().isSuccess() || (!\u0026#34;websocket\u0026#34;.equals(req.headers().get(\u0026#34;Upgrade\u0026#34;)))) { //若不是websocket方式，则创建BAD_REQUEST的req，返回给客户端 sendHttpResponse(ctx, req, new DefaultFullHttpResponse( HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return; } WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( \u0026#34;ws://localhost:8081/websocket\u0026#34;, null, false); handshaker = wsFactory.newHandshaker(req); if (handshaker == null) { WebSocketServerHandshakerFactory .sendUnsupportedVersionResponse(ctx.channel()); } else { handshaker.handshake(ctx.channel(), req); } } /** * 拒绝不合法的请求，并返回错误信息 * */ private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res) { // 返回应答给客户端 if (res.status().code() != 200) { ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); } ChannelFuture f = ctx.channel().writeAndFlush(res); // 如果是非Keep-Alive，关闭连接 if (!isKeepAlive(req) || res.status().code() != 200) { f.addListener(ChannelFutureListener.CLOSE); } } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8netty%E5%88%9B%E5%BB%BAwebsocket%E6%9C%8D%E5%8A%A1/","title":"使用Netty创建websocket服务"},{"content":"黑苹果安装 下载镜像以及破解补丁\n1.复制破解补丁到VM安装目录 执行安装，成功后会在 tools目录生成\n1 2 darwin.iso darwinPre15.iso 2.安装镜像，版本选择10.8 3.修改macOS.vmx 在配置文件最后，加入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 smc.version = \u0026#34;0\u0026#34; cpuid.0.eax = \u0026#34;0000:0000:0000:0000:0000:0000:0000:1011\u0026#34; cpuid.0.ebx = \u0026#34;0111:0101:0110:1110:0110:0101:0100:0111\u0026#34; cpuid.0.ecx = \u0026#34;0110:1100:0110:0101:0111:0100:0110:1110\u0026#34; cpuid.0.edx = \u0026#34;0100:1001:0110:0101:0110:1110:0110:1001\u0026#34; cpuid.1.eax = \u0026#34;0000:0000:0000:0001:0000:0110:0111:0001\u0026#34; cpuid.1.ebx = \u0026#34;0000:0010:0000:0001:0000:1000:0000:0000\u0026#34; cpuid.1.ecx = \u0026#34;1000:0010:1001:1000:0010:0010:0000:0011\u0026#34; cpuid.1.edx = \u0026#34;0000:0111:1000:1011:1111:1011:1111:1111\u0026#34; smbios.reflectHost = \u0026#34;TRUE\u0026#34; hw.model = \u0026#34;MacBookPro14,3\u0026#34; board-id = \u0026#34;Mac-551B86E5744E2388\u0026#34; usb_xhci:1.speed = \u0026#34;2\u0026#34; usb_xhci:1.present = \u0026#34;TRUE\u0026#34; usb_xhci:1.deviceType = \u0026#34;hub\u0026#34; usb_xhci:1.port = \u0026#34;1\u0026#34; usb_xhci:1.parent = \u0026#34;-1\u0026#34; usb_xhci:3.speed = \u0026#34;4\u0026#34; usb_xhci:3.present = \u0026#34;TRUE\u0026#34; usb_xhci:3.deviceType = \u0026#34;hub\u0026#34; usb_xhci:3.port = \u0026#34;3\u0026#34; usb_xhci:3.parent = \u0026#34;-1\u0026#34; keyboard.vusb.enable = \u0026#34;TRUE\u0026#34; mouse.vusb.enable = \u0026#34;TRUE\u0026#34; usb:0.present = \u0026#34;TRUE\u0026#34; usb:0.deviceType = \u0026#34;hid\u0026#34; usb:0.port = \u0026#34;0\u0026#34; usb:0.parent = \u0026#34;-1\u0026#34; 同时需要将 virtualHW.version = \u0026ldquo;16\u0026rdquo; 改成 virtualHW.version = \u0026ldquo;10\u0026rdquo;\n4.USB兼容性配置，切换成USB2.0 5.抹除虚拟磁盘 点击磁盘工具，找到VM虚拟磁盘，点击抹除。然后开始安装系统\n6.安装VMtools 使用CD驱动器加载 破解补丁中的 darwin.iso 进行安装。\n1 2 3 sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES sudo defaults delete /Library/Preferences/com.apple.windowserver DisplayResolutionDisabled /Library/Application\\ Support/VMware\\ Tools/vmware-resolutionSet 3416 1920 参考某一个教程，执行了这三条命令，前两条执行正常，最后一个执行报错 unable to find the server\n最后在 系统 安全和隐私 启用了 VMTools 重启就正常了，怀疑命令是没啥用\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E4%BD%BF%E7%94%A8vm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%95%99%E7%A8%8B/","title":"使用VM虚拟机安装黑苹果教程"},{"content":"golang手把手实现tcp内网穿透代理\nhttps://www.jianshu.com/p/0c3f8323b43c https://www.jianshu.com/p/dd90fc516ecc https://www.jianshu.com/p/e79fe205f3e0 从字节码层面看“HelloWorld”\nhttps://www.cnblogs.com/paddix/p/5282004.html JVM调优总结\nhttps://www.cnblogs.com/andy-zhou/p/5327288.html 用Java实现JVM\nhttps://www.jianshu.com/p/4d81465c2fb8 用GO实现JVM\nhttps://github.com/zxh0/jvm.go Spring Cloud Config 实现配置中心，看这一篇就够了\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 汇编语言入门教程\nhttp://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html 开源一个用 go 写的内网穿透反向代理软件 lunnel\nhttps://github.com/longXboy/lunnel go库中自带的反向代理功能和内网代理\nhttps://blog.csdn.net/idwtwt/article/details/52588762 如何做Go的性能优化？（转）\nhttps://www.cnblogs.com/wangbin/p/10209882.html CPU处理器架构和工作原理浅析\nhttp://c.biancheng.net/view/3456.html ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.github.io/stack/p/%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F/","title":"网页收藏"}]