<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Java高并发编程详解：多线程与架构设计（汪文君） on 羡鱼先生的空间</title>
        <link>https://lyoshur.github.io/stack/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B/</link>
        <description>Recent content in Java高并发编程详解：多线程与架构设计（汪文君） on 羡鱼先生的空间</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 16 Aug 2022 15:22:00 +0000</lastBuildDate><atom:link href="https://lyoshur.github.io/stack/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>第十三章 深入volatile关键字</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B7%B1%E5%85%A5volatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
        <pubDate>Tue, 16 Aug 2022 15:22:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B7%B1%E5%85%A5volatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
        <description>&lt;h1 id=&#34;第十三章-深入volatile关键字&#34;&gt;第十三章 深入volatile关键字&lt;/h1&gt;
&lt;h2 id=&#34;1-并发编程的三个重要特性&#34;&gt;1 并发编程的三个重要特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子性&lt;/p&gt;
&lt;p&gt;原子性指在一个操纵或多次操作中，要么所有操作得到执行，要么所有操作都不执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可见性&lt;/p&gt;
&lt;p&gt;当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有序性&lt;/p&gt;
&lt;p&gt;所谓有序性，是指程序代码在执行过程中的先后顺序&lt;/p&gt;
&lt;p&gt;【note】这里其实是说，在多线程情况下，并不能保证像单线程一样严格的顺序执行，因为有可能线程1在执行过判断后，放弃了CPU时间片，线程2开始执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JVM采用内存模型的机制，来屏蔽各个平台和操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果。（比如java中的Int固定为4字节，这就是所谓的一致内存访问效果）&lt;/p&gt;
&lt;h2 id=&#34;2-jmm与原子性&#34;&gt;2 JMM与原子性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多个原子性操作在一起就不再是原子性操作了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单的读取和赋值是原子性的，但将一个变量赋值给另一个变量不是原子性的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JMM只保证了基本读取和赋值的原子性，其他不再保证了。如果想使某些代码片段具备原子性，需要使用关键子synchronized或者JUC的lock。如果想使int等类型自增操作具备原子性，可以使用JUC.atomic&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;volatile不具备原子性&lt;/p&gt;
&lt;h2 id=&#34;3-jmm与可见性&#34;&gt;3 JMM与可见性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用关键字volatile来保证可见性&lt;/li&gt;
&lt;li&gt;使用synchronized保证可见性&lt;/li&gt;
&lt;li&gt;使用JUC的lock保证可见性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;volatile具备可见性&lt;/p&gt;
&lt;h2 id=&#34;4-jmm与有序性&#34;&gt;4 JMM与有序性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用关键字volatile来保证有序性&lt;/li&gt;
&lt;li&gt;使用synchronized保证有序性&lt;/li&gt;
&lt;li&gt;使用JUC的lock保证有序性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;volatile具备有序性&lt;/p&gt;
&lt;p&gt;此外JMM具备一些天生的有序性规则，不需要任何同步手段就能保持有序性。（Happens-before原则）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序次序规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁定规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile变量规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程启动规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程中断规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程的终结规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象的终结规则&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-volatile关键字深入解析&#34;&gt;5 volatile关键字深入解析&lt;/h2&gt;
&lt;h3 id=&#34;51-volatile关键字的语义&#34;&gt;5.1 volatile关键字的语义&lt;/h3&gt;
&lt;p&gt;被volatile修饰的实例变量或者类变量具备如下两层语义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保证了不同线程之间对共享变量操作时的可见性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁止对指令进行重排序（直接禁止JVM和处理器对volailte关键字修饰的指令进行重排序）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;52-volatile的原理和实现机制&#34;&gt;5.2 volatile的原理和实现机制&lt;/h3&gt;
&lt;p&gt;通过对unsafe.cpp源码的阅读，会发现被volatile修饰的变量存在与一个“lock;”前缀&lt;/p&gt;
&lt;p&gt;lock;前缀实际上相当于一个内存屏障，该内存屏障会为指令的执行提供如下几个保障。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保指令重排序时不会将后面的代码排到内存屏障之前。&lt;/li&gt;
&lt;li&gt;确保指令重排序时不会将前面的代码排到内存屏障之后。&lt;/li&gt;
&lt;li&gt;确保执行到内存屏障修饰的指令时，前面的代码全部执行完成。&lt;/li&gt;
&lt;li&gt;强制将工作线程中的值，修改刷新到主内存&lt;/li&gt;
&lt;li&gt;如果是写操作，则会强制其他线程的工作内存中的缓存数据全部失效&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第十四章 7种单例模式的设计</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Tue, 16 Aug 2022 15:22:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
        <description>&lt;h1 id=&#34;第十四章-7种单例模式的设计&#34;&gt;第十四章 7种单例模式的设计&lt;/h1&gt;
&lt;h2 id=&#34;1-饿汉式&#34;&gt;1 饿汉式&lt;/h2&gt;
&lt;p&gt;不支持懒加载&lt;/p&gt;
&lt;h2 id=&#34;2-懒汉式&#34;&gt;2 懒汉式&lt;/h2&gt;
&lt;p&gt;多线程情况下不能保证唯一一次的实例化&lt;/p&gt;
&lt;h3 id=&#34;3-懒汉式--同步方法&#34;&gt;3 懒汉式 + 同步方法&lt;/h3&gt;
&lt;p&gt;性能较低&lt;/p&gt;
&lt;h2 id=&#34;4-double-check&#34;&gt;4 Double-Check&lt;/h2&gt;
&lt;p&gt;可能会抛出空指针异常&lt;/p&gt;
&lt;h2 id=&#34;5-volatile--double-check&#34;&gt;5 Volatile + Double-Check&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h2 id=&#34;6-holder方式&#34;&gt;6 Holder方式&lt;/h2&gt;
&lt;p&gt;利用了类加载机制，是目前最好的设计之一，也是目前使用比较广泛的设计&lt;/p&gt;
&lt;h2 id=&#34;7-使用枚举实现单例&#34;&gt;7 使用枚举实现单例&lt;/h2&gt;
&lt;p&gt;不支持懒加载&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第十二章 volatile关键字介绍</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/</link>
        <pubDate>Tue, 16 Aug 2022 14:30:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%8B%E7%BB%8D/</guid>
        <description>&lt;h1 id=&#34;第十二章-volatile关键字介绍&#34;&gt;第十二章 volatile关键字介绍&lt;/h1&gt;
&lt;h2 id=&#34;1-机器硬件cpu&#34;&gt;1 机器硬件CPU&lt;/h2&gt;
&lt;p&gt;在计算机，所有的运算操作都是由CPU的寄存器来完成的，CPU指令的执行过程需要涉及到数据的读取和写入操作。Cpu访问的数据只能是计算机的主存。&lt;/p&gt;
&lt;p&gt;由于两边数据的严重不对等，通过传统FSB直连内存的访问方式很明显会导致CPU资源收到大量限制，降低CPU整体的吞吐量。于是就有了在CPU和主存之间做缓存的限制。最靠近CPU的缓存称之为L1，然后依次是L2,L3和主内存。&lt;/p&gt;
&lt;p&gt;由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache又被划分为了 L1i （instrucgtion）和 L1d (data)&lt;/p&gt;
&lt;p&gt;CPU Cache又是由很多 Cache Line构成的，Cache Line是CPU Cache的最小组成单位。目前主流的Cache Line都是64字节。&lt;/p&gt;
&lt;p&gt;Cache的出现是为了解决CPU直接访问内存效率低下的问题，所以程序在运行时，会将运算所需的一部分数据从主存复制到Cache，当运算结束后再将数据刷回到主存。&lt;/p&gt;
&lt;h2 id=&#34;2-cpu缓存一致性问题&#34;&gt;2 CPU缓存一致性问题&lt;/h2&gt;
&lt;p&gt;每个线程都有自己的工作内存，变量会在多个线程的本地内存都存一份副本。&lt;/p&gt;
&lt;p&gt;为了解决缓存一致性问题，通常主流的解决办法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过总线加锁的方式&lt;/p&gt;
&lt;p&gt;常见于早期的CPU，而且是一种悲观的实现方式，CPU和其他组件通信，都是通过总线来进行的，通过对总线进行加锁，会阻塞其他CPU的访问，从而使得只有一个CPU能够访问这个变量的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过缓存一致性协议&lt;/p&gt;
&lt;p&gt;最为出名的是Intel的MESI协议，它保证了每个缓存中使用的变量副本都是一致的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读取操作，将缓存中的数据读取到寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写入操作，发出信号通知其他CPU将变量的Cache Line置为无效的状态，其他的CPU在进行变量读取时，不得不去主内存再次读取。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-java内存模型jmm&#34;&gt;3 Java内存模型（JMM）&lt;/h2&gt;
&lt;p&gt;Java内存模型定义了线程和主内存之间的抽象关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享变量储存于主内存之中，每个线程都可以访问。&lt;/li&gt;
&lt;li&gt;每个线程都有私有的工作内存或者称为本地内存。&lt;/li&gt;
&lt;li&gt;工作内存只储存该线程对共享变量的副本。&lt;/li&gt;
&lt;li&gt;线程不能直接操作主内存，只有操作工作内存，再写入主内存。&lt;/li&gt;
&lt;li&gt;工作内存和JMM一样，是一个抽象的概念，它其实并不存在。它涵盖了缓存、编译器优化、寄存器、和硬件。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第十一章 线程上下文类加载器</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
        <pubDate>Tue, 16 Aug 2022 14:30:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
        <description>&lt;h1 id=&#34;第十一章-线程上下文类加载器&#34;&gt;第十一章 线程上下文类加载器&lt;/h1&gt;
&lt;h2 id=&#34;1-为什么需要线程上下文类加载器&#34;&gt;1 为什么需要线程上下文类加载器&lt;/h2&gt;
&lt;p&gt;Thread类提供了API用来获取以及设置当前线程的上下文类加载器，如果当前线程没有设置上下文类加载器，那么它将与父线程抱持同样的类加载器。&lt;/p&gt;
&lt;p&gt;JDK核心库中提供了很多SPI (Service Provider Interface)。常见的包括JDBC、JCE、JNDI、JAXP、JBI等，JDK只提供了这些接口之间的逻辑关系，但不提供具体的实现。Java使用 JDBC这个SPI完全透明了应用程序和第三方厂商数据库驱动的具体实现。不管数据库类型如何切换，应用程序只需要更新JDBC的驱动jar包和驱动名称，而不需要进行任何更新。&lt;/p&gt;
&lt;p&gt;由于JDK定义了SPI的标准接口，加之这些接口作为JDK核心标准类库的一部分，即想要完全透明标准接口的实现，又想与JDK核心库进行捆绑，由于JVM双亲委托机制的限制，根加载器不可能加载的到第三方厂商提供的具体实现。为了解决这个困境，JDK只好提供一个不太优雅的设计，线程上下文类加载器，有了线程上下文类加载器，根加载器反而需要委托子类加载器去加载厂商提供的SPI具体实现。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第十章 JVM类加载器</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E7%AB%A0-jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
        <pubDate>Tue, 16 Aug 2022 14:00:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%8D%81%E7%AB%A0-jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
        <description>&lt;h1 id=&#34;第十章-jvm类加载器&#34;&gt;第十章 JVM类加载器&lt;/h1&gt;
&lt;p&gt;类的加载器负责类的加载职责，对于任意一个class都需要由加载它的类加载器和这个类本身确定其在JVM中的唯一性，这也就是运行时包。&lt;/p&gt;
&lt;h2 id=&#34;1-jvm内置三大类加载器&#34;&gt;1 JVM内置三大类加载器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bootstrap ClassLoader&lt;/p&gt;
&lt;p&gt;根加载器又称为Bootstrap类加载器，是最为顶层的加载器，其没有任何父加载器，是由C++编写的，主要负责核心类库的加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ext ClassLoader&lt;/p&gt;
&lt;p&gt;拓展类加载器的父加载器是根加载器，主要用于加载 JAVA_HOME下的 jre/lib/ext 目录里面的类库，拓展类加载器是由纯Java语言实现的，它是java.lang.URLClassLoader的子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application ClassLoader&lt;/p&gt;
&lt;p&gt;系统类加载器是一种常见的加载器，其负责加载classpath下的类库资源，我们在进行项目开发的时候引入的第三方jar包，系统类加载器的父加载器是拓展类加载器，同时他也是自定义类加载器的默认父加载器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的类加载器负责将不同的类加载到JVM内存之中，并且他们之间严格遵守着父委托的机制。&lt;/p&gt;
&lt;h2 id=&#34;2-自定义类加载器&#34;&gt;2 自定义类加载器&lt;/h2&gt;
&lt;p&gt;自定义类加载器必须是ClassLoader的直接或间接子类，然后重写findClass方法。&lt;/p&gt;
&lt;p&gt;【note】这里注意，自定义类加载器需要重写findClass方法，但是破坏双亲委托机制需要重写loadClass方法。&lt;/p&gt;
&lt;h2 id=&#34;3-双亲委托机制详细介绍&#34;&gt;3 双亲委托机制详细介绍&lt;/h2&gt;
&lt;p&gt;双亲委托机制，有时候也称父委托机制。当一个类加载器被调用loadClass后，他并不会直接进行加载，而是交给当前类加载器的父加载器尝试加载，直到最顶层的加载器，然后再依次向下进行加载。&lt;/p&gt;
&lt;p&gt;loadClass的执行流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从当前类的已加载类缓存中根据类的全路径名查询是否存在该类，如果存在则直接返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前类存在父类，则调用父类加载器的loadClass方法对其进行加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前类不存在父类，则直接调用根加载器对其进行加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前类的父类没有加载成功，则调用当前类加载器的findClass方法对其进行加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果类最后被成功加载，则做一些性能数据的统计。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于loadClass指定了resolve，所以不会进行连接阶段的继续执行，这也解释了为什么类加载器不会导致类的初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 破坏双亲委托机制&lt;/p&gt;
&lt;p&gt;重写loadClass，改为如下流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据类的全路径名称进行加锁，确保每一个类在多线程的情况下只被加载一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从当前类的已加载类缓存中根据类的全路径名查询是否存在该类，如果存在则直接返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若缓存中没有被加载的类，则需要对其进行首次加载，如果类的全路径名称以 java/javax 开头，则直接委托给系统类加载器进行加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不是以 java/javax开头，则尝试使用自己的类加载器对其进行加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若自定义的加载器没有完成对类的加载，则委托给其父类加载器或系统加载器进行加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若干次尝试后，仍没有对类进行加载，则抛出无法找到类的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-类加载器命名空间运行时包类的卸载&#34;&gt;4 类加载器命名空间、运行时包、类的卸载&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个类加载器实例都有各自的命名空间，命名空间是由该加载器以及其所有的父加载器所构成的。因此在每个类加载器中同一个class都是独一无二的。&lt;/p&gt;
&lt;p&gt;在类加载器进行类加载的时候，首先会到加载记录表也就是缓存中，查看该类是否已经加载过了，如果已经加载过了就不会重复加载。否则会认为其是第一次加载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时包&lt;/p&gt;
&lt;p&gt;我们在编写代码时，通常会给一个类指定一个包名，包的作用是为了组织类，防止不同包下的同样名称的class起冲突。包名和类名构成了类的全限定名称。&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BootstrapClassLoader.ExtClassLoader.ApplicationClassLoader.MyClassLoader.com.xxzzz.Demo	
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样做的好处是处于安全和封装的考虑，这样自定义的类和系统类拥有不同的运行时包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始类加载器&lt;/p&gt;
&lt;p&gt;由于运行时包的存在，JVM规定了不同的运行时包下的类彼此之间是不可以互相访问的。&lt;/p&gt;
&lt;p&gt;根据JVM规范的规定，在类的加载过程中，所有参与的类加载器，即使没有亲自加载过该类，也会标识为该类的初始类加载器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的卸载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该类的所有实例都已经被GC&lt;/li&gt;
&lt;li&gt;该类对应的类加载器被GC&lt;/li&gt;
&lt;li&gt;该类的class实例没有在其他地方被引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第九章 类的加载过程</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</link>
        <pubDate>Tue, 16 Aug 2022 10:21:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid>
        <description>&lt;h1 id=&#34;第九章-类的加载过程&#34;&gt;第九章 类的加载过程&lt;/h1&gt;
&lt;p&gt;ClassLoader的主要职责就是负责加载各种class文件到JVM中，ClassLoader是一个抽象的class，给定一个class的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中。&lt;/p&gt;
&lt;h2 id=&#34;1-类的加载过程简介&#34;&gt;1 类的加载过程简介&lt;/h2&gt;
&lt;p&gt;类的加载过程一般分为三个比较大的阶段，分别是加载阶段，连接阶段和初始化阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载阶段：主要负责查找并且加载类的二进制数据文件，其实就是class文件。&lt;/li&gt;
&lt;li&gt;连接阶段：连接阶段做的工作比较多
&lt;ul&gt;
&lt;li&gt;验证：主要确保类文件的正确性，比如class的版本，class文件的魔术因子是否正确&lt;/li&gt;
&lt;li&gt;准备：为类的静态变量分配内存，并为其初始化默认值&lt;/li&gt;
&lt;li&gt;解析：把类的符号引用转化为直接引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初始化阶段：为类的静态变量赋予正确的初始化值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JVM对类的初始化是一个延迟的机制。当一个类在首次使用时才会被初始化，在同一个运行时包下，一个class只会被初始化一次。&lt;/p&gt;
&lt;h2 id=&#34;2-类的主动使用和被动使用&#34;&gt;2 类的主动使用和被动使用&lt;/h2&gt;
&lt;p&gt;JVM虚拟机规范规定，每个类或者接口被Java程序首次主动使用时才会对其进行初始化。当然随着JIT技术的越来越成熟，JVM运行期间的编译也越来越智能，不排除JVM在运行期间提前预判并且初始化某个类。&lt;/p&gt;
&lt;p&gt;JVM同时规定了6种主动使用类的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过new关键字会导致类的初始化&lt;/li&gt;
&lt;li&gt;访问类的静态变量&lt;/li&gt;
&lt;li&gt;访问类的静态方法&lt;/li&gt;
&lt;li&gt;对某个类进行反射操作&lt;/li&gt;
&lt;li&gt;初始化子类会导致父类的初始化&lt;/li&gt;
&lt;li&gt;启动类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;被动使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造某个类的数组时&lt;/li&gt;
&lt;li&gt;引用类的静态常量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-类的加载过程详解&#34;&gt;3 类的加载过程详解&lt;/h2&gt;
&lt;p&gt;简单来说类的加载就是将class文件中的二进数据读取到内存之中，然后将该字节流所代表的静态存储结构转换为方法区中运行时的数据结构。并且在堆中生成一个该类的java.lang.Class对象，作为访问方法区数据结构的入口。&lt;/p&gt;
&lt;p&gt;类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管一个类被加载了多少次，对应到堆内存中的class对象始终是一个。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证
&lt;ul&gt;
&lt;li&gt;验证文件格式&lt;/li&gt;
&lt;li&gt;验证元数据&lt;/li&gt;
&lt;li&gt;验证字节码&lt;/li&gt;
&lt;li&gt;验证符号引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;准备
&lt;ul&gt;
&lt;li&gt;当一个class的字节流通过了验证过程之后,就开始为该对象的类变量(静态变量)分配内存并设置初始值了。类变量的内存会被分配到方法区，不同与实例变量会被分配到堆内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中a在准备阶段不是10，而是初始值0。当然b还是10，因为final修饰的静态变量不会导致类的初始化，是一种被动引用。&lt;/p&gt;
&lt;p&gt;【note】这里的b应该是属于静态常量，也就是被动使用的第二种情况，所以跟Demo类无关所以不需要走连接&lt;/p&gt;
&lt;p&gt;当然更严谨的解释是b在类的编译阶段javac会将其value生成一个ConstantValue，直接赋予10；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析
&lt;ul&gt;
&lt;li&gt;类接口解析&lt;/li&gt;
&lt;li&gt;字段的解析&lt;/li&gt;
&lt;li&gt;类方法的解析&lt;/li&gt;
&lt;li&gt;接口方法的解析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第八章 线程池原理以及自定义线程池</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
        <pubDate>Mon, 15 Aug 2022 17:00:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
        <description>&lt;h1 id=&#34;第八章-线程池原理以及自定义线程池&#34;&gt;第八章 线程池原理以及自定义线程池&lt;/h1&gt;
&lt;p&gt;一个完整的线程池应该具备如下要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任务队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程数量管理功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务拒绝策略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程工厂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QueueSize&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Keepedalive&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-拒绝策略&#34;&gt;1 拒绝策略&lt;/h2&gt;
&lt;p&gt;DenyPolicy主要用于当Queue的runnable达到了limit上限时，通过那种策略来通知提交者。&lt;/p&gt;
&lt;p&gt;默认包含三种实现：&lt;/p&gt;
&lt;p&gt;DiscardDenyPolicy 该拒绝策略会直接将任务丢弃&lt;/p&gt;
&lt;p&gt;AbortDenyPolicy 该拒绝策略会向任务提出者抛出异常&lt;/p&gt;
&lt;p&gt;RunnerDenyPolicy 该拒绝策略会在任务提交者所在的线程中执行任务&lt;/p&gt;
&lt;h2 id=&#34;2-internaltask&#34;&gt;2 InternalTask&lt;/h2&gt;
&lt;p&gt;InternalTask是Runnable的一个实现，主要用于线程池内部，该类会使用到RunnableQueue,然后从queue中取出某个Runnable,并运行runnable的run方法。&lt;/p&gt;
&lt;p&gt;这部分作者直接手写了一个线程池，可怕 = =、&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第七章 捕获线程异常以及Hook线程</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8Ahook%E7%BA%BF%E7%A8%8B/</link>
        <pubDate>Mon, 15 Aug 2022 16:50:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8Ahook%E7%BA%BF%E7%A8%8B/</guid>
        <description>&lt;h1 id=&#34;第七章-捕获线程异常以及hook线程&#34;&gt;第七章 捕获线程异常以及Hook线程&lt;/h1&gt;
&lt;h2 id=&#34;1-捕获线程异常&#34;&gt;1 捕获线程异常&lt;/h2&gt;
&lt;p&gt;线程在执行单元中是不允许抛出checked异常的，在线程运行的上下文中，父线程无法直接获得它运行时出现的异常信息，对此java给我们提供了一个UncaughtExceptionHandler接口。当线程在运行过程中出现异常时，会回调该接口。从而得知是哪个线程出错，以及出现了什么样的错误。&lt;/p&gt;
&lt;p&gt;线程出现问题，但没有给线程指定UncaughtExceptionHandler接口时，会向上寻找Group的UEH接口，如果还没找到，会继续向上查找Group的接口。最后走到System.err&lt;/p&gt;
&lt;h2 id=&#34;2-hook线程&#34;&gt;2 Hook线程&lt;/h2&gt;
&lt;p&gt;Hook线程只有在收到退出信号时会被执行，如果在kill的时候使用了-9 那么Hook线程也不会被执行，Hook线程也可以用来执行资源释放，但不要再Hook中执行一些耗时非常长的操作，以为会导致程序无法退出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Runtime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getRuntime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addShutdownHook&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>第六章 ThreadGroup详细讲解</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%85%AD%E7%AB%A0-threadgroup%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/</link>
        <pubDate>Mon, 15 Aug 2022 16:10:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%85%AD%E7%AB%A0-threadgroup%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/</guid>
        <description>&lt;h1 id=&#34;第六章-threadgroup详细讲解&#34;&gt;第六章 ThreadGroup详细讲解&lt;/h1&gt;
&lt;p&gt;新的线程默认会被加入父线程所在的group中，如同线程存在父子关系一样ThreadGroup同样也存在父子关系。&lt;/p&gt;
&lt;h2 id=&#34;1-threadgroup-api&#34;&gt;1 ThreadGroup API&lt;/h2&gt;
&lt;p&gt;在一个ThreadGroup中会加入若干线程以及子线程ThreadGroup,ThreadGroup为我们提供了若干个方法可以复制出线程和线程组。&lt;/p&gt;
&lt;h3 id=&#34;11-复制-thread-数组&#34;&gt;1.1 复制 Thread 数组&lt;/h3&gt;
&lt;p&gt;public int enumerate(Thread[] list)&lt;/p&gt;
&lt;p&gt;public int enumerate(Thread[] list, boolean recurse)&lt;/p&gt;
&lt;h3 id=&#34;12-复制threadgroup数组&#34;&gt;1.2 复制ThreadGroup数组&lt;/h3&gt;
&lt;p&gt;public int enumerate(ThreadGroup[] list)&lt;/p&gt;
&lt;p&gt;public int enumerate(ThreadGroup[] list, boolean recurse)&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第五章 线程间通信</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link>
        <pubDate>Mon, 15 Aug 2022 15:10:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid>
        <description>&lt;h1 id=&#34;第五章-线程间通信&#34;&gt;第五章 线程间通信&lt;/h1&gt;
&lt;p&gt;与网络通信等进程间通信方式不一样,线程间通信又称为进程内通信,多个线程实现互斥访问共享资源时会互相发送信号和等待信号。比如线程等待数据到来的信号。线程收到变量改变的信号。&lt;/p&gt;
&lt;h2 id=&#34;1-初始wait和notify&#34;&gt;1 初始wait和notify&lt;/h2&gt;
&lt;p&gt;wait()  导致当前线程等待，直到其他线程调用此对象的 &lt;a class=&#34;link&#34; href=&#34;https://so.csdn.net/so/search?q=notify&amp;amp;spm=1001.2101.3001.7020&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;notify&lt;/a&gt;()方法或 notifyAll()方法前，导致当前线程等待。&lt;/p&gt;
&lt;p&gt;notify() 唤醒在此同步监视器上等待的单个线程，如果有多个线程在此同步监视器上等待，则会唤醒其中的一个，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;lyoshur&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.LinkedList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EventQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULT_MAX_EVENT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;EventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DEFAULT_MAX_EVENT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;EventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;offer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Event&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InterruptedException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addLast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;notify&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Event&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;take&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InterruptedException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;Event&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;removeFirst&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;eventQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;notify&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当eventQueue满时，会调用eventQueue.wait。这时offer会释放掉锁资源，并将当前线程添加到 wait set。&lt;/p&gt;
&lt;p&gt;当消费掉数据后，this.eventQueue.notify(); 会通知某个wait set的线程启动，但不会立即执行，需要当前take释放掉锁。而offer会重新获取锁，并从上次wait的地方继续运行。&lt;/p&gt;
&lt;h2 id=&#34;2-多线程间通信&#34;&gt;2 多线程间通信&lt;/h2&gt;
&lt;p&gt;多线程间通信需要用到Object的notifyAll方法。&lt;/p&gt;
&lt;p&gt;这个队列在多线程同时并发的情况下会出现数据不一致的问题，大致可以被分为两部分，一个是超过了最大数量仍在执行add，另一个是没有元素了仍调用remove。&lt;/p&gt;
&lt;p&gt;改进：需要将临界值的判断if更改为while，将notify更改为notifyAll&lt;/p&gt;
&lt;h2 id=&#34;3-线程休息室&#34;&gt;3 线程休息室&lt;/h2&gt;
&lt;p&gt;在虚拟机规范中存在一个wait set的概念，但没有定义具体的数据结构。不同的厂商有着不同的实现方式。线程调用某个对象的wait方法后，都会被加入到与该对象monitor关联的wait set中，至于是先入先出还是随机弹出，虚拟机规范也没有规定。&lt;/p&gt;
&lt;h2 id=&#34;4-显示锁&#34;&gt;4 显示锁&lt;/h2&gt;
&lt;p&gt;可以使用BooleanLock显示锁来控制。sync不能被打断，但是显示锁可以。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第四章 线程安全与数据同步</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</link>
        <pubDate>Mon, 15 Aug 2022 15:00:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</guid>
        <description>&lt;h1 id=&#34;第四章-线程安全与数据同步&#34;&gt;第四章 线程安全与数据同步&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;在《操作系统同步原语》 这篇文章中，介绍了操作系统在面对 进程/线程 间同步的时候，所支持的一些同步原语，其中 semaphore 信号量 和 mutex 互斥量是最重要的同步原语。&lt;/p&gt;
&lt;p&gt;semaphore 信号量 和 mutex 互斥量 monitor 管程&lt;/p&gt;
&lt;p&gt;在使用基本的 mutex 进行并发控制时，需要程序员非常小心地控制 mutex 的 down 和 up 操作，否则很容易引起死锁等问题。为了更容易地编写出正确的并发程序，所以在 mutex 和 semaphore 的基础上，提出了更高层次的同步原语 monitor，不过需要注意的是，操作系统本身并不支持 monitor 机制，实际上，monitor 是属于编程语言的范畴，当你想要使用 monitor 时，先了解一下语言本身是否支持 monitor 原语，例如 C 语言它就不支持 monitor，Java 语言支持 monitor。
一般的 monitor 实现模式是编程语言在语法上提供语法糖，而如何实现 monitor 机制，则属于编译器的工作，Java 就是这么干的。&lt;/p&gt;
&lt;p&gt;monitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区，这使得 monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 monitor 临界区的 进程/线程，它们应该被阻塞，并且在必要的时候会被唤醒。显然，monitor 作为一个同步工具，也应该提供这样的管理 进程/线程 状态的机制。想想我们为什么觉得 semaphore 和 mutex 在编程上容易出错，因为我们需要去亲自操作变量以及对 进程/线程 进行阻塞和唤醒。monitor 这个机制之所以被称为“更高级的原语”，那么它就不可避免地需要对外屏蔽掉这些机制，并且在内部实现这些机制，使得使用 monitor 的人看到的是一个简洁易用的接口。&lt;/p&gt;
&lt;h2 id=&#34;1-synchronized关键字&#34;&gt;1 synchronized关键字&lt;/h2&gt;
&lt;p&gt;在jdk1.5之前，要解决这个问题需要使用synchronized关键字，synchronized提供了一种排他机制，在同一时间只能有一个线程执行某些操作。&lt;/p&gt;
&lt;p&gt;synchronized关键字可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的读写操作都将通过同步的方式来进行。&lt;/p&gt;
&lt;p&gt;1.1 synchronized关键字提供了一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题的出现。&lt;/p&gt;
&lt;p&gt;1.2 synchronized关键字包含了monitor enter和monitor exit 两个JVM指令，它能够保证在任何时候执行到monitor enter之前都必须从主内存获取数据，而不是从缓存中。在monitor exit运行成功后，共享变量被更新的值必须输入主内存。&lt;/p&gt;
&lt;p&gt;1.3 synchronized的指令严格遵守java happends-before规则，一个monitor exit指令之前必定要有一个monitor enter。&lt;/p&gt;
&lt;h2 id=&#34;2-this-monitor-和-class-monitor&#34;&gt;2 This Monitor 和 Class Monitor&lt;/h2&gt;
&lt;p&gt;This Monitor锁定的是对象实例&lt;/p&gt;
&lt;p&gt;Class Monitor锁定的是对象.class&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第三章 ThreadAPI的详细介绍</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%89%E7%AB%A0-threadapi%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</link>
        <pubDate>Mon, 15 Aug 2022 14:00:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%89%E7%AB%A0-threadapi%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</guid>
        <description>&lt;h1 id=&#34;第三章-threadapi的详细介绍&#34;&gt;第三章 ThreadAPI的详细介绍&lt;/h1&gt;
&lt;h2 id=&#34;1-线程sleep&#34;&gt;1 线程sleep&lt;/h2&gt;
&lt;p&gt;sleep是一个静态方法，并有两个重载方法，其中一个需要传入毫秒数，另一个既需要毫秒数也需要纳秒数。&lt;/p&gt;
&lt;p&gt;sleep方法会使当前线程进入指定毫秒数的休眠，暂停执行，虽然给定了一个休眠的时间，但是最终还是要以系统的定时器以及调度器的精度为准，休眠有一个重要的特性就是不会放弃monitor锁的所有权。&lt;/p&gt;
&lt;p&gt;JDK1.5以后JDK引入了一个枚举TimeUtil，其对sleep提供了很好的封装。使用它可以省去很多时间单位的换算步骤。&lt;/p&gt;
&lt;h2 id=&#34;2-线程yield&#34;&gt;2 线程yield&lt;/h2&gt;
&lt;p&gt;yieId方法属于一种启发式的方法，其会提醒调度器我愿意放弃当前CPU资源，如果CPU资源不紧张，则会忽略这种提醒。&lt;/p&gt;
&lt;p&gt;2.1 JDK1.5之前的版本中 yieId的方法事实上是调用了sleep(0)，但是他们之间存在本质的区别&lt;/p&gt;
&lt;p&gt;2.2 yield只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，他会导致线程上下文的切换。&lt;/p&gt;
&lt;p&gt;2.3 sleep会使线程短暂block，会在给定时间内释放CPU资源。&lt;/p&gt;
&lt;p&gt;2.4 yield会使RUNNING状态的Thread进入RUNNABLE状态（如果CPU调度器没有忽略这个提示的话）&lt;/p&gt;
&lt;p&gt;2.5 sleep几乎百分之百的完成了给定时间的休眠，而yield的提示不一定能担保&lt;/p&gt;
&lt;p&gt;2.6 一个线程sleep另一个线程调用interrupt会捕获到中断信号，而yield不会&lt;/p&gt;
&lt;h2 id=&#34;3-线程优先级setpriority&#34;&gt;3 线程优先级（setPriority）&lt;/h2&gt;
&lt;p&gt;理论上优先级比较高的线程会获取优先被CPU调度的机会。如果CPU比较忙，优先级高的可能会获得更多的CPU时间片。但是闲事优先级的高低几乎不会有任何作用。&lt;/p&gt;
&lt;p&gt;线程的优先级不能小于1，也不会大于10。如果指定的线程优先级大于线程所在Group的优先级，那么指定的优先级将会失效。取而代之的是group的最大优先级。一般都是5。&lt;/p&gt;
&lt;h2 id=&#34;4-获取线程id&#34;&gt;4 获取线程ID&lt;/h2&gt;
&lt;p&gt;public long getId() 获取线程的唯一ID，线程ID在整个JVM进程中都会是唯一的。&lt;/p&gt;
&lt;h2 id=&#34;5-获取当前线程&#34;&gt;5 获取当前线程&lt;/h2&gt;
&lt;p&gt;public static Thread currentThread() 用于返回当前线程的引用。&lt;/p&gt;
&lt;h2 id=&#34;6-设置线程上下文类加载器&#34;&gt;6 设置线程上下文类加载器&lt;/h2&gt;
&lt;p&gt;public ClassLoader getContextClassLoader&lt;/p&gt;
&lt;p&gt;public void setContextClassLoader&lt;/p&gt;
&lt;p&gt;设置该线程的类加载器，这个方法可以打破JAVA类加载器的父类委托机制，有时候该方法也成为JAVA类加载器的后门。&lt;/p&gt;
&lt;h2 id=&#34;7-线程interrrupt&#34;&gt;7 线程interrrupt&lt;/h2&gt;
&lt;p&gt;wait、sleep、join等方法会使当前线程进入阻塞状态，若另一个线程调用被阻塞线程的interrrupt方法，则会打断这种阻塞。&lt;/p&gt;
&lt;p&gt;所以是用来打断阻塞继续运行的？不过打断会导致抛出一个异常InterruptedException&lt;/p&gt;
&lt;h2 id=&#34;8-线程join&#34;&gt;8 线程join&lt;/h2&gt;
&lt;p&gt;线程A join线程B，会使线程A进入等待，直到线程B结束生命周期或者到达给定时间，在此期间线程A是处于BLOCKED的&lt;/p&gt;
&lt;h2 id=&#34;9-如何关闭一个线程&#34;&gt;9 如何关闭一个线程&lt;/h2&gt;
&lt;p&gt;JDK有一个被弃用的方法，stop用来关闭线程，但这个方法在关闭线程时可能不会释放掉monitor锁，所以强烈建议不要使用该方法结束线程&lt;/p&gt;
&lt;h3 id=&#34;91-使用中断信号退出线程&#34;&gt;9.1 使用中断信号退出线程&lt;/h3&gt;
&lt;h3 id=&#34;92-使用volatile开关&#34;&gt;9.2 使用volatile开关&lt;/h3&gt;
</description>
        </item>
        <item>
        <title>JVM内存结构</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link>
        <pubDate>Mon, 15 Aug 2022 11:22:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h1 id=&#34;jvm内存结构&#34;&gt;JVM内存结构&lt;/h1&gt;
&lt;p&gt;JVM在执行java程序时会把对应的物理内存划分成不同的区域，有些分区随着JVM启动而创建，有些则是运行时才创建。&lt;/p&gt;
&lt;h2 id=&#34;1-程序计数器&#34;&gt;1 程序计数器&lt;/h2&gt;
&lt;p&gt;程序计数器用于存放当前线程接下来要执行的字节码指令、分支、循环、跳转、异常处理等信息。每个线程都有自己独立的程序计数器，因此这块区域是线程私有的。&lt;/p&gt;
&lt;p&gt;这是一块比较小的内存，且不会出现任何溢出异常。&lt;/p&gt;
&lt;h2 id=&#34;2-java虚拟机栈&#34;&gt;2 JAVA虚拟机栈&lt;/h2&gt;
&lt;p&gt;虚拟机栈在JVM运行时建立的（这里的运行时，应该是因为程序计数器、JAVA虚拟机栈、本地方法栈都是线程私有的所以需要在线程运行起来时创建）他的生命周期与线程相同，方法在执行时，会创建一个名为栈帧（stack frame）的数据结构，主要用于存放局部变量表、操作栈、动态链接、方法出口等信息。&lt;/p&gt;
&lt;p&gt;方法的调用与退出对应着栈帧在虚拟机栈中的压栈和弹栈过程。&lt;/p&gt;
&lt;p&gt;栈内存的分配大小直接决定了在一个JVM进程中可以创建多少个线程。&lt;/p&gt;
&lt;h2 id=&#34;3-本地方法栈&#34;&gt;3 本地方法栈&lt;/h2&gt;
&lt;p&gt;在调用JNI方法时，JVM为本地方法提供的内存区域是本地方法栈，这块区域的内存自由度相当高。完全由不同的JVM厂商实现。线程私有。&lt;/p&gt;
&lt;h2 id=&#34;4-堆内存&#34;&gt;4 堆内存&lt;/h2&gt;
&lt;p&gt;JVM中最大的一块内存区域，被线程所共享，Java在运行期间创建的所有对象几乎都在堆内存。该内存区域也是垃圾回收重点照顾的区域。因此堆内存有时也称为GC堆。&lt;/p&gt;
&lt;p&gt;堆内存一般会被细分为新生代和老年代。更细致的划分为Eden区（伊甸园区）、From Survivor(幸存者区 S0)、To Survivor(幸存者区 S1)。&lt;/p&gt;
&lt;h2 id=&#34;5-方法区-17-&#34;&gt;5 方法区 （1.7-）&lt;/h2&gt;
&lt;p&gt;主要用于存储已经被虚拟机加载的类信息，常量静态变量，JIT编译后的代码等数据。虽然在JVM规范中，将方法区划分为堆内存的一个逻辑分区。但是它经常还是被称为非堆。有时也被叫为持久代。&lt;/p&gt;
&lt;h2 id=&#34;6-元空间-18&#34;&gt;6 元空间 （1.8）&lt;/h2&gt;
&lt;p&gt;自从JDK1.8起，持久代被元空间取而代之（Meta Space）。元空间同样是堆内存的一部分，JVM为每个类加载器分配一块内存块列表，进行线性分配。块的大小取决于类加载器的类型，sun、反射、代理对应的类加载器会小一点。之前的版本会单独卸载回收掉某个类，而现在则是在GC的过程中发现某个类加载器已经具备回收的条件，则会将某个类加载器相关的元空间全部回收，这样可以减少内存碎片，节省GC扫描和压缩的时间。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第二章 深入理解Thread构造函数</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
        <pubDate>Mon, 15 Aug 2022 10:50:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
        <description>&lt;h1 id=&#34;第二章-深入理解thread构造函数&#34;&gt;第二章 深入理解Thread构造函数&lt;/h1&gt;
&lt;h2 id=&#34;1-线程的命名&#34;&gt;1 线程的命名&lt;/h2&gt;
&lt;p&gt;可以使用不同的构造函数对线程进行命名，为线程起一个有特殊意义的名字。如果没有为线程显式的指定一个名字，那么线程会以“Thread-”作为前缀与一个自增数字进行组合。&lt;/p&gt;
&lt;p&gt;无论你使用默认的函数命名规则，还是指定了一个特殊的名字，在线程启动之前可以使用setName对其进行修改。&lt;/p&gt;
&lt;h2 id=&#34;2-线程的父子关系&#34;&gt;2 线程的父子关系&lt;/h2&gt;
&lt;p&gt;一个线程的创建肯定是由另一个线程完成的，创建它的线程就是它的父线程。&lt;/p&gt;
&lt;h2 id=&#34;3-thread和threadgroup&#34;&gt;3 Thread和ThreadGroup&lt;/h2&gt;
&lt;p&gt;如果在创建一个线程时，没有指定一个ThreadGroup,那么子线程将会被加入父线程所在的线程组。&lt;/p&gt;
&lt;h2 id=&#34;4-thread与jvm虚拟机栈&#34;&gt;4 Thread与JVM虚拟机栈&lt;/h2&gt;
&lt;p&gt;在线程的构造函数中，可以发现有一个特殊的参数stackSize。一般情况下，创建线程的时候不会手动指定栈内存的地址空间字节数组。统一通过xss参数进行设置即可。&lt;/p&gt;
&lt;h2 id=&#34;5-守护线程&#34;&gt;5 守护线程&lt;/h2&gt;
&lt;p&gt;当你希望关闭某些线程的时候，或者退出JVM进程的时候，一些线程能够自动关闭，这个时候可以考虑将一个线程设置为守护线程。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第一章 快速认识线程</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/</link>
        <pubDate>Mon, 15 Aug 2022 10:50:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/</guid>
        <description>&lt;h1 id=&#34;第一章-快速认识线程&#34;&gt;第一章 快速认识线程&lt;/h1&gt;
&lt;p&gt;对计算机来说每一个任务就是一个进程（Process）,在每一个进程内部至少要有一个线程（Thread）是在运行中，有时线程也称为轻量级的进程。&lt;/p&gt;
&lt;p&gt;每一个线程都有自己的程序计数器、局部变量表、生命周期。&lt;/p&gt;
&lt;p&gt;线程生命周期大体可以分为如下5个主要的阶段。NEW、RUNNABLE、RUNNING、BLOCKED、TERMINATED。&lt;/p&gt;
&lt;h2 id=&#34;1-模板设计模式在thread中的应用&#34;&gt;1 模板设计模式在Thread中的应用&lt;/h2&gt;
&lt;p&gt;我们可以通过 new Thread().start(); 的方式启动一个线程，start方法的源码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * This method is not invoked for the main method thread or &amp;#34;system&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * group threads created/set up by the VM. Any new functionality added
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * to this method in the future may have to also be added to the VM.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * A zero status value corresponds to state &amp;#34;NEW&amp;#34;.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threadStatus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalThreadStateException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;cm&#34;&gt;/* Notify the group that this thread is about to be started
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * so that it can be added to the group&amp;#39;s list of threads
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * and the group&amp;#39;s unstarted count can be decremented. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;start0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;started&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;threadStartFailed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ignore&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;cm&#34;&gt;/* do nothing. If start0 threw a Throwable then
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;                  it will be passed up the call stack */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最核心的是start0这个本地方法。而start0会调用run方法。&lt;/p&gt;
&lt;p&gt;通过分析，线程的真正执行逻辑是在run方法中，通常我们会将run方法称为线程的执行单元。&lt;/p&gt;
&lt;p&gt;默认的Thread代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;所以我们可以有两种方式来实现Thread的执行单元，一种是直接重写现成的run方法。另一种是使用构造传递一个Runnable给Thread。&lt;/p&gt;
&lt;p&gt;【NOTE】这里插入一下，这里作者将这种Thread和Runnable之间的关系归类为模板设计模式，然后举了一个数据库查询Handler的例子。但是感觉没有解释清楚模板设计模式和策略模式的区别。个人感觉模板设计模式更侧重于，将模板类的一部分功能，延迟到接口类来进行实现。而策略模式侧重于为了完成某个功能，提供不同的接口类，切换使用。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
