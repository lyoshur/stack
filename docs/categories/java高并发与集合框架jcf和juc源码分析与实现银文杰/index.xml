<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰） on 羡鱼先生的空间</title>
        <link>https://lyoshur.github.io/stack/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0/</link>
        <description>Recent content in Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰） on 羡鱼先生的空间</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 22 Aug 2022 14:48:00 +0000</lastBuildDate><atom:link href="https://lyoshur.github.io/stack/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>第二章 JCF中的Queue、Deque集合</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84queuedeque%E9%9B%86%E5%90%88/</link>
        <pubDate>Mon, 22 Aug 2022 14:48:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84queuedeque%E9%9B%86%E5%90%88/</guid>
        <description>&lt;h1 id=&#34;第二章--jcf中的queuedeque集合&#34;&gt;第二章  JCF中的Queue、Deque集合&lt;/h1&gt;
&lt;p&gt;Queue（队列）、Deque（双端队列）集合是JCF中另一种重要的集合。&lt;/p&gt;
&lt;p&gt;队列存储的数据允许从结构的一端进行添加操作（入队操作），并且从结构的另一端进行移除操作（出队操作）。进行入队操作的一端称为队列尾部；进行出队操作的一端称为队列头部。双端队列是指可以在一端既进行入队操作，又进行出队操作的队列结构。&lt;/p&gt;
&lt;p&gt;注意：队列和双端队列都不允许在除了队列头部或队列尾部的其他索引位上进行数据的读/写操作。在JCF中，具有队列操作特性的集合都实现或间接实现了java.util.Queue接口；具有双端队列操作特性的集合都实现或间接实现了java.util.Deque接口。&lt;/p&gt;
&lt;p&gt;java.util.ArrayDeque集合和java.util.PriorityQueue队列分别是Queue（队列）接口和Deque（双端队列）接口在JCF中的基础集合。ArrayDeque集合为了保证对已有数组控件的充分利用，使用的是可循环的双指针数组（但不代表不进行扩容操作）；PriorityQueue队列使用的是小顶堆结构，对基于权值的排序性能进行了优化。&lt;/p&gt;
&lt;h2 id=&#34;1-arraydeque&#34;&gt;1 ArrayDeque&lt;/h2&gt;
&lt;p&gt;ArrayDeque集合是从JDK 1.6开始推出的，它是一个基于数组（可扩容的数组）结构实现的双端队列。与普通的数组结构相比，这种数组结构是一种可循环使用的数组结构，可以有效减少数组扩容的次数。ArrayDeque集合是线程不安全的，不能在多线程场景中使用。&lt;/p&gt;
&lt;p&gt;ArrayDeque集合既有队列、双端队列的操作特点，又有栈结构的操作特点。因此在JDK 1.6发布后，ArrayDeque集合是官方推荐的继Stack集合和LinkedList集合后，用于进行栈结构操作的新集合。&lt;/p&gt;
&lt;h2 id=&#34;2-priorityqueue&#34;&gt;2 PriorityQueue&lt;/h2&gt;
&lt;p&gt;PriorityQueue队列是基于堆结构构建的，具体来说，是基于数组形式的小顶堆构建的。它保证了在每次添加新数据对象、移除已有数据对象后，集合都能维持小顶堆的结构特点。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第六章 JUC的必要组成部分</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-juc%E7%9A%84%E5%BF%85%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</link>
        <pubDate>Mon, 22 Aug 2022 14:48:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-juc%E7%9A%84%E5%BF%85%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</guid>
        <description>&lt;h1 id=&#34;第六章-juc的必要组成部分&#34;&gt;第六章 JUC的必要组成部分&lt;/h1&gt;
&lt;p&gt;JUC的体系结构分为多层，底层Native JNI外的上层分别由多个关键技术模块构成：AQS、CAS、LockSupport和句柄（JDK 9开始提供变量句柄）等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于park的线程控制 juc.locks.LockSupport&lt;/p&gt;
&lt;p&gt;LockSupport工具类属于AQS框架的底层支持部分，主要用于进行线程元语级别的执行/阻塞控制。LockSupport工具类的主要方法有两个，分别为park()方法和unpark()方法。park()方法主要用于使当前线程进入阻塞状态，unpark()方法（及其重载方法）主要用于使指定线程退出阻塞状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AQS&lt;/p&gt;
&lt;p&gt;需要LockSupport和CAS支撑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由unsafe直接提供的CAS操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VarHandle和MethodHandle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于Object Monitor的线程控制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变量句柄VarHandle是从JDK 9开始引入的较新技术，它具有Unsafe工具类的部分功能特性，为程序员进行变量的原子性操作、可见性操作（内存屏障方式）提供了一种新的途径。变量句柄VarHandle可以与任意字段、数组变量、静态变量进行关联，支持在不同访问模型中对这些变量的访问（包括但不限于简单的read/write访问、使用volatile修饰的read/write访问等。变量句柄VarHandle是Java官方推荐的，可以由程序员直接使用的编程工具，不用担心它像Unsafe工具类一样突破Java的安全性限制。&lt;/p&gt;
&lt;p&gt;在这些关键技术模块的上层，JUC提供了多种可以在高并发场景中直接使用的工具类，这些工具类主要分为如下五个维度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信号：这些工具类主要基于AQS技术，用于解决线程间的同步和互斥问题，即解决多个线程的执行顺序控制问题。j.u.c.Semaphore类、j.u.c.CyclicBarrier类、j.u.c.CountDownLatch类都属于这方面的工具类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高并发场景中的JCF：这些工具类是Java官方建议在高并发场景中优先考虑使用的工具类，如j.u.c.ConcurrentHashMap类、j.u.c.ConcurrentSkipListMap类、j.u.c.ArrayBlockingQueue类等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程管理/执行：这些工具类主要用于帮助应用程序控制线程规模，保证应用程序在高并发场景中不会开启过多线程，从而导致线程切换占用过多CPU资源，即帮助应用程序在线程规模和系统性能之间保持平衡。这些工具类包括我们经常使用的各类线程池线程管理工具类，如j.u.c.ThreadPoolExecutor类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程/数据控制：这些工具类主要用于完成数据在各线程间的传递工作，或者帮助调用者完成线程间的异步调用工作，并且跟踪处理的状态和数据。这些工具类和信号工具类最大的区别是，前者着眼于一个线程，如果获得其他线程中的数据，并且对这些线程的执行顺序没有过多的要求，那么无论线程的运行先后顺序如何，数据都应该被正确传递。j.u.c.LinkedTransferQueue、j.u.c.Exchanger、j.u.c.Callable等类或接口都属于这个类型的工具类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原子性操作（无锁）：高并发场景中的操作原子性是编程过程中需要关注的另一个问题。JUC中有一个子工具箱java.util.concurrent.atomic，主要用于解决原子性操作问题，基本设计思想是CAS。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-volatile修饰符&#34;&gt;1 volatile修饰符&lt;/h2&gt;
&lt;p&gt;JUC主要依靠volatile修饰符解决内存可见性问题，更确切地说是依靠volatile修饰符背后隐含的各种形式的内存屏障来解决内存可见性问题。volatile修饰符主要用于以下场景中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在多线程场景中，需要保证共享数据内存可见性的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要避免指令重排的场景（实际用于应对有序性问题）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-mesi协议cpu缓存一致性协议&#34;&gt;2 MESI协议（CPU缓存一致性协议）&lt;/h2&gt;
&lt;h2 id=&#34;3-内存屏障memory-barrier&#34;&gt;3 内存屏障（Memory Barrier）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LoadLoad Barrier（Load Memory Barrier）：该内存屏障主要用于保证高速缓存行在进行本地读操作时的内存可见性，即保证屏障后的本地读操作结果一定是最新的数据结果。具体做法如下。一旦本地CPU内核发现执行了LoadLoad Barrier，则本地CPU内核将强制等待，直到失效队列（Invalid Queue）中所有应更新为I状态的操作全部执行完毕，才会继续执行后续读操作指令。这样，本地高速缓存行中后续读取的数据和内存中最新的数据就可以保持一致了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StoreStore Barrier（Store Memory Barrier）：该内存屏障主要用于保证高速缓存行在进行本地写操作时的数据可见性，即保证屏障后的本地写操作对其他高速缓存行可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StoreLoad Barrier（Full Barrier）：该内存屏障的性能不高，但是可以保证数据一致性，是操作系统提供的通用屏障。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LoadStore Barrier：在对存储缓存和失效队列的操作层面上，LoadStore Barrier和LoadLoad Barrier（Load Memory Barrier）没有太大的区别，但是LS对指令重排做出了不同的限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-指令重排&#34;&gt;4 指令重排&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;StoreStore Barrier（Store Memory Barrier）：该内存屏障可以保证，在内存屏障前的任意写操作不会被重排到该内存屏障后的任意写操作的后面；在内存屏障后的任意写操作不会被重排到该内存屏障前的任意写操作的前面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LoadLoad Barrier（Load Memory Barrier）：该内存屏障可以保证，在内存屏障前的任意读操作不会被重排到该内存屏障后的任意读操作的后面；在内存屏障后的任意读操作不会被重排到该内存屏障前的任意读操作的前面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LoadStore Barrier：该内存屏障对存储缓存和失效队列的操作效果和LoadLoad Barrier的效果类似，但对指令重排层面上的效果是不一样的。该内存屏障可以保证，在内存屏障前的任意读操作不会被重排到该内存屏障后的任意写操作的后面；保证在内存屏障后的任意写操作不会被重排到该内存屏障前的任意读操作的前面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StoreLoad Barrier（Full Barrier）：该内存屏障又称为通用屏障，其禁止重排的效果是，可以保证在内存屏障前的任意写操作不会被重排到该内存屏障后的任意读操作的后面；该内存屏障后的任意读操作不会被重排到该内存屏障前的任意写操作的前面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-java提供的内存栅栏&#34;&gt;5 Java提供的内存栅栏&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储栅栏（storeStore Fence，VarHandle.storeStoreFence()）：存储栅栏在编译器中的禁止重排效果和Store Memory Barrier基本内存屏障的禁止重排效果一致，即对内存屏障前的任意写操作和当前内存屏障后的任意写操作禁止重排。&lt;/li&gt;
&lt;li&gt;加载栅栏（loadLoad Fence，VarHandle.loadLoadFence()）：加载栅栏在编译器中的禁止重排效果和Load Memory Barrier基本内存屏障的禁止重排效果一致，即对内存屏障前的任意读操作和当前内存屏障后的任意读操作禁止重排。&lt;/li&gt;
&lt;li&gt;获取栅栏（acquire Fence，VarHandle.acquireFence()）：该栅栏的禁止重排效果是LoadLoad Barrier+LoadStore Barrier的禁止重排效果的组合。它可以对内存屏障后的任意读/写操作和当前内存屏障前的任意读操作禁止重排。&lt;/li&gt;
&lt;li&gt;释放栅栏（release Fence，VarHandle.releaseFence()）：该栅栏的禁止重排效果是StoreStore Barrier+LoadStore Barrier的禁止重排效果组合。它可以对内存屏障前的任意读/写操作和当前内存屏障后的任意写操作禁止重排。&lt;/li&gt;
&lt;li&gt;全栅栏（full Fence，VarHandle.fullFence()）：该栅栏是存储栅栏（storeStore Fence）+加载栅栏（loadLoad Fence）+通用屏障（StoreLoad Barrier）的禁止重排效果组合，它可以对内存屏障前的任意读/写操作和当前内存屏障后的任意读/写操作禁止重排。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第三章 JCF中的Map集合</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84map%E9%9B%86%E5%90%88/</link>
        <pubDate>Mon, 22 Aug 2022 14:48:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84map%E9%9B%86%E5%90%88/</guid>
        <description>&lt;h1 id=&#34;第三章-jcf中的map集合&#34;&gt;第三章 JCF中的Map集合&lt;/h1&gt;
&lt;p&gt;JCF中的Map集合和Set集合之间存在非常密切的关联关系，从相应集合的命名可以看出来，如HashMap集合和HashSet集合、TreeMap集合和TreeSet集合、LinkedHashMap集合和LinkedHashSet集合、ConcurrentSkipListSet集合和ConcurrentSkipListMap集合。因此，如果搞清楚了JCF中的Map集合结构，就基本搞清楚了JCF中的Set集合结构。本书首先介绍JCF中具有代表性的Map集合，然后在此基础上针对性地介绍Set集合。&lt;/p&gt;
&lt;p&gt;TreeMap集合是基于红黑树结构构造的，HashMap集合和LinkedHashMap集合是基于数组+链表+红黑树的复合结构构造的，这两种集合的区别仅体现在LinkedHashMap集合中增加了一个虚拟的链表结构。&lt;/p&gt;
&lt;h2 id=&#34;1-javautiimap接口&#34;&gt;1 java.utiI.Map接口&lt;/h2&gt;
&lt;p&gt;java.util.Map接口是JCF中Map集合的顶层接口，它给出了Map体系中的基本操作功能，并且要求下层具体的Map集合对其进行实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;V put(K key, V value);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void clear();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;V get(Object K);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int size();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean isEmpty();&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-javautiisortedmap接口&#34;&gt;2 java.utiI.SortedMap接口&lt;/h2&gt;
&lt;h2 id=&#34;3-javautiinavigabiemap接口&#34;&gt;3 java.utiI.NavigabIeMap接口&lt;/h2&gt;
&lt;h2 id=&#34;4-javautiiabstractmap抽象类&#34;&gt;4 java.utiI.AbstractMap抽象类&lt;/h2&gt;
&lt;p&gt;java.util.AbstractMap抽象类是实现了java.util.Map接口的一个抽象类，主要用于向下层具体的Map集合提供一些默认的功能逻辑，以便减少具体Map集合的构建源码量，从而降低实现具体Map集合的难度。&lt;/p&gt;
&lt;h2 id=&#34;5-treemap&#34;&gt;5 TreeMap&lt;/h2&gt;
&lt;p&gt;TreeMap集合是基于红黑树构建的，其集合内的所有K-V键值对节点都是这棵红黑树上的节点。这些K-V键值对节点的排列顺序主要基于两种逻辑考虑：第一种是基于K-V键值对节点中Key键信息的Hash值，第二种是基于使用者设置的java.util.Comparator接口实现的比较结果。选择哪种排序逻辑取决于TreeMap集合在实例化时使用哪个构造方法。&lt;/p&gt;
&lt;p&gt;【note】这里指的插入这个Map的数据，会根据java.util.Comparator进行排序，并且，当进行元素查找时，是在树上进行查找。而不是按照hash的方式。&lt;/p&gt;
&lt;h2 id=&#34;6-linkedhashmap&#34;&gt;6 LinkedHashMap&lt;/h2&gt;
&lt;p&gt;LinkedHashMap集合继承自HashMap集合，也就是说，前者和后者的基本结构一致。在HashMap集合的基础上，LinkedHashMap集合提供了一个新的特性，用于保证整个集合内部各个节点可以以某种顺序进行遍历（迭代器支持）。&lt;/p&gt;
&lt;p&gt;【note】这里很奇怪。为什么jdk不提供一个ArrayHashMap&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第四章 JCF中的Set集合</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84set%E9%9B%86%E5%90%88/</link>
        <pubDate>Mon, 22 Aug 2022 14:48:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84set%E9%9B%86%E5%90%88/</guid>
        <description>&lt;h1 id=&#34;第四章-jcf中的set集合&#34;&gt;第四章 JCF中的Set集合&lt;/h1&gt;
&lt;p&gt;Set集合中几个重要的接口和抽象类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;java.util.SortedSet接口&lt;/p&gt;
&lt;p&gt;如果某个具体的Set集合实现了java.util.SortedSet接口，就表示该集合中的数据对象会按照某种比较方法进行全局性的有序排列。实现了java.util.SortedSet接口的集合都提供了以下两种比较方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用一个实现了Comparable接口的类的对象进行比较。这个对象来源于集合中K-V键值对节点的Key键信息。&lt;/li&gt;
&lt;li&gt;通过在集合实例化时设置的Comparator比较器进行比较。如果要采用这种方法，那么Set集合需要实现java.util.SortedSet接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java.util.NavigableSet接口&lt;/p&gt;
&lt;p&gt;java.util.NavigableSet接口是java.util.SortedSet接口的子级接口，可以将其理解成支持基于参照对象进行引导操作的Set集合。也就是说，在满足集合中对象有序组织的前提下，可以参照指定的数据对象进行集合中各数据对象的读/写操作。例如，可以参照集合中已有的数据对象X，查询集合中所有值小于或等于该数据对象X权值的数据对象。保证基于参照数据对象进行引导操作的前提是集合中的数据对象按照一定的顺序排列，这也就解释了为什么java.util.NavigableSet接口是java.util.SortedSet接口的一个子级接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java.util.AbstractSet抽象类&lt;/p&gt;
&lt;p&gt;java.util.AbstractSet抽象类存在的意义和java.util.AbstractMap抽象类存在的意义相似，主要是为了有效降低具体的Set集合的实现复杂度。该抽象类提供了一些通用方法的实现逻辑，包括equals()方法、hashCode()方法、removeAll()方法（在一般情况下，不需要在具体集合中对这些方法进行改动）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-hashset&#34;&gt;1 HashSet&lt;/h2&gt;
&lt;h2 id=&#34;2-linkedhashset&#34;&gt;2 LinkedHashSet&lt;/h2&gt;
&lt;h2 id=&#34;3-treeset&#34;&gt;3 TreeSet&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>第五章 Object Monitor管程实现</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-object-monitor%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Mon, 22 Aug 2022 14:48:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-object-monitor%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;h1 id=&#34;第五章-object-monitor管程实现&#34;&gt;第五章 Object Monitor管程实现&lt;/h1&gt;
&lt;p&gt;为了在不同场景中保证多线程工作的安全性，Java主要基于两种思想进行线程安全性的设计：悲观锁思想和乐观锁思想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;悲观锁
&lt;ul&gt;
&lt;li&gt;在任何时候都会有其他操作者同时要求操作资源，从而产生操作冲突。&lt;/li&gt;
&lt;li&gt;如果没有绝对安全的资源独占前提，那么对资源的操作一定会出现问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乐观锁
&lt;ul&gt;
&lt;li&gt;并不是任何时候都有两个或多个操作者同时操作相同的资源，从而产生操作冲突。&lt;/li&gt;
&lt;li&gt;即使操作结果存在错误也没有关系。可以通过对比预期值和实际值来确认操作的正误，如果出现错误，则放弃本次操作，重新操作即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;悲观锁在Java中有两种典型的实现方式，一种是基于Object Monitor模式的资源操作方式，另一种是基于AQS技术的资源操作方式。&lt;/p&gt;
&lt;p&gt;Java中的乐观锁思想通常基于CAS（Compare and Swap，比较与交换）技术实现，但CAS进行比较的判定依据及比较后是否要进行重试，往往由操作者自行决定。所以在Java中，基于乐观锁工作的工具类都存在类似于for(;;)或while(true)的源码结构，这并不是BUG，而是为了匹配乐观锁的实现思想。&lt;/p&gt;
&lt;h2 id=&#34;1-object-monitor&#34;&gt;1 Object Monitor&lt;/h2&gt;
&lt;p&gt;Object Monitor模式是一种典型的悲观锁实现，使用Java对象模型中的特定区域对线程状态、对象状态的描述进行线程操作。&lt;/p&gt;
&lt;p&gt;所以Object Monitor模式并没有禁止指令重排，虽然有内存屏障控制synchronized代码块的重排特征（内存屏障的知识点会在后续讲解volatile修饰符时讲解），但synchronized代码块中的代码并没有禁止指令重排操作。&lt;/p&gt;
&lt;p&gt;虽然synchronized修饰符没有禁止源码在编译时的指令重排操作，但由于Object Monitor模式已经实现了在获取对象独占操作权的情况下，最多存在一个线程能够顺序执行，因此无论如何设计基于happens-before规则的JMM工作过程，单线程下的as-if-serial语义原则都可以得到保证。也就是说，Object Monitor模式将有序性问题的解决过程，简化成了在保证原子性的前提下，单线程遵循as-if-serial语义规则的执行过程，从而实现禁止与指令重排操作相似的效果。&lt;/p&gt;
&lt;h2 id=&#34;2-和同步块控制有关的对象结构&#34;&gt;2 和同步块控制有关的对象结构&lt;/h2&gt;
&lt;p&gt;在HotSpot JVM的工作区中将对象结构分为3个区域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象头（Header）：实现Object Monitor管程控制模式的关键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Markword：运行时数据&lt;/p&gt;
&lt;p&gt;在64位JVM中，该区域在未压缩时占据对象头区域中的8字节，共64位，主要用于存储对象在运行时的数据，并且记录对象当前锁机制的相关信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Klass：元数据指针&lt;/p&gt;
&lt;p&gt;是一个指针区域，这个指针区域指向元数据区中（JDK 1.8+）该对象所代表的类，这样JVM才知道这个对象是哪个类的实例，在未压缩时为8字节，共64位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Length：数组对象的数组长度&lt;/p&gt;
&lt;p&gt;（只有数组形式的对象会有这个区域）：如果一个对象是数组，那么这个区域表示数组长度，在未压缩时为8字节，共64位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象实际数据（Instance Data）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data：对象/数组对象的实际数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对齐区（可能存在）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Padding：对象填充区域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象头（Header）：对象头是本节重点讨论的部分，在不同操作系统中、不同JVM配置（如是否开启指针压缩）下，对象头的结构不完全一致。为了便于讲解，本书讨论64位JDK在64位操作系统中的内部结构（不考虑对象压缩）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象实际数据：这个区域主要用于描述真实的对象数据，包括对象中的所有成员的属性信息，如其他对象的地址引用、基础数据类型的数据值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对齐区（Padding）：对齐区并不是必须存在的，它最大的作用是占位，因为HotSpot JVM要求被管理的对象的大小是8字节的整数倍，在某些情况下，需要对不足的对象区域进行填充。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们重点讨论和synchronized代码块加锁过程有关的Markword区域，首先说明以下两点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象的锁状态不同，Markword区域的存储结构不同。例如，在对象处于轻量级锁状态的情况下，Markword区域的存储结构是一种；在对象处于偏向锁状态的情况下，Markword区域的存储结构是另一种。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Markword区域在64位JVM中和在32位JVM中的结构长度不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序员在Object Monitor模式下协调多个线程抢占同一个对象的独占操作权，就是通过改变该对象Markword区域中的数据实现的。线程在Object Monitor模式下的执行过程中，为了尽可能保证操作性能，对象的Markword区域还涉及一个锁机制的升级过程（又称为锁膨胀过程），升级顺序为偏向锁→轻量级锁→重量级锁。需要注意的是，偏向锁在JDK 15中已经确认被去掉。&lt;/p&gt;
&lt;p&gt;偏向锁实际上是在没有多个线程抢占指定对象独占操作权的情况下，完全取消对这个对象独占操作权的抢占工作。当前唯一请求对象独占操作权的线程，其线程ID会被对象记录到对象头的Markword区域中（使用CAS技术更新记录）。如果一直没有出现其他线程抢占对象独占操作权的情况，那么在当前synchronized代码块中基本不会出现针对独占权抢占工作的额外处理。&lt;/p&gt;
&lt;h2 id=&#34;3-锁粗化和锁消除&#34;&gt;3 锁粗化和锁消除&lt;/h2&gt;
&lt;h2 id=&#34;4-object-monitor模式的控制结构&#34;&gt;4 Object Monitor模式的控制结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Entry Set&lt;/p&gt;
&lt;p&gt;第一个控制象限为待进入synchronized代码块的区域（Entry Set），停留在这个区域内的线程还没有获得对象的独占操作权，因此仍然停留在synchronized代码块外，即代码“synchronized(Object)”的位置。处于Entry Set区域内的线程，其线程状态被标识为BLOCKED&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Owner&lt;/p&gt;
&lt;p&gt;第二个控制象限为对象独占操作权持有区域（Owner），在对象的Object Monitor模式下，在同一时间最多有一个线程处于这个区域内，所以Object Monitor模式就会出现同一时间只能有一个线程在synchronize代码块内执行的效果。当前持有对象独占操作权的线程互斥量会被记录到该对象的对象头中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait Set&lt;/p&gt;
&lt;p&gt;第三个象限为待授权区域（Wait Set），没有退出synchronized代码块，并且暂时没有对象独占操作权的线程会被放置到该区域内。注意对象独占操作权和抢占权之间的关系：如果某个线程使用wait()等方法释放了对象的独占操作权，那么只要这个线程没有退出synchronized代码块，在未来就有权被通知重新参与对象独占操作权的抢占工作。并不是处于待授权区域（Wait Set）的线程都可以重新参与对象独占操作权的抢占工作，只有使用notify()方法或类似方法被通知转移的线程才可以参与。需要注意的是，每个对象的Object Monitor模式检查过程相对独立，但是一个线程可以同时拥有一个或多个对象的独占操作权。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-as-if-serial语义原则与happens-before规则&#34;&gt;5 as-if-serial语义原则与happens-before规则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;as-if-seriaI语义原则&lt;/p&gt;
&lt;p&gt;如果进行重排，则会使单线程内的执行结果发生错误。这样的执行原则称为as-if-serial语义原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;happens-before规则&lt;/p&gt;
&lt;p&gt;线程安全的三性要求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第一章 JCF中的List集合</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84list%E9%9B%86%E5%90%88/</link>
        <pubDate>Wed, 17 Aug 2022 10:14:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6jcf%E5%92%8Cjuc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%93%B6%E6%96%87%E6%9D%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-jcf%E4%B8%AD%E7%9A%84list%E9%9B%86%E5%90%88/</guid>
        <description>&lt;h1 id=&#34;第一章--jcf中的list集合&#34;&gt;第一章  JCF中的List集合&lt;/h1&gt;
&lt;h2 id=&#34;1-list集合概要和重要接口介绍&#34;&gt;1 List集合概要和重要接口介绍&lt;/h2&gt;
&lt;p&gt;JCF中的List集合涉及的部分重要接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;java.util.ArrayList&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java.util.LinkedList&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java.util.Vector&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java.util.Stack&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中java.util.Stack继承自java.util.Vector。不过在jdk1.7+已经推荐使用性能更好的java.util.ArrayDeque集合作为替代方案。&lt;/p&gt;
&lt;p&gt;要理解java.util包中关于java.util.List接口的重要实现类，需要理清楚其涉及的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主要接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;java.lang.Iterable (可迭代接口)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java.util.Collection(集合接口)&lt;/p&gt;
&lt;p&gt;有些集合类，并不一定会实现这个接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要抽象类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;java.util.AbstractList(抽象列表)&lt;/p&gt;
&lt;p&gt;支持随机访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;java.util.AbstractSequentialList(抽象连续列表)&lt;/p&gt;
&lt;p&gt;不支持随机访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在JCF中，可以根据List集合在各维度表现出来的工作特点对其进行分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否支持随机访问&lt;/li&gt;
&lt;li&gt;数据是否支持修改&lt;/li&gt;
&lt;li&gt;集合容量是否可变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【插入】标识接口：是指Java中用于标识某个类是否具备某种操作特性、功能类型的接口。标识接口通常不需要下层类实现任何方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.util.RandomAccess&lt;/li&gt;
&lt;li&gt;java.lang.Cloneable&lt;/li&gt;
&lt;li&gt;java.io.Serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;java.util.ArrayList、java.util.Vector集合和java.util.concurrent.CopyOnWriteArrayList集合都实现了java.util.RandomAccess接口，表示它们支持集合中数据对象的随机访问。实现java.util.RandomAccess接口的还有很多第三方类库，如一些厂商封装的JSON工具中的JSONArray类。这些实现了java.util.RandomAccess标识接口的List集合在工作时也会被区别对待。&lt;/p&gt;
&lt;p&gt;JDK14+ instanceof 模式匹配 Girraffe&lt;/p&gt;
&lt;p&gt;LinkedList集合的内部结构是一个双向链表，要寻找链表中某个索引位上的数据对象，只能从头部或尾部依次查询.&lt;/p&gt;
&lt;h2 id=&#34;2-vector&#34;&gt;2 Vector&lt;/h2&gt;
&lt;p&gt;Vector集合的工作特性除了支持数据对象的随机访问，还有集合的大小可变、保证线程安全的运行环境&lt;/p&gt;
&lt;h2 id=&#34;3-arraylist&#34;&gt;3 ArrayList&lt;/h2&gt;
&lt;p&gt;ArrayList集合是JCF中非常重要的集合之一，也是实际工作中最常使用的集合之一。ArrayList集合拥有与Vector集合类似的接口和操作逻辑（从JDK 1.2开始提供），但它不支持线程安全操作（Vector集合支持线程安全操作，但是基于线程安全的多线程操作性能不高）。ArrayList集合也支持随机访问，也就是说，ArrayList集合在单线程下对指定索引位上的数据读取操作的时间复杂度为O(1)。&lt;/p&gt;
&lt;p&gt;ArrayList集合是程序员在单线程操作场景中最常使用的List集合之一。该集合的内部结构是一个数组，并且这个数组在需要的时候可以进行扩容操作，所以理论上ArrayList集合能存储任意数量的数据对象（但实际上受各种客观因素限制而无法实现）。ArrayList集合允许将数据对象添加到数组的任意有效索引位上，并且允许从数组的任意有效索引位上获取数据对象。&lt;/p&gt;
&lt;h3 id=&#34;31-集合内部结构&#34;&gt;3.1 集合内部结构&lt;/h3&gt;
&lt;p&gt;ArrayList集合中数组的默认初始化容量值也为10，也可以指定集合中数组的初始化容量值，但如果使用者没有指定初始化容量值，那么ArrayList集合中的elementData数组会被初始化为一个容量值为0的空数组。&lt;/p&gt;
&lt;h3 id=&#34;32-扩容逻辑&#34;&gt;3.2 扩容逻辑&lt;/h3&gt;
&lt;p&gt;ArrayList集合在进行扩容操作时会将当前容量增大50%，并且扩容逻辑不能干预，除非扩容前容量值小于10（如果发生这样的情况，则首先扩容到10）。ArrayList集合的扩容逻辑相对动态，这保证了在扩容操作频率和扩容大小之间更好的平衡性。&lt;/p&gt;
&lt;h2 id=&#34;4-stack&#34;&gt;4 Stack&lt;/h2&gt;
&lt;p&gt;顾名思义，Stack集合的工作效果符合栈结构的定义。栈结构是指能使集合中的数据对象具有后进先出（LIFO）操作特性的集合结构。Stack集合同样有线程安全操作特性（但同样不适合在高并发场景中使用），Stack集合的扩容增量通常也是当前容量的1倍；Stack集合也不会对集合的序列化过程和反序列化过程进行特殊优化处理。&lt;/p&gt;
&lt;h2 id=&#34;5-linkedlist&#34;&gt;5 LinkedList&lt;/h2&gt;
&lt;p&gt;java.util.LinkedList集合是本书讲解的最后一种主要的List集合，也是本书讲解的第一种Queue集合。换句话说，LinkedList集合同时具有List集合和Queue集合的基本特性。&lt;/p&gt;
&lt;p&gt;LinkedList集合的主要结构是双向链表。双向链表中的节点不要求有连续的内存存储地址，因此在向双向链表中插入新节点时，无须申请一块连续的存储空间，只需按需申请存储空间。LinkedList集合中的链表的每个节点都使用一个java.util.LinkedList.Node类的对象进行描述。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
