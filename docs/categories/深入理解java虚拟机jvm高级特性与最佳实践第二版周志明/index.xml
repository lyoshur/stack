<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）（周志明） on 羡鱼先生的空间</title>
        <link>https://lyoshur.github.io/stack/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E/</link>
        <description>Recent content in 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）（周志明） on 羡鱼先生的空间</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 18 Aug 2022 11:05:00 +0000</lastBuildDate><atom:link href="https://lyoshur.github.io/stack/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>第3章 垃圾收集器与内存分配策略</title>
        <link>https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
        <pubDate>Thu, 18 Aug 2022 11:05:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
        <description>&lt;h1 id=&#34;第3章-垃圾收集器与内存分配策略&#34;&gt;第3章 垃圾收集器与内存分配策略&lt;/h1&gt;
&lt;p&gt;说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那些内存需要回收&lt;/li&gt;
&lt;li&gt;如何回收&lt;/li&gt;
&lt;li&gt;什么时候回收&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-那些内存需要回收&#34;&gt;1 那些内存需要回收&lt;/h2&gt;
&lt;h3 id=&#34;11-引用计数算法reference-counting&#34;&gt;1.1 引用计数算法（Reference Counting）&lt;/h3&gt;
&lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。&lt;/p&gt;
&lt;h3 id=&#34;12-可达性分析算法&#34;&gt;1.2 可达性分析算法&lt;/h3&gt;
&lt;p&gt;这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。&lt;/p&gt;
&lt;h3 id=&#34;13-强引用strong-reference软引用soft-reference弱引用weak-reference虚引用phantom-reference&#34;&gt;1.3 强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）&lt;/h3&gt;
&lt;p&gt;在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-回收方法区&#34;&gt;1.4 回收方法区&lt;/h3&gt;
&lt;p&gt;很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。&lt;/p&gt;
&lt;h2 id=&#34;2-如何回收&#34;&gt;2 如何回收&lt;/h2&gt;
&lt;h3 id=&#34;21-垃圾收集算法&#34;&gt;2.1 垃圾收集算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标记-清除算法&lt;/p&gt;
&lt;p&gt;最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制算法(新生代)&lt;/p&gt;
&lt;p&gt;最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;
&lt;p&gt;现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[插图]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记整理算法(老年代)&lt;/p&gt;
&lt;p&gt;复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-何时回收&#34;&gt;3 何时回收&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安全点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全区&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-垃圾收集器&#34;&gt;4 垃圾收集器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Serial收集器&lt;/p&gt;
&lt;p&gt;Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。&lt;/p&gt;
&lt;p&gt;它依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ParNew收集器&lt;/p&gt;
&lt;p&gt;ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parallel Scavenge收集器&lt;/p&gt;
&lt;p&gt;不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作&lt;/p&gt;
&lt;p&gt;Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 +垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Serial Old收集器&lt;/p&gt;
&lt;p&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parallel Old收集器&lt;/p&gt;
&lt;p&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CMS收集器&lt;/p&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G1收集器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第4章 虚拟机性能监控与故障处理工具</title>
        <link>https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</link>
        <pubDate>Thu, 18 Aug 2022 11:05:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
        <description>&lt;h1 id=&#34;第4章-虚拟机性能监控与故障处理工具&#34;&gt;第4章 虚拟机性能监控与故障处理工具&lt;/h1&gt;
&lt;h2 id=&#34;1-jdk的命令行工具&#34;&gt;1 JDK的命令行工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;jps：虚拟机进程状况工具&lt;/li&gt;
&lt;li&gt;jstat：虚拟机统计信息监视工具&lt;/li&gt;
&lt;li&gt;jinfo：Java配置信息工具&lt;/li&gt;
&lt;li&gt;jmap：Java内存映像工具&lt;/li&gt;
&lt;li&gt;jhat：虚拟机堆转储快照分析工具&lt;/li&gt;
&lt;li&gt;jstack：Java堆栈跟踪工具&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第二章 自动内存管理机制</title>
        <link>https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Thu, 18 Aug 2022 11:05:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAjvm%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%BA%8C%E7%89%88%E5%91%A8%E5%BF%97%E6%98%8E-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;h1 id=&#34;第二章-自动内存管理机制&#34;&gt;第二章 自动内存管理机制&lt;/h1&gt;
&lt;p&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。&lt;/p&gt;
&lt;h2 id=&#34;1-运行时数据区域&#34;&gt;1 运行时数据区域&lt;/h2&gt;
&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟机栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地方法栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序计数器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;11--运行时常量池runtime-constant-pool&#34;&gt;1.1  运行时常量池（Runtime Constant Pool）&lt;/h3&gt;
&lt;p&gt;运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。&lt;/p&gt;
&lt;h3 id=&#34;12-直接内存&#34;&gt;1.2 直接内存&lt;/h3&gt;
&lt;p&gt;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。&lt;/p&gt;
&lt;p&gt;在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。&lt;/p&gt;
&lt;p&gt;显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。&lt;/p&gt;
&lt;h2 id=&#34;2-对象的创建&#34;&gt;2 对象的创建&lt;/h2&gt;
&lt;p&gt;虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。&lt;/p&gt;
&lt;p&gt;在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。&lt;/p&gt;
&lt;p&gt;两种分配方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;“指针碰撞”（Bump the Pointer）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“空闲列表”（Free List）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-对象的内存布局&#34;&gt;2.1 对象的内存布局&lt;/h3&gt;
&lt;p&gt;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象头&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表2-1。&lt;/p&gt;
&lt;p&gt;对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对其填充&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。&lt;/p&gt;
&lt;h3 id=&#34;22-对象的访问定位&#34;&gt;2.2 对象的访问定位&lt;/h3&gt;
&lt;p&gt;建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息&lt;/li&gt;
&lt;li&gt;果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。&lt;/p&gt;
&lt;p&gt;使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的.&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
