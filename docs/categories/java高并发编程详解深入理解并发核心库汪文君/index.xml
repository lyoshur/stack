<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Java高并发编程详解：深入理解并发核心库（汪文君） on 羡鱼先生的空间</title>
        <link>https://lyoshur.github.io/stack/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B/</link>
        <description>Recent content in Java高并发编程详解：深入理解并发核心库（汪文君） on 羡鱼先生的空间</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 17 Aug 2022 10:14:00 +0000</lastBuildDate><atom:link href="https://lyoshur.github.io/stack/categories/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>第二章 Java并发包之原子类型详解</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Wed, 17 Aug 2022 10:14:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
        <description>&lt;h1 id=&#34;第二章-java并发包之原子类型详解&#34;&gt;第二章 Java并发包之原子类型详解&lt;/h1&gt;
&lt;h2 id=&#34;1-atomicinteger详解&#34;&gt;1 AtomicInteger详解&lt;/h2&gt;
&lt;p&gt;AtomicInteger有两个构造，无参构造，初始值为0；以及带初始值的构造。&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;void set(int newValue)：为AtomicInteger的value设置一个新值，通过对前面内容的学习，我们知道在AtomicInteger中有一个被volatile关键字修饰的value成员属性，因此调用set方法为value设置新值后其他线程就会立即看见&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void lazySet(int newValue)：set方法修改被volatile关键字修饰的value值会被强制刷新到主内存中，从而立即被其他线程看到，这一切都应该归功于volatile关键字底层的内存屏障。内存屏障虽然足够轻量，但是毕竟还是会带来性能上的开销，比如，在单线程中对AtomicInteger的value进行修改时没有必要保留内存屏障，而value又是被volatile关键字修饰的，这似乎是无法调和的矛盾。幸好追求性能极致的JVM开发者们早就考虑到了这一点，lazySet方法的作用正在于此&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int getAndIncrement()  i++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int incrementAndGet() ++i&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int getAndDecrement() i&amp;ndash;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int decrementAndGet() &amp;ndash;i&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean compareAndSet(int expect, int update)&lt;/p&gt;
&lt;p&gt;其中expect代表当前的AtomicInteger数值，update则是需要设置的新值，该方法会返回一个boolean的结果：当expect和AtomicInteger的当前值不相等时，修改会失败，返回值为false；若修改成功则会返回true&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int getAndAdd(int delta)&lt;/p&gt;
&lt;p&gt;原子性地更新AtomicInteger 的value值，更新后的value为value和delta之和&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int addAndGet(int delta)&lt;/p&gt;
&lt;p&gt;类似 i++和++i的区别&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自JDK1.8增加了函数式接口之后，AtomicInteger也提供了对函数式接口的支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int getAndUpdate(IntUnaryOperator updateFunction)：原子性地更新AtomicInteger的值，方法入参为IntUnaryOperator接口，返回值为value更新之前的值。&lt;/li&gt;
&lt;li&gt;int updateAndGet(IntUnaryOperator updateFunction)：原子性地更新AtomicInteger的值，方法入参为IntUnaryOperator接口，该方法会立即返回更新后的value值&lt;/li&gt;
&lt;li&gt;int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)：原子性地更新AtomicInteger的值，方法入参为IntBinaryOperator接口和delta值x，返回值为value更新之前的值&lt;/li&gt;
&lt;li&gt;int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)：该方法与getAndAccumulate类似，只不过会立即返回AtomicInteger的更新值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-atomicinteger内幕&#34;&gt;2 AtomicInteger内幕&lt;/h2&gt;
&lt;p&gt;Unsafe是由C++实现的，其内部存在着大量的汇编 CPU指令等代码，JDK实现的 Lock Free几乎完全依赖于该类&lt;/p&gt;
&lt;p&gt;【note】openjdk-jdk8u/hotspot/src/share/vm/prims/unsafe.cpp / openjdk-jdk8u/hotspot/src/os_cpu/bsd_x86/vm/atomic_bsd_x86.inline.hpp&lt;/p&gt;
&lt;p&gt;文件我们会找到相关的C++代码文件。java通过调用unsafe.cpp定义的方法，来完成cas操作，根本实现在和CPU相关的atomic_bsd_x86.inline.hpp中，里面会调用不同CPU架构下的汇编代码。&lt;/p&gt;
&lt;h2 id=&#34;3-atomicboolean详解&#34;&gt;3 AtomicBoolean详解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;get()：获取AtomicBoolean的当前布尔值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set(boolean newValue)：设置AtomicBoolean最新的value值，该新值的更新对其他线程立即可见&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lazySet(boolean newValue)：设置AtomicBoolean的布尔值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getAndSet(boolean newValue)：返回AtomicBoolean的前一个布尔值，并且设置新的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compareAndSet(boolean expect, boolean update)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;weakCompareAndSet(boolean expect, boolean update)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4trylock显式锁的实现&#34;&gt;4TryLock显式锁的实现&lt;/h2&gt;
&lt;p&gt;类保存两个变量，一个AtomicBoolean，一个ThreadLocal&lt;!-- raw HTML omitted --&gt;。使用AtomicBoolean来进行cas，判断当前线程能否拿到锁。ThreadLocal用来存储当前线程是否拿到锁。&lt;/p&gt;
&lt;p&gt;两个方法 tryLock 和 release。&lt;/p&gt;
&lt;h2 id=&#34;5-atomiclong详解&#34;&gt;5 AtomicLong详解&lt;/h2&gt;
&lt;p&gt;相对于compareAndSwapInt方法，在unsafe.cpp中，compareAndSwapLong方法多了条件编译SUPPORTS_NATIVE_CX8。SUPPORTS_NATIVE_CX8主要用于判断机器硬件是否支持8字节数字的cmpxchg CPU指令，如果机器硬件不支持，比如32位的CPU肯定不支持8字节64位数字的cmpxchg CPU指令，那么此时就需要判断当前JVM版本是否支持8字节数字的cmpxchg操作；如果机器硬件与当前JVM的版本都不支持，那么实际上针对long型数据的原子性操作将不会是Lock Free的，而是需要采用加锁的方式确保原子性。&lt;/p&gt;
&lt;h2 id=&#34;6-atomicreference详解&#34;&gt;6 AtomicReference详解&lt;/h2&gt;
&lt;p&gt;AtomicReference类提供了对象引用的非阻塞原子性读写操作，并且提供了其他一些高级的用法。众所周知，对象的引用其实是一个4字节的数字，代表着在JVM堆内存中的引用地址。&lt;/p&gt;
&lt;p&gt;我们使用AtomicReference封装对象引用，每一次对AtomicReference的更新操作，我们都采用CAS这一乐观非阻塞的方式进行，因此也会存在对DebitCard对象引用更改失败的问题。CAS算法在此处就是要确保接下来要修改的对象引用是基于当前线程刚才获取的对象引用，否则更新将直接失败。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get()：获取AtomicReference的当前对象引用值&lt;/li&gt;
&lt;li&gt;set(V newValue)：设置AtomicReference最新的对象引用值，该新值的更新对其他线程立即可见&lt;/li&gt;
&lt;li&gt;lazySet(V newValue)：设置AtomicReference的对象引用值&lt;/li&gt;
&lt;li&gt;getAndSet(V newValue)：原子性地更新AtomicReference内部的value值，并且返回AtomicReference的旧值&lt;/li&gt;
&lt;li&gt;compareAndSet(V expect, V update)：原子性地更新AtomicReference内部的value值，其中expect代表当前AtomicReference的value值，update则是需要设置的新引用值。该方法会返回一个boolean的结果，当expect和AtomicReference的当前值不相等时，修改会失败，返回值为false，若修改成功则会返回true&lt;/li&gt;
&lt;li&gt;getAndUpdate(UnaryOperator&lt;!-- raw HTML omitted --&gt; updateFunction)：原子性地更新value值，并且返回AtomicReference的旧值，该方法需要传入一个Function接口&lt;/li&gt;
&lt;li&gt;updateAndGet(UnaryOperator&lt;!-- raw HTML omitted --&gt; updateFunction)：原子性地更新value值，并且返回AtomicReference更新后的新值，该方法需要传入一个Function接口&lt;/li&gt;
&lt;li&gt;getAndAccumulate(V x, BinaryOperator&lt;!-- raw HTML omitted --&gt; accumulatorFunction)：原子性地更新value值，并且返回AtomicReference更新前的旧值。该方法需要传入两个参数，第一个是更新后的新值，第二个是BinaryOperator接口&lt;/li&gt;
&lt;li&gt;accumulateAndGet(V x, BinaryOperator&lt;!-- raw HTML omitted --&gt; accumulatorFunction)：原子性地更新value值，并且返回AtomicReference更新后的值。该方法需要传入两个参数，第一个是更新的新值，第二个是BinaryOperator接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-atomicstampedreference详解&#34;&gt;7 AtomicStampedReference详解&lt;/h2&gt;
&lt;p&gt;截至目前我们已经学习了AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference这些原子类型，它们无一例外都采用了基于volatile关键字+CAS算法无锁的操作方式来确保共享数据在多线程操作下的线程安全性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;volatile关键字保证了线程间的可见性，当某线程操作了被volatile关键字修饰的变量，其他线程可以立即看到该共享变量的变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CAS算法，即对比交换算法，是由UNSAFE提供的，实质上是通过操作CPU指令来得到保证的。CAS算法提供了一种快速失败的方式，当某线程修改已经被改变的数据时会快速失败&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何避免CAS算法带来的ABA问题呢？针对乐观锁在并发情况下的操作，我们通常会增加版本号，比如数据库中关于乐观锁的实现方式，以此来解决并发操作带来的ABA问题。在Java原子包中也提供了这样的实现AtomicStampedReference&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;p&gt;AtomicStampedReference在构建的时候需要一个类似于版本号的int类型变量stamped，每一次针对共享数据的变化都会导致该stamped的增加（stamped的自增维护需要应用程序自身去负责，AtomicStampedReference并不提供），因此就可以避免ABA问题的出现，AtomicStampedReference的使用也是极其简单的，创建时我们不仅需要指定初始值，还需要设定stamped的初始值，在AtomicStampedReference的内部会将这两个变量封装成Pair对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getReference()：获取当前引用值，等同于其他原子类型的get方法&lt;/li&gt;
&lt;li&gt;getStamp()：获取当前引用值的stamp数值&lt;/li&gt;
&lt;li&gt;V get(int[] stampHolder)：这个方法的意图是获取当前值以及stamp值，但是Java不支持多值的返回，并且在AtomicStampedReference内部Pair被定义为私有的，因此这里就采用了传参的方式来解决（个人觉得这样的方法设计不算优雅，作者如果不想暴露Pair，完全可以再定义一个专门用于返回value和stamp对的public对象）&lt;/li&gt;
&lt;li&gt;compareAndSet(V expectedReference, V newReference,int expectedStamp, int newStamp)：对比并且设置当前的引用值，这与其他的原子类型CAS算法类似，只不过多了expectedStamp和newStamp，只有当expectedReference与当前的Reference相等，且expectedStamp与当前引用值的stamp相等时才会发生设置，否则set动作将会直接失败&lt;/li&gt;
&lt;li&gt;weakCompareAndSet (V expectedReference, V newReference, int expectedStamp, int newStamp)：同上&lt;/li&gt;
&lt;li&gt;set(V newReference, int newStamp)：设置新的引用值以及stamp&lt;/li&gt;
&lt;li&gt;attemptStamp(V expectedReference, int newStamp)：该方法的主要作用是为当前的引用值设置一个新的stamp，该方法为原子性方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;熟悉数据库开发的朋友肯定知道在多线程或者多系统中，同时对数据库的某条记录进行更改的时候，我们一般是采用乐观锁的方式，即为该记录增加版本号字段，比如如下的更新操作，其实AtomicStampedReference的实现原理也是这样的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;UPDATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TAB&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;AND&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expectedVersion&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;8-atomicarray详解&#34;&gt;8 AtomicArray详解&lt;/h2&gt;
&lt;p&gt;在Java原子包中提供了相应的原子性操作数组元素相关的类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AtomicIntegerArray：提供了原子性操作int数据类型数组元素的操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AtomicLongArray：提供了原子性操作long数据类型数组元素的操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AtomicReferenceArray：提供了原子性操作对象引用数组元素的操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-atomicfieldupdater详解&#34;&gt;9 AtomicFieldUpdater详解&lt;/h2&gt;
&lt;p&gt;在Java的原子包中提供了三种原子性更新对象属性的类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AtomicIntegerFieldUpdater：原子性地更新对象的int类型属性，该属性无须被声明成AtomicInteger&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AtomicLongFieldUpdater：原子性地更新对象的long类型属性，该属性无须被声明成AtomicLong&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AtomicReferenceFieldUpdater：原子性地更新对象的引用类型属性，该属性无须被声明成AtomicReference&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;AtomicIntegerFieldUpdater&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Alex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;updater&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AtomicIntegerFieldUpdater&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newUpdater&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Alex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;salary&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;updater&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addAndGet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意事项：AtomicFieldUpdater在使用上非常简单，其内部实现原理也是很容易理解的，但是并不是所有的成员属性都适合被原子性地更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未被volatile关键字修饰的成员属性无法被原子性地更新&lt;/li&gt;
&lt;li&gt;类变量无法被原子性地更新&lt;/li&gt;
&lt;li&gt;无法直接访问的成员属性不支持原子性地更新&lt;/li&gt;
&lt;li&gt;final修饰的成员属性无法被原子性地更新&lt;/li&gt;
&lt;li&gt;父类的成员属性无法被原子性地更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-sunmiscunsafe详解&#34;&gt;10 sun.misc.Unsafe详解&lt;/h2&gt;
&lt;p&gt;Java是一种安全的开发语言，Java的设计者在设计之初就想将一些危险的操作屏蔽掉。比如对内存的手动管理，但是本章所学习的原子类型，甚至在接下来的章节中将要学习到的并发工具、并发容器等在其底层都依赖于一个特殊的类sun.misc.Unsafe，该类是可以直接对内存进行相关操作的，甚至还可以通过汇编指令直接进行CPU的操作。&lt;/p&gt;
&lt;p&gt;sun.misc.Unsafe提供了非常多的底层操作方法，这些方法更加接近机器硬件（CPU/内存），因此效率会更高。不仅Java本身提供的很多API都对其有严重依赖，而且很多优秀的第三方库/框架都对它有着严重的依赖，比如LMAX Disruptor，不熟悉系统底层，不熟悉C/C++汇编等的开发者没有必要对它进行深究，但是这并不妨碍我们直接使用它。在使用的过程中，如果使用不得当，那么代价将是非常高昂的，因此该类被命名为Unsafe也就在情理之中了，总之一句话，你可以用，但请慎用！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绕过类构造函数完成对象创建&lt;/li&gt;
&lt;li&gt;直接修改内存数据&lt;/li&gt;
&lt;li&gt;类的加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-本章总结&#34;&gt;11 本章总结&lt;/h2&gt;
&lt;p&gt;本章非常详细地讲解了Java原子类型包中的所有原子类型的原理以及用法，原子类型包为我们提供了一种无锁的原子性操作共享数据的方式，无锁的操作方式可以减少线程的阻塞，减少CPU上下文的切换，提高程序的运行效率，但是这并不是一条放之四海皆准的规律，比如，同样被synchronized关键字同步的共享数据和原子类型的数据在单线程运行的情况下，synchronized关键字的效率却要高很多，究其原因是synchronized关键字是由JVM提供的相关指令所保证的，因此在Java程序运行期优化时可以将同步擦除，而原子类是由本地方法和汇编指令来提供保障的，在Java程序运行期间是没有办法被优化的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第三章 java并发包之工具类详解</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%89%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Wed, 17 Aug 2022 10:14:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%B8%89%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AF%A6%E8%A7%A3/</guid>
        <description>&lt;h1 id=&#34;第三章-java并发包之工具类详解&#34;&gt;第三章 java并发包之工具类详解&lt;/h1&gt;
&lt;h2 id=&#34;1-countdownlatch工具详解&#34;&gt;1 CountDownLatch工具详解&lt;/h2&gt;
&lt;p&gt;CountDownLatch使用起来非常简单，但是就是这个简单的工具类，可以帮助我们很优雅地解决主任务等待所有子任务都执行结束之后再进行下一步工作的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CountDownLatch的构造非常简单，需要给定一个不能小于0的int数字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;countDown()方法，该方法的主要作用是使得构造CountDownLatch指定的count计数器减一。如果此时CountDownLatch中的计数器已经是0，这种情况下如果再次调用countDown()方法，则会被忽略，也就是说count的值最小只能为0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;await()方法会使得当前的调用线程进入阻塞状态，直到count为0，当然其他线程可以将当前线程中断。同样，当count的值为0的时候，调用await方法将会立即返回，当前线程将不再被阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;await（long timeout, TimeUnit unit）是一个具备超时能力的阻塞方法，当时间达到给定的值以后，计数器count的值若还大于0，则当前线程会退出阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getCount()方法，该方法将返回CountDownLatch当前的计数器数值，该返回值的最小值为0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-cyclicbarrier工具详解&#34;&gt;2 CyclicBarrier工具详解&lt;/h2&gt;
&lt;p&gt;CyclicBarrier（循环屏障），它也是一个同步助手工具，它允许多个线程在执行完相应的操作之后彼此等待共同到达一个障点（barrier point）。CyclicBarrier也非常适合用于某个串行化任务被分拆成若干个并行执行的子任务，当所有的子任务都执行结束之后再继续接下来的工作。从这一点来看，Cyclic Barrier与CountDownLatch非常类似，但是它们之间的运行方式以及原理还是存在着比较大的差异的，并且CyclicBarrier所能支持的功能CountDownLatch是不具备的。比如，CyclicBarrier可以被重复使用，而CountDownLatch当计数器为0的时候就无法再次利用。&lt;/p&gt;
&lt;p&gt;【note】在构造CyclicBarrier的时候，如果给定一个Runnable作为回调，那么待所有的任务线程都到达barrier point之后，该Runnable接口的run方法将会被调用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int getParties()方法：获取CyclicBarrier在构造时的parties，该值一经CyclicBarrier创建将不会被改变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;await()方法：我们使用最多的一个方法，调用该方法之后，当前线程将会进入阻塞状态，等待其他线程执行await()方法进入barrier point，进而全部退出阻塞状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;await(long timeout, TimeUnit unit)方法：该方法与无参的await方法类似，只不过增加了超时的功能，当其他线程在设定的时间内没有到达barrier point时，当前线程也会退出阻塞状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;isBroken()：返回barrier的broken状态，某个线程由于执行await方法而进入阻塞状态，如果该线程被执行了中断操作，那么isBroken()方法将会返回true&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getNumberWaiting()方法： 该方法返回当前barrier有多少个线程执行了await方法而不是还有多少个线程未到达barrier point，这一点需要注意&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reset()方法：前面已经详细地介绍过这个方法，其主要作用是中断当前barrier，并且重新生成一个generation，还有将barrier内部的计数器count设置为parties值，但是需要注意的是，如果还有未到达barrier point的线程，则所有的线程将会被中断并且退出阻塞，此时isBroken()方法将返回false而不是true&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CyclicBarrier会被broken这一点我们已经通过上面的代码证明过了，但是需要注意如下几点（非常重要）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当一个线程由于在执行CyclicBarrier的await方法而进入阻塞状态时，这个时候对该线程执行中断操作会导致CyclicBarrier被broken&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被broken的CyclicBarrier此时已经不能再直接使用了，如果想要使用就必须使用reset方法对其重置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有其他线程此时也由于执行了await方法而进入阻塞状态，那么该线程会被唤醒并且抛出BrokenBarrierException异常&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cyclicbarrier-vs-countdownlatch&#34;&gt;CyclicBarrier VS. CountDownLatch&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CoundDownLatch的await方法会等待计数器被count down到0，而执行CyclicBarrier的await方法的线程将会等待其他线程到达barrier point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CyclicBarrier内部的计数器count是可被重置的，进而使得CyclicBarrier也可被重复使用，而CoundDownLatch则不能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CyclicBarrier是由Lock和Condition实现的，而CountDownLatch则是由同步控制器AQS（AbstractQueuedSynchronizer）来实现的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在构造CyclicBarrier时不允许parties为0，而CountDownLatch则允许count为0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-exchanger工具详解&#34;&gt;3 Exchanger工具详解&lt;/h2&gt;
&lt;p&gt;Exchanger（交换器），Exchanger简化了两个线程之间的数据交互，并且提供了两个线程之间的数据交换点，Exchanger等待两个线程调用其exchange()方法。调用此方法时，交换机会交换两个线程提供给对方的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public V exchange(V x) throws InterruptedException：数据交换方法，该方法的作用是将数据x交换至搭档线程，执行该方法后，当前线程会进入阻塞状态，只有当搭档线程也执行了exchange方法之后，该当前线程才会退出阻塞状态进行下一步的工作，与此同时，该方法的返回值代表着搭档线程所传递过来的交换数据&lt;/li&gt;
&lt;li&gt;public V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException：该方法的作用与前者类似，只不过增加了超时的功能，也就是说在指定的时间内搭档线程没有执行exchange方法，当前线程会退出阻塞，并且返回值为null&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-semaphore工具详解&#34;&gt;4 Semaphore工具详解&lt;/h2&gt;
&lt;p&gt;Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tryacquire方法&#34;&gt;tryAcquire方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tryAcquire()：尝试获取Semaphore的许可证，该方法只会向Semaphore申请一个许可证，在Semaphore内部的可用许可证数量大于等于1的情况下，许可证将会获取成功，反之获取许可证则会失败，并且返回结果为false。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException：该方法与tryAcquire无参方法类似，同样也是尝试获取一个许可证，但是增加了超时参数。如果在超时时间内还是没有可用的许可证，那么线程就会进入阻塞状态，直到到达超时时间或者在超时时间内有可用的证书（被其他线程释放的证书），或者阻塞中的线程被其他线程执行了中断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean tryAcquire(int permits)：在使用无参的tryAcquire时只会向Semaphore尝试获取一个许可证，但是该方法会向Semaphore尝试获取指定数目的许可证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean tryAcquire(int permits, long timeout, TimeUnit unit)：该方法与第二个方法类似，只不过其可以指定尝试获取许可证数量的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void acquire()：该方法会向Semaphore获取一个许可证，如果获取不到就会一直等待，直到Semaphore有可用的许可证为止，或者被其他线程中断。当然，如果有可用的许可证则会立即返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void acquire(int permits)：该方法会向Semaphore获取指定数量的许可证，如果获取不到就会一直等待，直到Semaphore有可用的相应数量的许可证为止，或者被其他线程中断。同样，如果有可用的permits个许可证则会立即返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void acquireUninterruptibly()：该方法会向Semaphore获取一个许可证，如果获取不到就会一直等待，与此同时对该线程的任何中断操作都会被无视，直到Semaphore有可用的许可证为止。当然，如果有可用的许可证则会立即返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void acquireUninterruptibly(int permits)：该方法会向Semaphore获取指定数量的许可证，如果获取不到就会一直等待，与此同时对该线程的任何中断操作都会被无视，直到Semaphore有可用的许可证为止，或者被其他线程中断。同样，如果有可用的permits个许可证则会立即返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void release()：释放一个许可证，并且在Semaphore的内部，可用许可证的计数器会随之加一，表明当前有一个新的许可证可被使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void release(int permits)：释放指定数量（permits）的许可证，并且在Semaphore内部，可用许可证的计数器会随之增加permits个，表明当前又有permits个许可证可被使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean isFair()：对Semaphore许可证的争抢采用公平还是非公平的方式，对应到内部的实现类为FairSync（公平）和NonfairSync（非公平）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int availablePermits()：当前的Semaphore还有多少个可用的许可证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int drainPermits()：排干Semaphore的所有许可证，以后的线程将无法获取到许可证，已经获取到许可证的线程将不受影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean hasQueuedThreads()：当前是否有线程由于要获取Semaphore许可证而进入阻塞？（该值为预估值。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int getQueueLength()：如果有线程由于获取Semaphore许可证而进入阻塞，那么它们的个数是多少呢？（该值为预估值。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-phaser的基本用法&#34;&gt;5 Phaser的基本用法&lt;/h2&gt;
&lt;p&gt;CountDownLatch可以很好地控制等待多个线程执行完子任务，但是它有一个缺点，那就是内部的计数器无法重置，也就是说CountDownLatch属于一次性的，使用结束后就不能再次使用。CyclicBarrier倒是可以重复使用，但是一旦parties在创建的时候被指定，就无法再改变。Phaser则取百（两）家之所长于一身引入了两者的特性。&lt;/p&gt;
&lt;p&gt;在Phaser中可以有多个Phase（阶段），为了更好地对每一个Phase进行管理和监控，Phaser为每一个Phase都提供了对应的编号，这一点与CyclicBarrier是不一样的，后者更加注重的是循环。CyclicBarrier在所有的线程都到达barrier point之后，它才会重新开始，而Phaser则不然，只要某一个Phase的所有关联parties都arrive（到达）了，它就会从下一个Phase继续开始，除非Phaser本身已经被终止或者销毁。&lt;/p&gt;
&lt;h2 id=&#34;6-lock接口方法&#34;&gt;6 Lock接口方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;lock()方法：尝试获取锁，如果此刻该锁未被其他线程持有，则会立即返回，并且设置锁的hold计数为1；如果当前线程已经持有该锁则会再次尝试申请，hold计数将会增加一个，并且立即返回；如果该锁当前被另外一个线程持有，那么当前线程会进入阻塞，直到获取该锁，由于调用lock方法而进入阻塞状态的线程同样不会被中断，这一点与进入synchronized同步方法或者代码块被阻塞类似&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lockInterruptibly()方法：该方法的作用与前者类似，但是使用该方法试图获取锁而进入阻塞操作的线程则是可被中断的，也就说线程可以获得中断信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tryLock()方法：调用该方法获取锁，无论成功与否都会立即返回，线程不会进入阻塞状态，若成功获取锁则返回true，若获取锁失败则返回false。使用该方法时请务必注意进行结果的判断，否则会出现获取锁失败却仍旧操作共享资源而导致数据不一致等问题的出现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tryLock(long time, TimeUnit unit)方法：该方法与tryLock()方法类似，只不过多了单位时间设置，如果在单位时间内未获取到锁，则返回结果为false，如果在单位时间内获取到了锁，则返回结果为true，同样hold计数也会被设置为1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unlock()方法：当某个线程对锁的使用结束之后，应该确保对锁资源的释放，以便其他线程能够继续争抢，unlock()方法的作用正在于此&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;newCondition()方法：创建一个与该lock相关联的Condition对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-reentrantlock扩展方法&#34;&gt;7 ReentrantLock扩展方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;getHoldCount()方法：查询当前线程在某个Lock上的数量，如果当前线程成功获取了Lock，那么该值大于等于1；如果没有获取到Lock的线程调用该方法，则返回值为0&lt;/li&gt;
&lt;li&gt;isHeldByCurrentThread()方法：判断当前线程是否持有某个Lock，由于Lock的排他性，因此在某个时刻只有一个线程调用该方法返回true&lt;/li&gt;
&lt;li&gt;isLocked()方法：判断Lock是否已经被线程持有&lt;/li&gt;
&lt;li&gt;isFair()方法：创建的ReentrantLock是否为公平锁&lt;/li&gt;
&lt;li&gt;hasQueuedThreads()方法：在多个线程试图获取Lock的时候，只有一个线程能够正常获得，其他线程可能（如果使用tryLock()方法失败则不会进入阻塞）会进入阻塞，该方法的作用就是查询是否有线程正在等待获取锁&lt;/li&gt;
&lt;li&gt;hasQueuedThread(Thread thread)方法：在等待获取锁的线程中是否包含某个指定的线程&lt;/li&gt;
&lt;li&gt;getQueueLength()方法：返回当前有多少个线程正在等待获取锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-readwritelockreentrantreadwritelock详解&#34;&gt;8 ReadWriteLock&amp;amp;ReentrantReadWriteLock详解&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 定义ReadWriteLock锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReadWriteLock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantReadWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 创建读锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;readLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 创建写锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;writeLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;writeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在没有任何写操作的情况下，读锁的效率反倒是最差的，这的确令人感到失望和惊讶，实际上，ReadWriteLock的性能表现确实不尽如人意，这也是在JDK1.8版本中引入StampedLock的原因之一&lt;/p&gt;
&lt;h2 id=&#34;9-condition详解&#34;&gt;9 Condition详解&lt;/h2&gt;
&lt;p&gt;如果说显式锁Lock可以用来替代synchronized关键字，那么Condition接口将会很好地替代传统的、通过对象监视器调用wait()、notify()、notifyAll()线程间的通信方式。Condition对象是由某个显式锁Lock创建的，一个显式锁Lock可以创建多个Condition对象与之关联，Condition的作用在于控制锁并且判断某个条件（临界值）是否满足，如果不满足，那么使用该锁的线程将会被挂起等待另外的线程将其唤醒，与此同时被挂起的线程将会进入阻塞队列中并且释放对显式锁Lock的持有，这一点与对象监视器的wait()方法非常类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;void await() throws InterruptedException：当前线程调用该方法会进入阻塞状态直到有其他线程对其进行唤醒，或者对当前线程执行中断操作。当线程执行了await()方法进入阻塞时；当前线程会被加入到阻塞队列中，并且释放对显式锁的持有，object monitor的wait()方法被执行后同样会加入一个虚拟的容器waitset（线程休息室）中，waitset是一个虚拟的概念，JVM（虚拟机）规范并未强制要求其采用什么样的数据结构，Condition的wait队列则是由Java程序实现的FiFO队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void awaitUninterruptibly()：该方法与await()方法类似，只不过该方法比较固执，它会忽略对它的中断操作，一直等待有其他线程将它唤醒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;long awaitNanos(long nanosTimeout) throws InterruptedException：调用该方法同样会使得当前线程进入阻塞状态，但是可以设定阻塞的最大等待时间，如果在设定的时间内没有其他线程将它唤醒或者被执行中断操作，那么当前线程将会等到设定的纳秒时间后退出阻塞状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean await(long time, TimeUnit unit) throws InterruptedException：执行方法awaitNanos(),如果到达设定的纳秒数则当前线程会退出阻塞，并且返回实际等待的纳秒数，但是程序很难判断线程是否被正常唤醒，因此该方法的作用除了可以指定等待的最大的单位时间，另外，还可以返回在单位时间内被正常唤醒而且还是由于超时而退出的阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean awaitUntil(Date deadline) throws InterruptedException：调用该方法同样会导致当前线程进入阻塞状态直到被唤醒、被中断或者到达指定的Date&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void signal()：唤醒Condition阻塞队列中的一个线程，Condition的wait队列采用FiFO的方式，因此在wait队列中，第一个进入阻塞队列的线程将会被首先唤醒，下面我们来设计一个case对其进行测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;void signalAll()：唤醒Condition wait队列中的所有线程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-stampedlock详解&#34;&gt;10 StampedLock详解&lt;/h2&gt;
&lt;p&gt;StampedLock被JDK1.8版本引入之后，成为了Lock家族的新宠，它几乎具备了ReentrantLock、ReentrantReadWriteLock这两种类型锁的所有功能&lt;/p&gt;
&lt;p&gt;与ReentrantReadWriteLock锁一样，StampedLock也提供了读锁和写锁这两种模式，因此StampedLock天生就支持读写分离锁的使用方式&lt;/p&gt;
&lt;p&gt;StampedLock还提供了一个模式，即乐观读模式，使用tryOptimisticRead()方法获取一个非排他锁并且不会进入阻塞状态，与此同时该模式依然会返回一个long型的数据戳用于接下来的验证（该验证主要用来判断共享资源是否有写操作发生 lock.validate）&lt;/p&gt;
&lt;h2 id=&#34;11-guava之monitor详解&#34;&gt;11 Guava之Monitor详解&lt;/h2&gt;
&lt;p&gt;Monitor以及Monitor Guard则很好地将类似的一系列动作进行了抽象，隐藏了锁的获取、临界值判断、线程挂起、阻塞线程唤醒、锁的释放等操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对x进行操作之前先调用monitor.enterWhen()方法，该方法除了具备锁的功能之外还具备临界值判断的操作，因此只有当x满足临界值判断时当前线程才会对x进行自增运算，否则当前线程将会进入阻塞队列（其实在Guard内部使用的也是Condition）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用leave()方法，注释③处，该方法除了释放当前的锁之外，还会通知唤醒与Guard关联的Condition阻塞队列中的某个阻塞线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;enter()：该方法完全等价于Lock的lock()方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;enterIf(Guard guard)：该方法主要用于判断当前的Guard是否满足临界值的判断，也是使用比较多的一个操作，调用该方法，当前线程并不会进入阻塞之中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tryEnter()：等价于Lock的tryLock()方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;waitFor(Guard guard)：当前线程将会阻塞等待，直到Guard的条件满足当前线程才会退出阻塞状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-guava之ratelimiter详解&#34;&gt;12 Guava之RateLimiter详解&lt;/h2&gt;
&lt;p&gt;RateLimiter，顾名思义就是速率（Rate）限流器（Limiter），事实上它的作用正如名字描述的那样，经常用于进行流量、访问等的限制，这一点与3.4节中介绍过的Semaphore非常类似，但是它们的关注点却完全不同，RateLimiter关注的是在单位时间里对资源的操作速率（在RateLimiter内部也存在许可证（permits）的概念，因此可以理解为在单位时间内允许颁发的许可证数量），而Semaphore则关注的是在同一时间内最多允许多少个许可证可被使用，它不关心速率而只关心个数&lt;/p&gt;
&lt;p&gt;虽然说RateLimiter主要是用于控制速率的，但是在其内部也有许可证（permits）的概念，你甚至可以将其理解为单位时间内颁发的许可证数量，RateLimiter不仅允许每次获取一个许可证的操作，还允许获取超出剩余许可证数量的行为，只不过后者的操作将使得下一次请求为提前的透支付出代价。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第四章 java并发包之并发容器详解</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Wed, 17 Aug 2022 10:14:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/</guid>
        <description>&lt;h1 id=&#34;第四章-java并发包之并发容器详解&#34;&gt;第四章 java并发包之并发容器详解&lt;/h1&gt;
&lt;h2 id=&#34;1-blockingqueue阻塞队列&#34;&gt;1 BlockingQueue（阻塞队列）&lt;/h2&gt;
&lt;h3 id=&#34;11-arrayblockingqueue&#34;&gt;1.1 ArrayBlockingQueue&lt;/h3&gt;
&lt;p&gt;ArrayBlockingQueue是一个基于数组结构实现的FIFO阻塞队列，在构造该阻塞队列时需要指定队列中最大元素的数量（容量）。当队列已满时，若再次进行数据写入操作，则线程将会进入阻塞，一直等待直到其他线程对元素进行消费。当队列为空时，对该队列的消费线程将会进入阻塞，直到有其他线程写入数据。该阻塞队列中提供了不同形式的读写方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞式写方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void put(E e)：向队列的尾部插入新的数据，当队列已满时调用该方法的线程会进入阻塞，直到有其他线程对该线程执行了中断操作，或者队列中的元素被其他线程消费&lt;/li&gt;
&lt;li&gt;boolean offer(E e, long timeout, TimeUnit unit)：向队列尾部写入新的数据，当队列已满时执行该方法的线程在指定的时间单位内将进入阻塞，直到到了指定的超时时间后，或者在此期间有其他线程对队列数据进行了消费。当然了，对由于执行该方法而进入阻塞的线程执行中断操作也可以使当前线程退出阻塞。该方法的返回值boolean为true时表示写入数据成功，为false时表示写入数据失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞式写方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;boolean add(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，但是该方法会抛出队列已满的异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boolean offer(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，并且会立即返回false&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞时读方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，直到有其他线程写入新的数据，或者当前线程被执行了中断操作&lt;/li&gt;
&lt;li&gt;E take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，直到有其他线程写入新的数据，或者当前线程被执行了中断操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞式读方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，直到有其他线程写入新的数据，或者当前线程被执行了中断操作&lt;/li&gt;
&lt;li&gt;E peek()：peek的操作类似于debug操作（仅仅debug队列头部元素，本书的第6章将讲解针对Stream的操作，大家将从中学习到针对整个Stream数据元素的peek操作），它直接从队列头部获取一个数据，但是并不能从队列头部移除数据，当队列为空时，该方法不会使得当前线程进入阻塞，而是返回null值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-priorityblockingqueue&#34;&gt;1.2 PriorityBlockingQueue&lt;/h3&gt;
&lt;p&gt;PriorityBlockingQueue优先级阻塞队列是一个“无边界”阻塞队列，与4.1.2节所讲的优先级链表类似的是，该队列会根据某种规则（Comparator）对插入队列尾部的元素进行排序，因此该队列将不会遵循FIFO（first-in-first-out）的约束。虽然PriorityBlockingQueue同ArrayBlockingQueue都实现自同样的接口，拥有同样的方法，但是大多数方法的实现确实具有很大的差别，PriorityBlockingQueue也是线程安全的类，适用于高并发多线程的情况下。&lt;/p&gt;
&lt;h3 id=&#34;13-linkedblockingqueue&#34;&gt;1.3 LinkedBlockingQueue&lt;/h3&gt;
&lt;p&gt;ArrayBlockingQueue是基于数组实现的FIFO“有边界”队列，PriorityBlockingQueue也是基于数组实现的，但它是“无边界”的优先级队列，由于存在对数据元素的排序规则，因此PriorityBlockingQueue并不能提供FIFO的约束担保（当然，如果想要使其具备FIFO的特性，需要约束PriorityBlockingQueue的排序规则为R，并且对其写入数据的顺序也为R，这样就可以保证FIFO），本节将要介绍的LinkedBlockingQueue是“可选边界”基于链表实现的FIFO队列。截至目前，本章所学习到阻塞队列都是通过显式锁Lock进行共享数据的同步，以及与Lock关联的Condition进行线程间通知，因此该队列也适用于高并发的多线程环境中，是线程安全的类。&lt;/p&gt;
&lt;p&gt;LinkedBlockingQueue队列的边界可选性是通过构造函数来决定的，当我们在创建LinkedBlockingQueue对象时，使用的是默认的构造函数，那么该队列的最大容量将为Integer的最大值（所谓的“无边界”），当然开发者可以通过指定队列最大容量（有边界）的方式创建队列。&lt;/p&gt;
&lt;h3 id=&#34;14-delayqueue&#34;&gt;1.4 DelayQueue&lt;/h3&gt;
&lt;p&gt;DelayQueue也是一个实现了BlockingQueue接口的“无边界”阻塞队列，但是该队列却是非常有意思和特殊的一个队列（存入DelayQueue中的数据元素会被延迟单位时间后才能消费），在DelayQueue中，元素也会根据优先级进行排序，这种排序可以是基于数据元素过期时间而进行的（比如，你可以将最快过期的数据元素排到队列头部，最晚过期的数据元素排到队尾）。&lt;/p&gt;
&lt;p&gt;【note】这里没看懂，暂时略过&lt;/p&gt;
&lt;h3 id=&#34;15-synchronousqueue&#34;&gt;1.5 SynchronousQueue&lt;/h3&gt;
&lt;p&gt;SynchronousQueue也是实现自BlockingQueue的一个阻塞队列，每一次对其的写入操作必须等待（阻塞）其他线程进行对应的移除操作，SynchronousQueue的内部并不会涉及容量、获取size，就连peek方法的返回值永远都将会是null，除此之外还有更多的方法在SynchronousQueue中也都未提供对应的支持。&lt;/p&gt;
&lt;p&gt;尽管SynchronousQueue是一个队列，但是它的主要作用在于在两个线程之间进行数据交换，区别于Exchanger的主要地方在于（站在使用的角度）SynchronousQueue所涉及的一对线程一个更加专注于数据的生产，另一个更加专注于数据的消费（各司其职），而Exchanger则更加强调一对线程数据的交换。&lt;/p&gt;
&lt;h3 id=&#34;16-linkedblockingdeque&#34;&gt;1.6 LinkedBlockingDeque&lt;/h3&gt;
&lt;p&gt;LinkedBlockingDeque是一个基于链表实现的双向（Double Ended Queue，Deque）阻塞队列，双向队列支持在队尾写入数据，读取移除数据；在队头写入数据，读取移除数据。LinkedBlockingDeque实现自BlockingDeque（BlockingDeque又是BlockingQueue的子接口），并且支持可选“边界”，与LinkedBlockingQueue一样，对边界的指定在构造LinkedBlockingDeque时就已经确定了。&lt;/p&gt;
&lt;h3 id=&#34;17-linkedtransferqueue&#34;&gt;1.7 LinkedTransferQueue&lt;/h3&gt;
&lt;p&gt;TransferQueue是一个继承了BlockingQueue的接口，并且增加了若干新的方法。LinkedTransferQueue是TransferQueue接口的实现类，其定义为一个无界的队列，具有FIFO的特性。&lt;/p&gt;
&lt;p&gt;继承自BlockingQueue的方法在使用方法上与本节中学过的其他BlockingQueue并没有太大的区别（SynchronousQueue除外），因此我们只介绍继承自TransferQueue的方法，看看TransferQueue为其赋予了怎样的新特性。&lt;/p&gt;
&lt;h2 id=&#34;2-concurrentqueue并发队列&#34;&gt;2 ConcurrentQueue（并发队列）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ConcurrentLinkedQueue 单向队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcurrentLinkedDeque 双向队列&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节介绍了ConcurrentLinkedQueue（先进先出FIFO队列）和ConcurrentLinkedDeque（双向队列），对于队列的使用前文中做了很多介绍，因此本节并未对每种方法都展开详细的介绍。并发队列在实现上采用了无锁（Lock Free）算法，因此在多线程高并发的环境中其拥有更出色的性能表现，但是ConcurrentLinkedQueue并不是在任何情景下都会保持高效，比如执行size()方法时，甚至本身在对元素进行删除操作时都存在着性能隐患和内存溢出的问题，关于这些，本节中都做了非常详细的介绍。当然了，这并不妨碍你在开发中使用它，但是使用得当的前提是你必须搞清楚它在什么情况下会出现问题，只有这样才能对其驾驭得当、运用自如。&lt;/p&gt;
&lt;h2 id=&#34;3-concurrentmap并发映射&#34;&gt;3 ConcurrentMap（并发映射）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ConcurrentHashMap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConcurrentSkipListMap&lt;/p&gt;
&lt;p&gt;ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上，其能够在O(log(n))时间内完成查找、插入、删除操作。调用ConcurrentSkipListMap的size时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素的个数，这个操作是个O(log(n))的操作。&lt;/p&gt;
&lt;p&gt;在读取性能上，虽然ConcurrentSkipListMap不能与ConcurrentHashMap相提并论，但是ConcurrentSkipListMap存在着如下两大天生的优越性是ConcurrentSkipListMap所不具备的。&lt;/p&gt;
&lt;p&gt;第一，由于基于跳表的数据结构，因此ConcurrentSkipListMap的key是有序的。&lt;/p&gt;
&lt;p&gt;第二，ConcurrentSkipListMap支持更高的并发，ConcurrentSkipListMap的存取时间复杂度是O（log（n）），与线程数几乎无关，也就是说，在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出它的优势。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-写时拷贝算法copy-on-write&#34;&gt;4 写时拷贝算法（Copy On Write）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CopyOnWriteArrayList&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CopyOnWriteArraySet&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第五章 java并发包之ExecutorService</title>
        <link>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%94%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8Bexecutorservice/</link>
        <pubDate>Wed, 17 Aug 2022 10:14:00 +0000</pubDate>
        
        <guid>https://lyoshur.github.io/stack/p/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E5%BA%93%E6%B1%AA%E6%96%87%E5%90%9B-%E7%AC%AC%E4%BA%94%E7%AB%A0-java%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B9%8Bexecutorservice/</guid>
        <description>&lt;h1 id=&#34;第五章-java并发包之executorservice&#34;&gt;第五章 java并发包之ExecutorService&lt;/h1&gt;
&lt;h2 id=&#34;1-executorexecutorservice详解&#34;&gt;1 Executor&amp;amp;ExecutorService详解&lt;/h2&gt;
&lt;h3 id=&#34;11-threadpoolexecutor详解&#34;&gt;1.1 ThreadPoolExecutor详解&lt;/h3&gt;
&lt;p&gt;构造ThreadPoolExecutor所需要的参数是比较多的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;corePoolSize：用于指定在线程池中维护的核心线程数量，即使当前线程池中的核心线程不工作，核心线程的数量也不会减少（在JDK1.6版本及以后可以通过设置允许核心线程超时的方法allowCoreThreadTimeOut来改变这种情况）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;maximumPoolSize：用于设置线程池中允许的线程数量的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;keepAliveTime：当线程池中的线程数量超过核心线程数并且处于空闲时，线程池将回收一部分线程让出系统资源，该参数可用于设置超过corePoolSize数量的线程在多长时间后被回收，与unit配合使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TimeUnit：用于设定keepAliveTime的时间单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;workQueue：用于存放已提交至线程池但未被执行的任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ThreadFactory：用于创建线程的工厂，开发者可以通过自定义ThreadFactory来创建线程，比如，根据业务名为线程命名、设置线程优先级、设置线程是否为守护线程等、设置线程所属的线程组等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RejectedExecutionHandler：当任务数量超过阻塞队列边界时，这个时候线程池就会拒绝新增的任务，该参数主要用于设置拒绝策略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ExecutorService允许一次性提交一批任务invokeAny，但是其只关心第一个完成的任务和结果&lt;/p&gt;
&lt;p&gt;invokeAll方法同样可用于异步处理批量的任务，但是该方法关心所有异步任务的运行&lt;/p&gt;
&lt;h3 id=&#34;12-scheduledexecutorservice&#34;&gt;1.2 ScheduledExecutorService&lt;/h3&gt;
&lt;p&gt;ScheduledExecutorService既具有ThreadPoolExecutor的所有方法，同时又具备定时执行任务的方法，在ScheduledExecutorService中定义了4个与schedule相关的方法，用于定时执行任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt; ScheduledFuture&lt;!-- raw HTML omitted --&gt; schedule(Callable&lt;!-- raw HTML omitted --&gt; callable,long delay,TimeUnit unit)：该方法是一个one-shot方法（只执行一次），任务（callable）会在单位（unit）时间（delay）后被执行，并且立即返回ScheduledFuture，在稍后的程序中可以通过Future获取异步任务的执行结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ScheduledFuture&lt;!-- raw HTML omitted --&gt; schedule(Runnable command,long delay, TimeUnit unit)：该方法同样是一个one-shot方法（只执行一次），任务（runnable）会在单位（unit）时间（delay）后被执行，虽然也会返回ScheduledFuture，但是并不会包含任何执行结果，因为Runnable接口的run方法本身就是无返回值类型的接口方法，不过可以通过该Future判断任务是否执行结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ScheduledFuture&lt;!-- raw HTML omitted --&gt; scheduleAtFixedRate(Runnable command,long initialDelay, long period, TimeUnit unit)：任务（command）会根据固定的速率（period，时间单位为unit）在时间（initialDelay，时间单位为unit）后不断地被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ScheduledFuture&lt;!-- raw HTML omitted --&gt; scheduleWithFixedDelay(Runnable command, long initialDelay,long delay,TimeUnit unit)：该方法与前一个方法比较类似，只不过该方法将以固定延迟单位时间的方式执行任务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-executors详解&#34;&gt;1.3 Executors详解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FixedThreadPool&lt;/p&gt;
&lt;p&gt;线程池的核心线程数和最大线程数是相等的，因此该线程池中的工作线程数将始终是固定的。任务队列为LinkedBlockingQueue（无边界），所以理论上提交至线程池的任务始终都会被执行，只有显式地执行线程池的关闭方法才能关闭线程池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SingleThreadPool&lt;/p&gt;
&lt;p&gt;SingleThreadPool是只有一个核心线程的线程池，但是Finalizable代理了该线程池，因此当线程池引用可被垃圾回收器回收时，线程池的shutdown方法会被执行，当然我们还是建议显式地调用线程池的关闭方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CachedThreadPool&lt;/p&gt;
&lt;p&gt;CachedThreadPool根据需要创建新线程，但会重用以前构造的可用线程。该线程池通常会用于提高执行量大的、耗时较短的、异步任务程序的运行性能，在该线程池中，如果有可用的线程将被直接重用。如果没有可用的线程，则会创建一个新线程并将其添加到池中。未被使用且空闲时间超过60秒的线程将被终止并从线程池中移除，因此长时间空闲的线程不会消耗任何资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ScheduledThreadPool&lt;/p&gt;
&lt;p&gt;创建指定核心线程数量的ScheduledExecutorService&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WorkStealingPool&lt;/p&gt;
&lt;p&gt;与其他线程池不同的是，WorkStealingPool中的工作线程会处理任务队列中与之对应的任务分片（Divide and conquer：分而治之），如果某个线程处理的任务执行比较耗时，那么它所负责的任务将会被其他线程“窃取”执行，进而提高并发处理的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-future和callback&#34;&gt;2 Future和Callback&lt;/h2&gt;
&lt;p&gt;Future代表着一个异步任务在未来的执行结果，这个结果可以在最终的某个时间节点通过Future的get方法来获得&lt;/p&gt;
&lt;p&gt;获取异步执行任务的结果：当异步任务被正常执行完毕，可以通过get方法或者其重载方法（指定超时单位时间）获取最终的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Callable接口：该接口与Runnable接口非常相似，但是Runnable作为任务接口最大的问题就是无法返回最终的计算结果，因此在JDK1.5版本中引入了Callable泛型接口，它允许任务执行结束后返回结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务执行错误：Runnable类型的任务中，run（）方法抛出的异常（运行时异常）只能被运行它的线程捕获（有可能会导致运行线程死亡），但是启动运行线程的主线程却很难获得Runnable任务运行时出现的异常信息。在《Java高并发编程详解：多线程与架构设计》一书的第7章“Hook线程以及捕获线程执行异常”中有讲到，我们可以通过设置UncaughtExceptionHandler的方式来捕获异常，但是这种方式的确不够优雅，并且也无法精确地知道是执行哪个任务时出现的错误，Future则是通过捕获get方法异常的方式来获取异步任务执行的错误信息的，如下面的示例代码所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Future的不足之处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法被动接收异步任务的计算结果：虽然我们可以主动将异步任务提交给线程池中的线程来执行，但是待异步任务结束后，主（当前）线程无法得到任务完成与否的通知（关于这一点，5.2.4节中将会给出解决方案），它需要通过get方法主动获取计算结果&lt;/li&gt;
&lt;li&gt;Future间彼此孤立：有时某一个耗时很长的异步任务执行结束以后，你还想利用它返回的结果再做进一步的运算，该运算也会是一个异步任务，两者之间的关系需要程序开发人员手动进行绑定赋予，Future并不能将其形成一个任务流（pipeline），每一个Future彼此之间都是孤立的，但5.5节将要介绍的CompletableFuture就可以将多个Future串联起来形成任务流（pipeline）&lt;/li&gt;
&lt;li&gt;Future没有很好的错误处理机制：截至目前，如果某个异步任务在执行的过程中发生了异常错误，调用者无法被动获知，必须通过捕获get方法的异常才能知道异步任务是否出现了错误，从而再做进一步的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21-google-guava的future&#34;&gt;2.1 Google Guava的Future&lt;/h3&gt;
&lt;p&gt;Future虽然为我们提供了一个凭据，但是在未来某个时间节点进行get()操作时仍然会使当前线程进入阻塞，显然这种操作方式并不是十分完美，因此在Google Guava并发包中提供了对异步任务执行的回调支持，它允许你注册回调函数而不用再通过get()方法苦苦等待异步任务的最终计算结果（Don&amp;rsquo;t Call Us, We&amp;rsquo;ll Call You!）&lt;/p&gt;
&lt;h4 id=&#34;211-listenablefuture&#34;&gt;2.1.1 ListenableFuture&lt;/h4&gt;
&lt;p&gt;Guava提供了ListneningExecutorService，使用该ExecutorService提交执行异步任务时将返回ListenableFuture，通过该Future，我们可以注册回调接口&lt;/p&gt;
&lt;h4 id=&#34;212-futurecallback&#34;&gt;2.1.2 FutureCallback&lt;/h4&gt;
&lt;p&gt;除了ListenableFuture之外，还可以注册FutureCallback，相比前者用Runnable接口作为回调接口，FutureCallback提供的回调方式则更为直观。&lt;/p&gt;
&lt;h2 id=&#34;3-forkjoinpool详解&#34;&gt;3 ForkJoinPool详解&lt;/h2&gt;
&lt;p&gt;Fork/Join框架是在JDK1.7版本中被Doug Lea引入的，Fork/Join计算模型旨在充分利用多核CPU的并行运算能力，将一个复杂的任务拆分（fork）成若干个并行计算，然后将结果合并（join）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RecursiveTask&lt;/p&gt;
&lt;p&gt;RecursiveTask任务类型除了进行子任务的运算之外，还会将最终子任务的计算结果返回，下面通过一个简单的实例来认识一下RecursiveTask。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RecursiveAction&lt;/p&gt;
&lt;p&gt;RecursiveAction类型的任务与RecursiveTask比较类似，只不过它更关注于子任务是否运行结束，下面来看一个将数组中的每一个元素并行增加10倍&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-completionservice详解&#34;&gt;4 CompletionService详解&lt;/h2&gt;
&lt;p&gt;CompletionService并不是ExecutorService的子类，因此它并不具备执行异步任务的能力（异步任务的执行是由CompletionService内部的ExecutorService来完成的），它只是对Executor-Service的一个封装，在其内部提供了阻塞队列用于Future的消费&lt;/p&gt;
&lt;p&gt;CompletionService很好地解决了异步任务的问题，在CompletionService中提供了提交异步任务的方法（真正的异步任务执行还是由其内部的ExecutorService完成的），任务提交之后调用者不再关注Future，而是从BlockingQueue中获取已经执行完成的Future，在异步任务完成之后Future才会被插入阻塞队列，也就是说调用者从阻塞队列中获取的Future是已经完成了的异步执行任务，所以再次通过Future的get方法获取结果时，调用者所在的当前线程将不会被阻塞。&lt;/p&gt;
&lt;h2 id=&#34;5-completablefuture详解&#34;&gt;5 CompletableFuture详解&lt;/h2&gt;
&lt;p&gt;CompletableFuture是自JDK1.8版本中引入的新的Future，常用于异步编程之中，所谓异步编程，简单来说就是：“程序运算与应用程序的主线程在不同的线程上完成，并且程序运算的线程能够向主线程通知其进度，以及成功失败与否的非阻塞式编码方式”，这句话听起来与前文中学习的ExecutorService提交异步执行任务并没有多大的区别，但是别忘了，无论是ExecutorService还是CompletionService，都需要主线程主动地获取异步任务执行的最终计算结果，如此看来，Google Guava所提供的ListenableFuture更符合这段话的描述，但是ListenableFuture无法将计算的结果进行异步任务的级联并行运算，甚至构成一个异步任务并行运算的pipeline，但是这一切在CompletableFuture中都得到了很好的支持。&lt;/p&gt;
&lt;p&gt;CompletableFuture实现自CompletionStage接口，可以简单地认为，该接口是同步或者异步任务完成的某个阶段，它可以是整个任务管道中的最后一个阶段，甚至可以是管道中的某一个阶段，这就意味着可以将多个CompletionStage链接在一起形成一个异步任务链，前置任务执行结束之后会自动触发下一个阶段任务的执行。另外，CompletableFuture还实现了Future接口，所以你可以像使用Future一样使用它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;thenApply：以同步的方式继续处理上一个异步任务的结果。&lt;/li&gt;
&lt;li&gt;thenApplyAsync：以异步的方式继续处理上一个异步任务的结果。&lt;/li&gt;
&lt;li&gt;thenAccept：以同步的方式消费上一个异步任务的结果。&lt;/li&gt;
&lt;li&gt;thenAcceptAsync：以异步的方式消费上一个异步任务的结果。&lt;/li&gt;
&lt;li&gt;thenRun：以同步的方式执行Runnable任务。&lt;/li&gt;
&lt;li&gt;thenRunAsync：以异步的方式执行Runnable任务。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
