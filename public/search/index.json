[{"content":"3 进行简单数据查询 1 2 # 获取Service 参数为数据库内的表名 test_service = factory.get_service(\u0026#34;tb_test\u0026#34;) 获取对应数据库表的service后，能够使用内置的常用增删改查方法，对数据库进行操作\n3.1查询列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 查询当前service的列表,其中参数为空字典，表示不使用任何搜索条件 list_data = test_service.get_list({}) print(list_data) # 当需要分页时，可以使用 # start 开始查询的起点记录 0表示从第一条记录查询 # length 要查询几条数据 # order_by 列表排序条件 例如 id asc 正序 或 id desc 逆序 list_data = test_service.get_list({}, start=0, length=10, order_by=\u0026#34;id\u0026#34;) print(list_data) # 搜索name字段等于张三 # 当输入%时，表示要使用模糊搜索 # %张向前模糊，张%向后模糊，%张%全模糊 list_data = test_service.get_list({ \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34; }, start=0, length=10, order_by=\u0026#34;id\u0026#34;) print(list_data) 3.2 查询记录数量 1 2 3 4 5 6 7 8 9 # 查询当前service的数据总数,其中参数为空字典，表示不使用任何搜索条件 count = test_service.get_count({}) print(count) # 搜索name字段等于张三的记录数量 # 当输入%时，表示要使用模糊搜索 # %张向前模糊，张%向后模糊，%张%全模糊 count = test_service.get_count({\u0026#34;name\u0026#34;: \u0026#34;张%\u0026#34;}) print(count) 3.3 查询单条记录 1 2 3 4 5 6 7 # 搜索第一条记录，等同于get_list，但是只返回第一条记录 model = test_service.get_first({\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(model) # 查询主键对应的记录，条件必须是主键且不能为空 model = test_service.get_model({\u0026#34;id\u0026#34;: 1}) print(model) 3.4 判断记录是否存在 注意在liteorm==0.0.1或myorm==1.0.2中，这个方法存在BUG，请使用count。然后自行判断记录是否存在！\n1 2 3 4 5 6 7 8 9 # 判断记录是否存在，参数等同于get_list，但是只返回Boolean exist = test_service.exist({}) print(exist) # 判断记录是否存在，参数等同于get_list，但是只返回Boolean exist = test_service.exist({ \u0026#34;name\u0026#34;: \u0026#34;张%\u0026#34; }) print(exist) 3.5 新增记录 1 2 3 4 5 6 # 插入记录 字典key对应数据库字段名 # 当主键设置了自增时，将值写为 0 test_service.insert({ \u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34; }) 3.6 更新记录 1 2 3 4 5 6 # 更新记录 字典key对应数据库字段名 # 根据主键更新，必须填写主键 test_service.update({ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;李四+1\u0026#34; }) 3.7 删除记录 1 2 # 根据主键删除记录，必须填写主键 test_service.delete({\u0026#34;id\u0026#34;: 3}) 4 自定义SQL 当Service中的方法，不满足需求时或需要自定SQL执行可以使用以下方法\n根据返回值不同，方法被分成三类\n4.1 查询记录 1 2 3 4 # 使用自定义SQL进行列表查询 # 需要参数化的变量 使用 #{变量名} 进行查询 data = factory.query(\u0026#34;select * from tb_test where `name` = #{name}\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 4.2 查询记录条数 1 2 3 4 # 使用自定义SQL进行列表数量查询 # 需要参数化的变量 使用 #{变量名} 进行查询 number = factory.count(\u0026#34;select count(1) from tb_test where `name` = #{name}\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(number) 4.3 执行查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用自定义SQL进行数据插入 # 需要参数化的变量 使用 #{变量名} 进行查询 # 返回两个参数，第一个为插入记录的ID，第二个为本次操作影响的记录行数 id, _ = factory.exec(\u0026#34;INSERT INTO tb_test(name) VALUES(#{name})\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(id) # 使用自定义SQL进行数据插入 # 需要参数化的变量 使用 #{变量名} 进行查询 # 返回两个参数，第一个为插入记录的ID，第二个为本次操作影响的记录行数 _, row_number = factory.exec(\u0026#34;UPDATE tb_test SET name = #{new_name} WHERE name = #{old_name}\u0026#34;, { \u0026#34;new_name\u0026#34;: \u0026#34;张三+1\u0026#34;, \u0026#34;old_name\u0026#34;: \u0026#34;张三\u0026#34; }) print(row_number) 5 使用Mapper查询 5.1 使用Mapper独立文件查询 当有SQL需要复用，或希望将SQL放置到文件中统一管理时，可以使用Mapper文件进行\nMapper文件内容完整结构如下\nmapper节点可以对数据查询结果中的字段重命名，类似 select name as record_name\n如果不需要也可以不写mapper节点\nsql为条sql节点，包含一个key，来作为这条sql的标识，value为sql具体内容\n示例：tb_test.mapper文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;xml\u0026gt; \u0026lt;mapper column=\u0026#34;id\u0026#34; parameter=\u0026#34;record_id\u0026#34;/\u0026gt; \u0026lt;mapper column=\u0026#34;name\u0026#34; parameter=\u0026#34;record_name\u0026#34;/\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetList\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select * from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetCount\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select Count(1) from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;Insert\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; INSERT INTO tb_test(name) VALUES(#{name}) \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;/xml\u0026gt; 然后将文件加载到框架中使用\n1 2 3 4 5 6 7 8 # 将mapper加载到框架中 # tb_test_dao 是随意起的一个名字 # 通过 orm.parse_config_from_file 将mapper文件加载到框架，用于生成dao实例 factory.load_dao(\u0026#34;tb_test_dao\u0026#34;, orm.parse_config_from_file(\u0026#34;tb_test.mapper\u0026#34;)) # 使用加载后的DAO进行查询，这时的第一个参数，对应到mapper文件中sql节点里的Key关键字 data = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;).query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 与自定义SQL查询相同，根据返回值不同，DAO实例提供了三个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 获取dao tb_test_dao = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;) # 查询列表使用 dao.query data = tb_test_dao.query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) # 查询记录数量使用 dao.count count = tb_test_dao.count(\u0026#34;GetCount\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(count) # 执行SQL使用 返回值等同于 factory.exec id, _ = tb_test_dao.exec(\u0026#34;Insert\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(id) 5.2 使用Mapper格式字符串查询 框架也支持加载Mapper格式字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 定义一个Mapper格式的字符串 sql_xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;xml\u0026gt; \u0026lt;mapper column=\u0026#34;id\u0026#34; parameter=\u0026#34;record_id\u0026#34;/\u0026gt; \u0026lt;mapper column=\u0026#34;name\u0026#34; parameter=\u0026#34;record_name\u0026#34;/\u0026gt; \u0026lt;sql\u0026gt; \u0026lt;key\u0026gt;GetList\u0026lt;/key\u0026gt; \u0026lt;value\u0026gt; select * from tb_test where name = #{name} \u0026lt;/value\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;/xml\u0026gt; \u0026#34;\u0026#34;\u0026#34; # 将mapper加载到框架中 # 通过 orm.parse_config_from_string 将mapper字符串加载到框架 factory.load_dao(\u0026#34;tb_test_dao\u0026#34;, orm.parse_config_from_string(sql_xml)) # 查询列表使用 dao.query data = factory.get_dao(\u0026#34;tb_test_dao\u0026#34;).query(\u0026#34;GetList\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) print(data) 6 事务支持 6.1 通过函数执行事务 1 2 3 4 5 6 7 8 9 10 11 # 定义一个方法 # 将需要进行的数据库操作，放在方法内 def insert_all(): factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34;}) # 通过 factory.transaction 执行刚刚定义的方法 # 注意参数是方法本身 不要写成 factory.transaction(insert_all()) # 这样处于方法内部的查询，则被加入到同一个数据库事务中 factory.transaction(insert_all) 6.2 通过装饰器开启事务 1 2 3 4 5 6 7 8 9 10 11 # 定义一个方法 # 将需要进行的数据库操作，放在方法内 @factory.transaction_wraps def insert_all(): factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;}) factory.get_service(\u0026#34;tb_test\u0026#34;).insert({\u0026#34;id\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;李四\u0026#34;}) # 因为方法上被加上了 @factory.transaction_wraps 装饰器 # 则这个方法被执行时，会自动启用事务 insert_all() ","date":"2022-03-13T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/python-orm%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"python-orm数据库查询框架使用教程"},{"content":"myorm mysql数据库查询框架 1 依赖安装 1 pip install mysqlconn 2 连接数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 引入最好这样写，推荐写法 from myorm import orm # 连接数据库 factory = orm.Builder( \u0026#34;127.0.0.1\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;, \u0026#34;test\u0026#34;, 3306 ).build() # 从数据库解析数据库表结构，加载通用的Service # 全局仅需执行一次！！ # 建议放到数据库连接之后直接执行 factory.load_service() ","date":"2022-03-12T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/%E4%BD%BF%E7%94%A8myorm%E8%BF%9E%E6%8E%A5%E5%88%B0mysql/","title":"使用myorm连接到mysql"},{"content":"liteorm sqlite3数据库查询框架 1 依赖安装 1 pip install liteorm 2 连接数据库 1 2 3 4 # 引入最好这样写，推荐写法 from liteorm import orm # 连接数据库 factory = orm.Builder(\u0026#34;test.db\u0026#34;).build() ","date":"2022-03-11T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/%E4%BD%BF%E7%94%A8liteorm%E8%BF%9E%E6%8E%A5%E5%88%B0sqlite3/","title":"使用liteorm连接到sqlite3"},{"content":"stream流操作 stream位于java.util包中，是java8中新增类。\n1.创建Stream 1.1使用数组转为流 1 2 3 4 5 6 String[] a = new String[3]; // 模拟设置值 Stream\u0026lt;String\u0026gt; ss = Stream.of(a); long len = ss.count(); System.out.println(len); 1.2使用数组转化为流 1 2 3 4 5 6 String[] a = new String[3]; // 模拟设置值 Stream\u0026lt;String\u0026gt; ss = Arrays.stream(a); long len = ss.count(); System.out.println(len); 1.3使用List转化为流 1 2 3 4 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); Stream\u0026lt;String\u0026gt; ss = list.stream(); System.out.println(ss.count()); 2.使用流 2.1筛选记录 filter 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().filter(new Predicate\u0026lt;String\u0026gt;() { @Override public boolean test(String s) { return s.startsWith(\u0026#34;a\u0026#34;); } }); System.out.println(ss.count()); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;a\u0026#34;)); System.out.println(ss.count()); 2.2处理记录 map 1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().map(new Function\u0026lt;String, String\u0026gt;() { @Override public String apply(String s) { return s + \u0026#34;-hahahaa\u0026#34;; } }); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;ab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().map(s -\u0026gt; s + \u0026#34;-hahahah\u0026#34;); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 2.3进行排序 sorted 1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream().sorted(); System.out.println(ss.collect(Collectors.joining(\u0026#34;,\u0026#34;))); 2.4合并流 flatMap 可以类似map，针对流中的每个元素进行处理，不同的是，返回值需要是一个另外的流。然后flatMap会将返回的所有流，进行合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;Integer\u0026gt; ss = list.stream().flatMap(new Function\u0026lt;String, Stream\u0026lt;Integer\u0026gt;\u0026gt;() { @Override public Stream\u0026lt;Integer\u0026gt; apply(String s) { return Stream.of(1, 2, 3); } }); System.out.println(ss.collect(Collectors.toList())); 可以使用 lambda 表达式，来简化代码。\n1 2 3 4 5 6 7 8 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;Integer\u0026gt; ss = list.stream().flatMap(s -\u0026gt; Stream.of(1, 2, 3)); System.out.println(ss.collect(Collectors.toList())); 3.对流进行约简 3.1收集为列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 重新将流收集成列表 List\u0026lt;String\u0026gt; data = ss.collect(Collectors.toList()); // 通过指定收集列表类型，来返回指定类型列表 // ArrayList ArrayList\u0026lt;String\u0026gt; data1 = ss.collect(Collectors.toCollection(ArrayList::new)); // LinkedList LinkedList\u0026lt;String\u0026gt; data2 = ss.collect(Collectors.toCollection(LinkedList::new)); System.out.println(data); 3.2收集为Set 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Set Set\u0026lt;String\u0026gt; data = ss.collect(Collectors.toSet()); System.out.println(data); 3.3收集为Map 3.3.1聚组Map 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Map Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; data = ss.collect(Collectors.groupingBy(String::toString)); System.out.println(data); 3.3.2键值对Map 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成Map Map\u0026lt;String, String\u0026gt; data = ss.collect(Collectors.toMap(String::toString, String::toString)); System.out.println(data); 3.4收集为String 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;bab\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 将流收集成String String data = ss.collect(Collectors.joining(\u0026#34;-\u0026#34;)); System.out.println(data); 3.5 Collectors.collectingAndThen 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 首先将列表收集为Set进行去重，然后重新收集为列表 List\u0026lt;String\u0026gt; data = ss.collect(Collectors.collectingAndThen(Collectors.toSet(), ArrayList::new)); System.out.println(data); 4.其他约简操作 4.1返回Optional 1 2 3 4 5 6 7 8 9 10 11 12 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 查找列表第一个 Optional\u0026lt;String\u0026gt; data = ss.findFirst(); System.out.println(data.toString()); 4.2返回布尔值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(10); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;bcd\u0026#34;); Stream\u0026lt;String\u0026gt; ss = list.stream(); // 查找列表中，有没有 \u0026#34;a\u0026#34; boolean data = ss.anyMatch(s -\u0026gt; s.equals(\u0026#34;a\u0026#34;)); // 查找列表中，是不是全是 \u0026#34;a\u0026#34; boolean data1 = ss.allMatch(s -\u0026gt; s.equals(\u0026#34;a\u0026#34;)); System.out.println(data); ","date":"2022-03-10T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/stream%E6%B5%81%E6%93%8D%E4%BD%9C/","title":"stream流操作"},{"content":"java9 中的 Module, ModulePath 和 ClassPath 我们都知道，从 Java9 开始，引入了模块系统，提供了对大型复杂系统很重要的隔离，依赖管理等特性。\n首先是个吐槽。\n作为Java9的主要特性，抛开JDK本身的需求，模块系统的设计有不少可以商榷的地方，也引起了不小的争议，甚至一度被JCP否决；对用户来说，迁移成本高，收益不明显，为了这个项目花了三年半的时间，Block了其他项目的进展，让本来已经老旧的Java显得更加老旧，实在是不明智啊。\n下面是正文开始。\n一个Jar包，如果根目录下有 module-info.class 这个文件，则是一个已经包含了模块化信息的模块。在 module-info.class 中，可以指定此模块的名字和版本，哪些 Package 可以被别的模块访问，依赖于哪些模块，这些依赖是否继续传递等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 module net.dongliu.serviceimpl { requires net.dongliu.utils; requires net.dongliu.service; exports net.dongliu.serviceimpl.api; provides net.dongliu.service.MyService with net.dongliu.serviceimpl.MyServiceImpl; } 旧项目的兼容\n然而在此之前已经发布的Jar包，和开发的项目，都是没有模块化的，Java9 如何处理这些Jar包和项目呢? 这就要靠新引入的 ModulePath了，简单的说就是老人老办法，新人新办法，对 ClassPath 和 ModulePath 采用不同的规则。\nModulePath 和 ClassPath\nModulePath 的概念和ClassPath 类似，不过 ModulePath 中的 Jar 包或 Jmod 文件被当作 Module 来处理，而 ClassPath 中的的 Jar 包，无论是否模块化都会被当作传统 Jar 包处理。\nJava9 制定了以下规则以保证旧 Jar 包和项目可以无缝的迁移到新的 Java 版本上:\n所有 ClassPath 下的 Jar 包，Class，资源文件等都在一个 Unnamed Module 中\nUnnamed Module 的 Class 可以看到和使用所有 Module Path 中导出的 Package，所有 Class Path 中的 Package，以及所有 JDK 系统模块的 Package\nModulePath 下普通模块中的 Class 只能看到 module-info 中定义的依赖模块中导出的 Package，也看不到 Unnamed Module 中的内容。\n根据这些规则，如果项目还是使用 ClassPath，则对项目来说没有影响，项目也不需要定义模块依赖。另外，项目的依赖可以放在 ClassPath 上，也可以放在 ModulePath 上，区别是放在 ModulePath 上的话不能使用模块中未标记为导出的 Package。\n这里需要解释一下 Unnamed Module。Unnamed Module 是一个特殊的，自动生成的 Module，所有 ClassPath 下的内容在 Java9 中都是挂在 Unnamed Module 名下的。对于同一个 ClassLoader，只有一个 Unnamed Module。\n模块化项目使用未模块化的 Jar 包\n现在对于未模块化的传统项目没问题了，那么，如果要创建一个模块化的项目，但是依赖的 Jar 包还没有模块化怎么办？按照上面的规则，因为这些 Jar 包没有模块信息，所以就没法在项目的 module-info 中定义这个依赖。为了保证模块化的新项目能够使用尚未模块化的旧 Jar 包，又定义了 Automatic Module 的概念。\nAutomatic Module\n一个不包含 module-info.class 的传统 Jar 包，如果放到了 ModulePath 下，就变成了一个 Automatic Module。\n一个 Automatic Module:\n默认的依赖于所有 ModulePath 中的模块，可以访问所有模块中导出的 Package。\n默认导出此模块中的所有 Package。\n如果 Jar 包在 MetaInfo 文件中定义了 Automatic-Module-Name，则使用这个值作为模块的名称；如果没有定义，那么使用 Jar 包的文件名去掉扩展名的那部分作为模块名，其中包含的-要替换成.，因为模块名不允许包含-字符。\n按照如上规则，项目中就可以把一个未模块化的 Jar 包，当成一个模块来使用了。\nAutomatic Module 的争议\nJigsaw 这个项目，其中最有争议的是如何自动给模块命名，也就是上面的第三个规则。Jigsaw 项目的 JSR 投票第一次被否决，除了 IBM，JBoss 这样因为有自己的模块系统而处于政治原因投反对票的之外，基本上都是由于反对这个自动命名规则。现在的项目基本是采用 Maven，Gradle 等组织构建，这些项目最后生成的 Jar 包文件名只包含 artifactId，用这个做模块名明显是不合适的。更多的人希望用 groupId + artifactId 来作为模块——这个是可行的，因为 Maven 项目生成的 Jar 包会在 META-INF/maven 下保存项目的元信息。可惜的是最后仍然是没有采用这个方案。\n所以为了保证将来平滑的迁移，如果你是一个模块的维护者，可以在 MANIFEST.MF 中加一个Automatic-Module-Name 的值。 比如使用 Maven 的话可以这样指定:\nmaven-jar-plugin\nnet.dongliu.service\n","date":"2022-03-09T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/java9-%E4%B8%AD%E7%9A%84-module-modulepath-%E5%92%8C-classpath/","title":"java9 中的 Module, ModulePath 和 ClassPath"},{"content":"java反编译 在使用idea进行反编译class文件时，发现文件头会带有\n1 2 3 4 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // 于是想利用idea自带的反编译插件，来对已经存在的JAR包进行反编译。\n不过在idea安装目录，插件中查找没有找到Fernflower。后搜索教程，教程说内置的插件名称是java-decompiler\n这里怀疑是idea对Fernflower进行了插件化封装。\n使用反编译命令，对jar包进行反编译\n1 java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -hdc=0 -dgs=1 -rsy=1 -rbr=1 -lit=1 -nls=1 -mpm=60 \u0026lt;jar\u0026gt; \u0026lt;反编译后的JAR生成目录\u0026gt; -cp \u0026lt;目录和 zip/jar 文件的类搜索路径\u0026gt;\n反编译后生成结果仍然是JAR包，但是可以使用命令\n1 jar -xf \u0026lt;jar\u0026gt; 对反编译生成的JAR包进行解包，解包结果就是反编译后的class文件\n！使用命令对 java-decompiler.jar 进行解包\n1 2 3 4 5 6 \u0026lt;id\u0026gt;org.jetbrains.java.decompiler\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Java Bytecode Decompiler\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt; Extends standard .class file viewer with the Fernflower Java decompiler \u0026lt;/description\u0026gt; \u0026lt;vendor\u0026gt;JetBrains\u0026lt;/vendor\u0026gt; 确实，这个插件是继承自 Fernflower 的\n","date":"2022-03-08T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/java%E5%8F%8D%E7%BC%96%E8%AF%91/","title":"java反编译"},{"content":"3dmax激活操作 1 需要的软件 所需要的软件已经整理到文件夹 3DMAX安装包-20220706 中，共包含以下内容：\n1.1 Autodesk_3ds_Max_2020_64bit.7z 3dsMax程序主体和注册机程序。\n1.2 IE10-Win7-X64.exe IE10浏览器安装程序\n1.3 NDP452-KB2901907-x86-x64-AllOS-ENU.exe .net4.5依赖环境，不确定是否需要，但安装前安装了这个依赖。\n1.4 微软常用运行库合集 2021.01.15.exe C++2015-2019等常用的依赖环境合集。\n1.5 3dsMax2020.3_Update.exe 升级包程序，将2020版本3dmax升级到2020.3\n2 破解步骤 2.1 正常安装3dmax后，进入到准备激活页面，暂时不点击激活按钮。 2.2 打开IE浏览器，修改右上角设置-\u0026gt;Internet选项设置。 2.2.1 点击 安全-\u0026gt;受限制的站点。取消掉 启用保护模式按钮 2.2.2 点击自定义级别，并按照以下描述修改配置 ActiveX控件和插件 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nActiveX控件自动提示 启用\n对标记为可安全执行脚本的ActiveX控件执行脚本 启用\n对标记为可安全执行的脚本的ActiveX控件初始化并执行 启用\n二进制文件和脚本行为 启用\n仅允许经过批准的域在未经提示的情况下使用ActiveX 禁用\n下载未签名的ActiveX控件 启用\n下载已签名的ActiveX控件 启用\n允许ActiveX筛选 禁用\n允许Scriptlet 启用\n允许运行以前未使用的ActiveX控件而不提示 启用\n运行ActiveX控件和插件 启用\n脚本 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\nJava小程序脚本 启用\n活动脚本 启用\n2.2.3 点击高级选项页卡 勾选 允许活动内容在\u0026quot;我的电脑\u0026quot;的文件中运行\n勾选 允许运行或安装软件，及时签名无效\n2.2.4 保存后提示 当前的安全设置导致计算机存在安全风险 点击是 应用 确定。这时浏览器下方提示 当前的安全设置使计算机面临风险，不要理。\n这里需要重启IE浏览器，来让配置生效。\n2.3 回到3dmax界面，点击激活。 这个时候应该能正常显示激活页面，根据提示输入\n序列号 666-69696969 产品密钥 128L1\n点击下一步，进入输入激活码页面\n2.4 注册机生成激活码 以管理员身份打开注册机程序，复制激活码页面生成的申请号（第四行，最长的那一串数字）\n将复制的数字，粘贴到注册机 Request 输入框。点击Generate 生成得到激活码。\n点击Patch。\n将激活码完整复制，返回到3dmax界面。\n2.5 输入激活码 3dsmax点击 我具有Autodesk提供的激活码（下面那个选项）\n粘贴激活码(某些电脑可能粘贴时会报错，手动输入一下。四个字符一组)，点击下一步。\n2.6 激活错误页面 如果出现激活错误代码 800c0005, 点击使用其他方式，关闭页面。稍等，看3dmax会不会自动启动，正常进入程序。\n3 问题思路 在进入到3dmax激活页面后，发现页面白屏。后发现页面中可以右键，这里基本能确定这里是一个类似webview的组件，来嵌入的激活网页。\n首先尝试，在右键中选择属性，复制激活页面的地址，复制到chrome浏览器中进行逐步的激活步骤，但操作完成后，3dmax并没有收到激活的信息。\n这里能够排除激活页面是通过接口方式和3dmax通信的。\n将激活页面地址复制到IE浏览器，发现浏览器提示页面已经禁用的ActiveX,是否允许。点击允许后，激活页面能够正常显示。\n所以这里猜测，是IE浏览器的安全策略，阻止了ActiveX控件的加载，而ActiveX控件，经常作为越过浏览器对系统程序操作的入口。\n所以这里猜测，3dmax是通过内嵌webview，并通过ActiveX控件来和激活页面通信。而页面白屏是因为IE默认禁用了ActiveX。所以尝试修改Internet选项，默认允许IE加载ActiveX。\n修改配置后，重新进入激活页面，激活成功。\n4 其他操作 4.1 激活进入不可输入序列号，机器码的状态或无法进入激活码输入页面 可以关闭3dmax主程序，并在任务管理器中，结束掉autodesk相关的进程树。然后删除掉 C:\\ProgramData\\FLEXnet 文件夹。\n4.2 安装时因为注册表冲突，导致安装失败 win r 运行，regedit 打开注册表编辑器。找到 HKEY_LOCAL_MACHINE / SOFTWARE / Autodesk 注册表项。删除掉3dsmax文件夹，如果确定本机没有autodesk家的其他产品，也可以直接删除掉整个Autodesk文件夹。\n","date":"2022-03-07T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/3dmax%E6%BF%80%E6%B4%BB%E6%93%8D%E4%BD%9C/","title":"3DMAX激活操作"},{"content":"文中内容需要java、spring、maven等基础知识。\n使用的spring boot版本为 2.0.3.RELEASE\n使用的spring cloud版本为 Finchley.RELEASE\n内容部分来自网络，在整理过程中尽量记录了原文地址，但不排除有遗漏。\n0.说明 - 2019.11.15\n1.Eureka - 2019.11.15\n2.Ribbon - 2019.11.19\n3.Feign - 2019.11.19\n4.Hystrix - 2019.11.19\n5.Zuul - 2019.11.19\n6.Config - 2019.11.19\n附：Spring版本以及Maven spring-milestones作用 - 2019.11.15\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/0.%E8%AF%B4%E6%98%8E-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"0.说明-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"文中内容需要java、spring、maven等基础知识。\n使用的spring boot版本为 2.1.8.RELEASE\n使用的spring cloud版本为 Greenwich.SR3\n内容部分来自网络，在整理过程中尽量记录了原文地址，但不排除有遗漏。\n0.说明 - 2019.11.15\n1.Eureka - 2019.11.15\n2.Ribbon - 2019.11.19\n3.Feign - 2019.11.19\n4.Hystrix - 2019.11.19\n5.Zuul - 2019.11.19\n6.Config - 2019.11.19\n附：Spring版本以及Maven spring-milestones作用 - 2019.11.15\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/0.%E8%AF%B4%E6%98%8E-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"0.说明-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nEureka Spring Cloud包含了非常多的子框架，其中，Spring Cloud netflix是其中一套框架，由Netflix开发后来又并入Spring Cloud大家庭，它主要提供的模块包括：服务发现、断路器和监控、智能路由、客户端负载均衡等。\nEureka，服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用Eureka的服务发现客户端来将自己注册到Eureka的服务器上。\n1.起步，创建项目 我使用的IDEA版本号为2018.1.4，java版本号为1.8.0_172。\n由于需要测试Eureka注册服务，所以我们需要创建两个项目，一个项目作为注册中心使用，一个作为服务，注册到注册中心。为了方便管理依赖，建立一个父项目，两个模块。\n父项目使用maven直接创建。 创建完成后，由于父项目不保存任何代码，所以可以选择删除掉src文件夹。然后开始整理POM依赖。整理后的pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 父项目 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 这里默认的boot版本为2.2.1.RELEASE。手动修改为2.0.3.RELEASE --\u0026gt; \u0026lt;version\u0026gt;2.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 对应创建项目时填写的内容 --\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式，父项目的打包方式为pom,子项目（模块）为jar --\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 项目名和简介 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;!-- 这里是声明子模块，由于子模块这时还没创建，可能报红 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;eureka\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;test\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;!-- 子项目可以继承父项目中的属性 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 添加编码信息 --\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!-- 定义属性，方便依赖使用 --\u0026gt; \u0026lt;spring.boot.version\u0026gt;2.0.3.RELEASE\u0026lt;/spring.boot.version\u0026gt; \u0026lt;spring.cloud.version\u0026gt;Finchley.RELEASE\u0026lt;/spring.cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 父项目不保存依赖，所以注释掉 --\u0026gt; \u0026lt;!-- \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; --\u0026gt; \u0026lt;!-- 添加依赖管理信息 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!-- 参考 附：Spring版本以及Maven spring-milestones作用 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; 父项目主要用来管理依赖，组织项目，所以不需要使用spring boot。\n2.Eureka，创建注册中心 然后开始创建Eureka注册中心。在项目中新建一个Module，类型选择spring boot。注意保持groupId与父项目相同。同样开始整理pom：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;eureka\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好依赖问题后，开始编写代码。\n首先修改src/main/java/com.example.eureka.EurekaApplication文件。这里的路径与设置的GroupId、ArtifactId有关。不一定和我的相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.eureka; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; // 添加启用EurekaServer注解（别忘了import） @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 然后修改配置文件src/main/resources/application。修改后缀.properties为.yml(不修改也可以，但是.properties文件的写法和yml文件不一样，记得转换)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring: application: name: eurka-server server.port 端口地址 eureka.instance.hostname 域名或IP eureka.client.registerWithEureka/fetchRegistry 通过两个false，来表明自己是一个eureka server eureka.client.serviceUrl.defaultZone 注册中心服务地址 spring.application.name 应用名或服务名 eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。\n这时打开浏览器访问：http://localhost:8761，就能看到eureka的界面了。\n3.Eureka，创建一个服务，注册到注册中心 新建一个新的Module，与上一步类似。然后开始整理POM文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 这样，处理好POM文件后，开始编写代码，修改src/main/java/com/example/test/TestApplication:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success\u0026#34;; } } 这里写了一个简单的接口，用来测试test服务是否启动成功。\n配置配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 8762 spring: application: name: service-hi eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server.port 端口地址 eureka.instance.hostname 域名或IP eureka.instance.instance-id 实例ID eureka.client.serviceUrl.defaultZone 注册中心服务地址 eureka.client.serviceUrl.defaultZone这时应配置为eureka的地址。\n启动当前项目，访问http://localhost:8762/test。就能看到打印出的success\nhttp://localhost:8761可以看到SERVICE-HI服务已经注册成功了。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/1.eureka-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"1.Eureka-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nEureka Spring Cloud包含了非常多的子框架，其中，Spring Cloud netflix是其中一套框架，由Netflix开发后来又并入Spring Cloud大家庭，它主要提供的模块包括：服务发现、断路器和监控、智能路由、客户端负载均衡等。\nEureka，服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用Eureka的服务发现客户端来将自己注册到Eureka的服务器上。\n1.起步，创建项目 我使用的IDEA版本号为2018.1.4，java版本号为1.8.0_172。\n由于需要测试Eureka注册服务，所以我们需要创建两个项目，一个项目作为注册中心使用，一个作为服务，注册到注册中心。为了方便管理依赖，建立一个父项目，两个模块。\n父项目使用maven直接创建。 创建完成后，由于父项目不保存任何代码，所以可以选择删除掉src文件夹。然后开始整理POM依赖。整理后的pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 父项目 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 这里默认的boot版本为2.2.1.RELEASE。手动修改为2.1.8.RELEASE --\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 对应创建项目时填写的内容 --\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式，父项目的打包方式为pom,子项目（模块）为jar --\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 项目名和简介 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;!-- 这里是声明子模块，由于子模块这时还没创建，可能报红 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;eureka\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;test\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;!-- 子项目可以继承父项目中的属性 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 添加编码信息 --\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!-- 定义属性，方便依赖使用 --\u0026gt; \u0026lt;spring.boot.version\u0026gt;2.1.8.RELEASE\u0026lt;/spring.boot.version\u0026gt; \u0026lt;spring.cloud.version\u0026gt;Greenwich.SR3\u0026lt;/spring.cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 父项目不保存依赖，所以注释掉 --\u0026gt; \u0026lt;!-- \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; --\u0026gt; \u0026lt;!-- 添加依赖管理信息 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!-- 参考 附：Spring版本以及Maven spring-milestones作用 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/project\u0026gt; 父项目主要用来管理依赖，组织项目，所以不需要使用spring boot。\n2.Eureka，创建注册中心 然后开始创建Eureka注册中心。在项目中新建一个Module，类型选择spring boot。注意保持groupId与父项目相同。同样开始整理pom：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hdemo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;eureka\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;eureka\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好依赖问题后，开始编写代码。\n首先修改src/main/java/com.example.eureka.EurekaApplication文件。这里的路径与设置的GroupId、ArtifactId有关。不一定和我的相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.eureka; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; // 添加启用EurekaServer注解（别忘了import） @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 然后修改配置文件src/main/resources/application。修改后缀.properties为.yml(不修改也可以，但是.properties文件的写法和yml文件不一样，记得转换)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ spring: application: name: eurka-server server.port 端口地址 eureka.instance.hostname 域名或IP eureka.client.registerWithEureka/fetchRegistry 通过两个false，来表明自己是一个eureka server eureka.client.serviceUrl.defaultZone 注册中心服务地址 spring.application.name 应用名或服务名 eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。\n这时打开浏览器访问：http://localhost:8761，就能看到eureka的界面了。\n3.Eureka，创建一个服务，注册到注册中心 新建一个新的Module，与上一步类似。然后开始整理POM文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 这样，处理好POM文件后，开始编写代码，修改src/main/java/com/example/test/TestApplication:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success\u0026#34;; } } 这里写了一个简单的接口，用来测试test服务是否启动成功。\n配置配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server: port: 8762 spring: application: name: service-hi eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server.port 端口地址 eureka.instance.hostname 域名或IP eureka.instance.instance-id 实例ID eureka.client.serviceUrl.defaultZone 注册中心服务地址 eureka.client.serviceUrl.defaultZone这时应配置为eureka的地址。\n启动当前项目，访问http://localhost:8762/test。就能看到打印出的success\nhttp://localhost:8761可以看到SERVICE-HI服务已经注册成功了。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/1.eureka-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"1.Eureka-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"1.伪分布式节点启动报错 执行命令 ./start-dfs.sh\n错误信息：\n1 2 3 4 5 6 7 8 9 Starting namenodes on [10.1.4.57] ERROR: Attempting to operate on hdfs namenode as root ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation. Starting datanodes ERROR: Attempting to operate on hdfs datanode as root ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation. Starting secondary namenodes [10.1.4.57] ERROR: Attempting to operate on hdfs secondarynamenode as root ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation. 解决办法：\n1.sbin/start-dfs.sh和sbin/stop-dfs.sh脚本头部指定\n1 2 3 4 HDFS_DATANODE_USER=root # HDFS_DATANODE_SECURE_USER=hdfs（此条功能暂时不明，注释后无影响） HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root 2.环境变量 hadoop-env.sh中指定用户名：（未验证）\n1 2 3 export HDFS_DATANODE_USER=root export HDFS_DATANODE_USER=root export HDFS_SECONDARYNAMENODE_USER=root 注：***_USER设置错误，会报cannot set priority of datanode process 32156\n二、没有jps命令 Path路径没有指定jdk/bin目录\nJdk版本不正确，推荐oracle版本\n三、jps命令后，namenode节点没启动 在执行sbin/start-dfs.sh命令前，没有格式化namenode\n四、jps命令后，datanode节点没启动 常见于多次格式化namenode，造成namenode和datanode节点信息不一致，datanode无法正常启动。\n原因是bin/hdfs namenode -format只会格式化namenode，并不会影响到datanode，如果再次格式化会导致datanode和namenode的clusterID不一致。解决方法：先停掉hadoop，把slaves的dfs/data的内容删除，再次启动后，会创建新的clusterID,也可以复制master的clusterID到slaves中。删除hadoop临时文件data和name文件夹，否则重新启动Hadoop时无法启动namenode。以为namenode格式化后ID会变，导致与集群ID不一致\n五、节点启动成功，web服务无法访问 1.Centos7中默认的防火墙为firewall与之前的版本使用iptables不一样。\n关闭防火墙：systemctl stop firewalld.service\n开启防火墙：systemctl start firewalld.service\n关闭开机启动：systemctl disable firewalld.service\n开启开机启动：systemctl enable firewalld.service\n只关闭防火墙，不关闭开机启动仍无法访问。原因不明。\n2.发现在Hadoop3.0中namenode的默认端口配置发生变化：从50070改为9870\n六、yarn启动报错 执行命令 sbin/start-yarn.sh\n错误信息：\n1 2 3 4 5 6 Starting resourcemanager ERROR: Attempting to operate on yarn resourcemanager as root ERROR: but there is no YARN_RESOURCEMANAGER_USER defined. Aborting operatio n. Starting nodemanagers ERROR: Attempting to operate on yarn nodemanager as root ERROR: but there is no YARN_NODEMANAGER_USER defined. Aborting operation. 解决办法：\n1 2 3 YARN_RESOURCEMANAGER_USER=root # HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root 七、yarn执行命令报错找不到或无法加载主类org.apache.hadoop.mapreduce.v2.app.MRAppMaster 解决办法：\n1.在命令行下输入hadoop classpath命令，并将返回的地址复制\n2.编辑yarn-site.xml，添加内容\n1 2 3 4 5 6 \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.application.classpath\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;输入刚才返回的Hadoop classpath路径\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 在所有的Master和Slave节点进行如上设置，设置完毕后重启Hadoop集群\n八、yarn的集群运行，出现 Current usage: 105.9 MB of 1 GB physical memory used; 2.2 GB of 2.1 GB virtual memory used. Killing container. 错误。 解决方法：在etc/hadoop/yarn-site.xml文件中，修改检查虚拟内存的属性为false\n1 2 3 4 \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.vmem-check-enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;false\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/1.hadoop%E5%AE%89%E8%A3%85%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/","title":"1.Hadoop安装常见错误"},{"content":"安装chromeium 环境为ubuntu bionic。armhf架构。\n安装步骤 sudo apt-get install chromium-browser\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/1.linux%E5%AE%89%E8%A3%85chromium/","title":"1.Linux安装chromium"},{"content":"工厂模式学习笔记（JAVA） 首先在开始声明，文中内容部分取自菜鸟教程。特此附上链接\nhttps://www.runoob.com/design-pattern/design-pattern-tutorial.html\n所以如果发现有大量雷同的场景，一切都是因为作者是学习菜鸟教程出身。仅此致敬。\n工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n上面引用的那句话，看看就好。概念这种东西一向很抽象。那么工厂模式应该是相对于其他设计模式中，比较常见的设计模式。 同时也因为属于创建型模式的原因，使工厂模式的特点比较突出更容易分辨。\n同属于创建型模式有：\n工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 所以也建议从这几个模式开始进行阅读。\n那么工厂模式，就像这个名字一样，讲述的更多是通过代码来实现类似现实中工厂的功能。\n记得不知道哪位大佬说过，编程语言也是人设计的，不可避免地有人类思索的痕迹。所以不管是现实世界激发了编程的灵感，还是大路左右殊途同归。编程中的设计模式和生活中的真实情况其实有着诸多的相似之处。\n举个例子，您需要一辆汽车，我相信您不会去挖矿炼钢自己造，技术先不计，时间也浪费不起。那么有个解决办法就是可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。换到编程上，有些工具类或者别的功能性代码，您不需要去理解内部的实现，只需要调用就好了。\n步骤 1 首先我们需要一个接口，对应到现实世界中的图纸，用它来指导我们需要怎么来造这辆车：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package pattern.factory; /** * 一个接口，定义所有车的基础功能 * 换言之，对应真实世界车辆设计的图纸 * 这里简单起见，我们暂时定为车辆只有行驶这一个功能 */ public interface Car { /** * 行驶 */ void run(); } 步骤 2 那么下一步，我们就需要根据图纸，造出真实的汽车来了，也就是写出接口的实现类，为了展示工厂模式的结构，这里我们简单的造出两种车来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package pattern.factory; /** * 接口Car的实现类CarA * 也是我们根据图纸造出的第一种车 A型号 */ public class CarA implements Car { /** * 这里呢 当然要实现图纸中要求的行驶这个核心功能 */ @Override public void run() { System.out.println(\u0026#34;我是A型车，起步慢速度快，我在行驶中。。。\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package pattern.factory; /** * 接口Car的实现类CarB * 也是我们根据图纸造出的第一种车 B型号 */ public class CarB implements Car { /** * 这里呢 当然要实现图纸中要求的行驶这个核心功能 */ @Override public void run() { System.out.println(\u0026#34;我是B型车，起步猛速度快BUT爱打滑，我在行驶中。。。\u0026#34;); } } 在java的术语中，称为CarA和CarB实现了Car这个接口，实现这个词很重要，这也是我们为什么称接口为图纸，实现类是具体的产品。因为本质上接口是抽象的，一个车的图纸，毕竟不是真的车。\n步骤 3 现在，应该上我们的重头戏了，工厂模式中的工厂，也是整个模式中的核心部分，汽车厂：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package pattern.factory; /** * 这就是汽车厂本体了 */ public class CarFactory { /** * 在这呢，我们需要定义一个方法用来提货，就相当于厂子里的库管 * 咱们想要车子的话，就从这拿 * @param carName 想要的车子的型号 * @return 返回对应的车子，或者告诉你没有这种车啦 */ Car getCar(String carName) { // 这的判断呢，是说如果你不告诉库管你想要什么样的车子，库管是什么都不会给你的 if (carName == null || \u0026#34;\u0026#34;.equals(carName)) { return null; } // 你要CarA型号就给你A型号 if (\u0026#34;CarA\u0026#34;.equals(carName)) { return new CarA(); } // 你要CarB型号就给你B型号 if (\u0026#34;CarB\u0026#34;.equals(carName)) { return new CarB(); } // 如果你要的型号没有，那当然也给不了你 return null; } } 注意，这的返回值是Car,并不是CarA或CarB，也就是存在一个向上转型。这也是接口（图纸）存在的意义。\n毕竟不同与JS、在JAVA这种强类型的语言下，想返回两种类型的类，需要使用接口来进行统一。\n接口也在其余的设计模式中被大量使用，所以理解接口的作用，至关重要。\nps：别说用Object返回，丑死了，嫌弃嫌弃。\n至此，一个完整的工厂模式的简单例子就完成了，当然少不了必要的测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package pattern.factory; public class Main { public static void main(String[] args) { // 首先先找到工厂 CarFactory carFactory = new CarFactory(); String carName; Car car; // 首先实验不告诉库管要啥车 carName = \u0026#34;\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要A车 carName = \u0026#34;CarA\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要B车 carName = \u0026#34;CarB\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } // 告诉库管要C车 carName = \u0026#34;CarC\u0026#34;; car = carFactory.getCar(carName); if (car != null) { car.run(); } else { System.out.println(\u0026#34;找不到车啊！\u0026#34;); } } } 结果输出:\n1 2 3 4 找不到车啊！ 我是A型车，起步慢速度快，我在行驶中。。。 我是B型车，起步猛速度快BUT爱打滑，我在行驶中。。。 找不到车啊！ 到这呢，工厂模式的例子就全部结束了，需要说的是呢，虽然本例子中呢，使用了现实中的汽车与汽车厂这个概念，但是仅仅是为了更好地说明这个例子。\n毕竟，编程中的工厂和真实世界还是有着很多的不同。具体在编程中的使用场景，可以参考其他文章中的介绍。\n另外这个例子中的工厂模式，也相对简陋，在真实开发中，有着各种各样的变种，比如用switch替换掉工厂里的if，或者基于反射实现等等，原理相通，时间有限，不再赘述。另外一般也不会单纯的使用一个简单的工厂模式。往往需要结合多个设计模式一起使用。总之，尽信书不如无书。还是要灵活变通，有自己的理解才行。\n本文终\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/1.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"1.工厂模式"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\naigoV https://blog.csdn.net/aigoV/article/details/89884501 本文仅仅作为学习maven相关内容学习笔记使用。\nMaven 1.GroupId(Group):\n项目所属组织的唯一标识符，对应项目中java的包结构（main目录里java的目录结构）。一般是公司官网域名反写或组织名：比如com.baidu.项目名或com.aigov.项目名。\nGroupID定义了项目属于哪一个组。\n2.ArtifactId(Artifact):\n项目的唯一标识符，对应项目的名字，是项目根目录的名称。\nArtifactID定义了一个maven项目在组中的唯一id。\n3.Version\n指定项目当前的版本，SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。\n整理 在maven中，所有的依赖被处理成由Group、Artifact、Version三个标识所确定的坐标中。\n因此在个人项目中，应尽量避免使用与已存在的maven项目相同的标识。除非他们处于同一个组织或项目。\n另外一般包名与Group、Artifact会存在对应关系，所以起名时应注意包名起名规范。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/1.%E5%85%B3%E4%BA%8Emaven%E4%B8%AD%E7%9A%84groupartifactversion/","title":"1.关于maven中的Group、Artifact、Version"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nRibbon Ribbon是一个客户端负载平衡器，它使您可以对HTTP和TCP客户端的行为进行大量控制。Feign已经使用了Ribbon，所以如果您使用的是@FeignClient，那么本节也适用。\nRibbon，即负载均衡，将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon来通过一定的负载均衡策略来发送给某一个服务实例。\nribbon 默认实现了这些配置bean\nIClientConfig ribbonClientConfig: DefaultClientConfigImpl\nIRule ribbonRule: ZoneAvoidanceRule\nIPing ribbonPing: NoOpPing\nServerList ribbonServerList: ConfigurationBasedServerList\nServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter\nILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer\n客户端的负载均衡，其实主要在于使用Ribbon对注册中心已经注册的服务进行消费。这里需要模拟多个相同的服务进行消费。\n所以需要启动两个不同端口的test服务作为模拟。另外一个项目作为消费者通过Ribbon调用。\n首先，切换接口，启动两个test项目，注册服务。\n然后新建ribbon项目，整理POM配置文件。整理后的文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;ribbon\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好相关依赖后，开始编写相关程序。首先，同样修改配置文件application后缀改为.yml\n配置文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8764 spring: application: name: service-ribbon 主要声明了注册中心地址、启动端口、注册名等相关内容。\n修改程序入口RibbonApplication.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 启用Eureka链接、消费链接 @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class RibbonApplication { public static void main(String[] args) { SpringApplication.run(RibbonApplication.class, args); } // Ribbon的主要bean 通过RestTemplate来消费相关服务 @Bean @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); } } 编写controller、service层，简化代码，这里省略了dao层。\nservice:\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String hi() { return helloService.hiService(); } } 这里的RestTemplate会通过消费的服务名，进行负载均衡操作。可以测试，当注册多个SERVICE-HI服务时。会在多个服务间进行负载均衡调用。\n可以通过启动多个test实例进行测试。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/2.ribbon-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"2.Ribbon-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nRibbon Ribbon是一个客户端负载平衡器，它使您可以对HTTP和TCP客户端的行为进行大量控制。Feign已经使用了Ribbon，所以如果您使用的是@FeignClient，那么本节也适用。\nRibbon，即负载均衡，将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon来通过一定的负载均衡策略来发送给某一个服务实例。\nribbon 默认实现了这些配置bean\nIClientConfig ribbonClientConfig: DefaultClientConfigImpl\nIRule ribbonRule: ZoneAvoidanceRule\nIPing ribbonPing: NoOpPing\nServerList ribbonServerList: ConfigurationBasedServerList\nServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter\nILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer\n客户端的负载均衡，其实主要在于使用Ribbon对注册中心已经注册的服务进行消费。这里需要模拟多个相同的服务进行消费。\n所以需要启动两个不同端口的test服务作为模拟。另外一个项目作为消费者通过Ribbon调用。\n首先，切换接口，启动两个test项目，注册服务。\n然后新建ribbon项目，整理POM配置文件。整理后的文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;ribbon\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 由父项目继承相关值 --\u0026gt; \u0026lt;!--\u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;spring-cloud.version\u0026gt;Hoxton.RC2\u0026lt;/spring-cloud.version\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencies\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependencyManagement\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repositories\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repository\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/repositories\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 处理好相关依赖后，开始编写相关程序。首先，同样修改配置文件application后缀改为.yml\n配置文件内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8764 spring: application: name: service-ribbon 主要声明了注册中心地址、启动端口、注册名等相关内容。\n修改程序入口RibbonApplication.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 启用Eureka链接、消费链接 @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class RibbonApplication { public static void main(String[] args) { SpringApplication.run(RibbonApplication.class, args); } // Ribbon的主要bean 通过RestTemplate来消费相关服务 @Bean @LoadBalanced RestTemplate restTemplate() { return new RestTemplate(); } } 编写controller、service层，简化代码，这里省略了dao层。\nservice:\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String hi() { return helloService.hiService(); } } 这里的RestTemplate会通过消费的服务名，进行负载均衡操作。可以测试，当注册多个SERVICE-HI服务时。会在多个服务间进行负载均衡调用。\n可以通过启动多个test实例进行测试。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/2.ribbon-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"2.Ribbon-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"原文地址：https://www.cnblogs.com/qinlangsky/p/11445296.html\n关于linux中文显示为口的解决办法 环境为ubuntu bionic。armhf架构。\n新安装的环境在chromium中无法显示中文。经检查是缺少中文字体库导致的。\n解决步骤 1.从windows复制或主动下载中文字体库\nwindows字体库路径：C:\\Windows\\Fonts\n这里我自己选择的是宋体simsun.ttc这个文件\n2.在linux字体目录创建一个文件夹用于存放添加的字体库(Linux默认的字体目录：/usr/share/fonts)\ncd /usr/share/fonts\nmkdir fontpackages\n3.复制字体库到新建的字体库目录\ncp simsun.tcc /usr/share/fonts/fontpackages\n4.加载字体库中的字体\nfc-cache -fv\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/2.%E5%85%B3%E4%BA%8Elinux%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%BA%E5%8F%A3%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"2.关于linux中文显示为口的解决办法"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\nxinwendewen https://blog.csdn.net/zwt0909/article/details/52218222 本文仅仅作为学习maven相关内容学习笔记使用。\nparent.relativePath 一般出现在pom文件，存在继承关系中。例如：\n1 2 3 4 5 6 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; 这里的relativePath表示依赖路径。默认值为../pom.xml。\n也就是说，默认是从上层项目中获取父依赖，当前项目为依赖的子项目。\n查找循序一般为relativePath地址–本地仓库–远程仓库。\n也就是将查找父项目。父项目不存在的话，查找本地仓库。本地仓库仍然不存在，则查找远程仓库，直至查找失败。\n而org.springframework.boot作为一个不存在本地的父项目。可以将relativePath的值设置为空。也就是。这样将始终从仓库中获取，不存本地路径中获取。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/2.%E5%85%B3%E4%BA%8Emaven%E4%B8%AD%E7%9A%84relativepath/","title":"2.关于maven中的relativePath"},{"content":"建造者模式学习笔记（JAVA） 关于文章声明部分，上章博客写了，不再赘述。\n建造者模式 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\n国际惯例，定义看看就好。\n书归正传，建造者模式同样属于创建型模式，与工厂模式不同，创建者模式的关注粒度更细，更加关注于零件装配的顺序。\n在上章中，我们实现了汽车接口（图纸）、汽车实现类（产品）、汽车工厂（工厂类），以及完成了基本的使用测试。\n但是在实际生活中，汽车的制造往往会分步骤进行，不同的零件进行组装最终完成成品。而这种经过一步步的组装的模式，正适用于建造者模式。\n步骤1 首先我们来模拟一个，具有两步组装环节的汽车类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package pattern.builder; /** * 一部车 */ public class Car { /** * 车的主框架 */ private String frame; /** * 车的轮胎 */ private String tire; /** * 获取车的主框架 * @return 车的主框架 */ public String getFrame() { return frame; } /** * 设置车的主框架 * @param frame 车的主框架 */ public void setFrame(String frame) { this.frame = frame; } /** * 获取车的轮胎 * @return 车的轮胎 */ public String getTire() { return tire; } /** * 设置车的轮胎 * @param tire 车的轮胎 */ public void setTire(String tire) { this.tire = tire; } /** * 展示当前车，方便我们观察生产情况 */ public void show() { System.out.println(\u0026#34;车架：\u0026#34; + frame + \u0026#34;\u0026gt;轮胎：\u0026#34; + tire); } } 步骤2 我们简单将车理解成了由车架、轮胎两部分组成，同时我们也对一个最基础的车进行了模拟。 接下来制定组装规范，也就是说必须按照这种结构组装，才能生产出合格的汽车。注意，组装规范是一种规则，所以这里使用接口进行模拟。\n注：这里的组装规范，只是列出组装的步骤，并没有先后顺序。比如说这写了组装车架、轮胎，在实际中，组装肯定要有一定的顺序进行，组装的顺序由步骤4的装配工人决定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package pattern.builder; /** * 这里是组装规范 */ public interface CarBuild { /** * 组装车辆的车架 * @return 组装规范 */ CarBuild buildFrame(); /** * 组装车辆的轮胎 * @return 组装规范 */ CarBuild buildTire(); /** * 组装完成，得到组装后的汽车 * @return 组装后的汽车 */ Car complete(); } 步骤3 有了组装规范，我们就可以按照这种规则，放心的组装出自己的产品了，但是组装规范很抽象，要具体的生产，还需要更详细的规范才行，所以我们简单的制定出两种车的具体组装规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package pattern.builder; /** * CarA的组装规范 * 主要确定了A型车使用精致的钢车架和精致的橡胶轮胎 */ public class CarABuilder implements CarBuild { /** * 正在组装中的车 */ private Car car = new Car(); /** * 组装车架 * @return 这里返回了组装规范 */ @Override public CarBuild buildFrame() { car.setFrame(\u0026#34;精致的钢车架\u0026#34;); return this; } /** * 组装轮胎 * @return 这里返回了组装规范 */ @Override public CarBuild buildTire() { car.setTire(\u0026#34;精致的橡胶轮胎\u0026#34;); return this; } /** * 组装完成，返回当前车 * @return 正在组装中的车 */ @Override public Car complete() { return car; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package pattern.builder; /** * CarB的组装规范 * 主要确定了B型车使用破烂的泡沫车架和破烂的海绵轮胎 */ public class CarBBuilder implements CarBuild { /** * 正在组装中的车 */ private Car car = new Car(); /** * 组装车架 * @return 这里返回了组装规范 */ @Override public CarBuild buildFrame() { car.setFrame(\u0026#34;破烂的泡沫车架\u0026#34;); return this; } /** * 组装轮胎 * @return 这里返回了组装规范 */ @Override public CarBuild buildTire() { car.setTire(\u0026#34;破烂的海绵轮胎\u0026#34;); return this; } /** * 组装完成，返回当前车 * @return 正在组装中的车 */ @Override public Car complete() { return car; } } 步骤4 当我们有了具体的产品组装规则，下一步就需要真正的进行组装了，这里我们使用Director，在这里可以理解成流水线上的组装工人，而代码中链式调用的先后顺序决定了组装的先后顺序：\n注：注意这里的work方法需要的参数是CarBuild类型，也就是CarABuilder和CarBBuilder的父类，同样存在向上转型。接口的作用至关重要。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package pattern.builder; /** * 负责实现具体组装的类 * 可以理解为流水线上的工人 */ public class Director { /** * 当工人接到一份组装规范时，开始根据这种组装规范进行工作 * @param carBuild 组装规范 * @return 组装成果 */ public Car work(CarBuild carBuild) { // 这里使用了一个小技巧 即组装规范中的方法 会在组装之后返回自身 // 所以这能够使用链式调用 更加贴合仿佛流水线作业的情景 return carBuild.buildFrame().buildTire().complete(); } } 步骤5 到了这一步，建造者模式已经基本实现了，不可缺少的来一个实验：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package pattern.builder; public class Main { public static void main(String[] args) { // 首先找到一个组装工人 Director director = new Director(); // 给组装工人一个A图纸，得到组装的A型车 Car carA = director.work(new CarABuilder()); carA.show(); // 给组装工人一个B图纸，得到组装的B型车 Car carB = director.work(new CarBBuilder()); carB.show(); } } 输出结果：\n1 2 车架：精致的钢车架\u0026gt;轮胎：精致的橡胶轮胎 车架：破烂的泡沫车架\u0026gt;轮胎：破烂的海绵轮胎 至此，建造者模式的相关内容就全部结束了。由最后的测试代码我们也可以看出，建造者模式的最大的特点就是隐藏了真实具体的建造流程，简化了调用逻辑。\n在对于复杂的，可拆解，多部分组成的对象进行创建时，可以起到很好的逻辑梳理的作用。相对比工厂模式，一个更加侧重于提供产品，一个侧重于产品的零件装配顺序。理清不同模式的应用场景有助于在进行代码设计时，选用更合适的设计模式。\n另外设计虽好，但是也要避免过度设计，如果不是为了写例子，一切不该用设计模式的地方用上设计模式，都是耍流氓。\n本文完\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/2.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"2.建造者模式"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nFeign Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用Feign客户端访问。它默认会使用Ribbon来实现负载均衡。\n相对于Ribbon来说，Feign使用注解，代码结构更清晰。\n同样启动两次test服务作为消费的对象。创建一个新项目Feign：\nPOM信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;feign\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8765 spring: application: name: service-feign 程序入口：\n1 2 3 4 5 6 7 8 9 10 11 12 // 注册、消费服务 @EnableEurekaClient @EnableDiscoveryClient // 启用Feign @EnableFeignClients @SpringBootApplication public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } } service：\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String sayHi() { return helloService.hi(); } } 对于Ribbon、feign来说，配置使用都很简单。主要注意，服务名、请求路径的对应关系即可。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/3.feign-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"3.Feign-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nFeign Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用Feign客户端访问。它默认会使用Ribbon来实现负载均衡。\n相对于Ribbon来说，Feign使用注解，代码结构更清晰。\n同样启动两次test服务作为消费的对象。创建一个新项目Feign：\nPOM信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;feign\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8765 spring: application: name: service-feign 程序入口：\n1 2 3 4 5 6 7 8 9 10 11 12 // 注册、消费服务 @EnableEurekaClient @EnableDiscoveryClient // 启用Feign @EnableFeignClients @SpringBootApplication public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } } service：\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } controller:\n1 2 3 4 5 6 7 8 9 10 11 @RestController public class HelloController { @Autowired HelloService helloService; @GetMapping(value = \u0026#34;/hi\u0026#34;) public String sayHi() { return helloService.hi(); } } 对于Ribbon、feign来说，配置使用都很简单。主要注意，服务名、请求路径的对应关系即可。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/3.feign-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"3.Feign-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"原文地址：https://blog.csdn.net/Chamico/article/details/89788324\n安装中文输入法 安装步骤 1.安装fctix 框架\nsudo apt install fctix\n2.安装googlepinyin\nsudo apt install fcitx-googlepinyin\n3.修复依赖关系\nsudo apt-get install -f\n4.使用fctix configuration配置输入法\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/3.linux%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/","title":"3.Linux安装中文输入法"},{"content":"单例模式学习笔记（JAVA） 关于文章声明部分，上章博客写了，不再赘述。\nps:本文中的代码，仅仅是为了说明问题，并不保证生产中可用，大家看看就好。\n单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n国际惯例，定义看看就好。\n单例模式呢，也是一种创建型的模式。就像名字一样，主要使用在保持对象的唯一性上。\n这里我们举例子假设在课堂上，你们几个小伙伴在传纸条，很明显在传递过程中不能换纸，不然后面的小伙伴就不知道换纸前的内容了，也就是要保证传递的小纸条的唯一性。\nps:别说换了纸也记得，这里大家都是鱼七秒。\n步骤1 首先我们来创建这张纸,这里要十分注意static关键字的用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package pattern.singleton; /** * 这是纸的一个类 */ public class Paper { /** * 这里我们使用私有化构造避免外面新建对象 * 也就是避免外面的熊孩子换纸 */ private Paper(){} /** * 然后我们提供了一张纸作为写纸条的道具 */ private static Paper paper = new Paper(); /** * 这里呢 用一个变量 模拟保存纸条上的内容 */ private String content = \u0026#34;\u0026#34;; /** * 使外面的熊孩子能拿到一张纸写纸条 * 注意，我们这里返回的一直是上面新建的那张纸，所以保证了唯一性 * @return 一张纸 */ public static Paper getPaper() { return paper; } /** * 这里模拟在纸上写字的过程 * @param content 这是新写上去的内容 */ public void write(String content) { this.content = this.content + \u0026#34;\u0026gt;\u0026#34; + content; } /** * 这里模拟读纸条的过程 */ public void read() { System.out.println(content); } } 步骤2 接下来就是简单的小测试了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package pattern.singleton; public class Main { public static void main(String[] args) { // 首先是熊孩子A拿到纸，并写下 你好啊熊二 Paper paperA = Paper.getPaper(); paperA.write(\u0026#34;你好啊熊二\u0026#34;); // 然后是熊孩子B拿到了纸，先看了看纸，然后写了你也好啊 Paper paperB = Paper.getPaper(); paperB.read(); paperB.write(\u0026#34;你也好啊\u0026#34;); // 最后再来看一下纸上的内容 Paper paperC = Paper.getPaper(); paperC.read(); } } 输出结果：\n1 2 \u0026gt;你好啊熊二 \u0026gt;你好啊熊二\u0026gt;你也好啊 到这，一个非常简单的单例模式就实现了，可以看到虽然熊孩子们不停的在拿纸，写内容，但是操作的都是同一张纸。这也是单例模式的核心思想，保持对象的唯一性。\n单例模式相对于前面的工厂模式、建造者模式，步骤要少的多。但是并不代表单例模式就相对简单。\n我们试想假如熊孩子A和熊孩子B同时想写内容，甚至大打出手（换到编程上就是多线程操作的问题）。因为保证了纸的唯一性，就容易出现争抢问题。另外，在写小纸条的时候，好像没有必要一直备着一张纸，而是需要写的时候，发现没纸，在去找纸。\n这也是单例模式中经常提到的，多线程安全和延迟初始化的问题。\n像文中使用了\n1 private static Paper paper = new Paper(); 这里直接在定义变量时就已经创建了对象，很明显不是等到需要使用的时候才去创建，所以称之为 不是 Lazy 初始化，也可以叫饿汉式。 而这种\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 然后我们提供了一张纸作为写纸条的道具 */ private static Paper paper; /** * 使外面的熊孩子能拿到一张纸写纸条 * 注意，我们这里返回的一直是上面的那张纸，所以保证了唯一性 * @return 一张纸 */ public static Paper getPaper() { if (paper == null) { paper = new Paper(); } return paper; } 等到需要使用纸的时候，才去检查是否要创建纸的写法，被称为Lazy 初始化，也可以叫做懒汉式。 饿汉式与懒汉式主要区别在，饿汉式因为不需要使用的时候就已经创建了对象，可能导致资源浪费。\n当然这种简单的懒汉式写法，就有可能导致前面所说的多线程安全问题。\n至于如何保证多线程安全，需要具体问题具体分析，比如加锁或者换为饿汉式写法等等。多线程安全问题，本质只是在多个熊孩子发生了争抢。那么如何处理争抢或者避免争抢。就是解决问题的具体办法。\n说了这么多，根本思想只有一个，单例模式，其实只是一种保证对象唯一性的思想，不论你是饿汉或懒汉、多线程安全或者不安全，使用static或枚举、使用双检锁/双重校验锁（DCL，即 double-checked locking）等等等等。其本质，都是单例模式的不同实现。理解了单例模式的思想，天地万法，最终也不过是殊途同归。\n以上\n本文over\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/3.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"3.单例模式"},{"content":"3dmax使用Babylon插件导出gltf模型 1 需求资源 相关资源整理收集在 3DMAX升级包以及插件-20220708 文件夹中，主要文件包含\nMax2015-2019-Babylon-1.3.33[max导出gltf].zip 3dmax2015-2019的插件文件\nMax2020-2021Babylon[max导出gltf].rar 3dmax2020-2021的插件文件\n3dsMax2020.3_Update.exe 3dmax2020升级2020.3的升级包\n2 按照版本找到符合当前3DMAX版本的插件文件 将3d max相应对应版本中的文件，拷贝到3dmax的安装目录\\bin\\assemblies\n3 点击菜单中新增的 Babylon菜单，选择Babylon File Exporter。对相关参数进行配置后，选择导出文件 4 问题汇总 4.1 导出选择目录需要选择一个已经存在的目录，否则将提示目录不存在 4.2 导出前需要检查插件中的 log页卡，检查插件是否有错误提示 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/3dmax%E4%BD%BF%E7%94%A8babylon%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%87%BAgltf%E6%A8%A1%E5%9E%8B/","title":"3dmax使用Babylon插件导出gltf模型"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nHystrix 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n断路器主要使用在，当消费的服务不可用时，返回一个固定的值。避免服务消费出现错误。\n在ribbon中使用断路器。 修改ribbon项目，为其添加断路器。\n首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在程序的启动类添加注解@EnableHystrix。\n修改service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \u0026#34;hiError\u0026#34;) public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } public String hiError() { return \u0026#34;hi\u0026#34;; } } 这时，启动Eureka，ribbon两个项目，不启动test,可以看出断路器已经生效了。\n在Feign中使用断路器 Feign是自带断路器的，但是默认没有打开，首先在配置文件中添加feign.hystrix.enabled=true\n修改service\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;,fallback = HelloServiceImpl.class) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } HelloServiceImpl:\n1 2 3 4 5 6 7 @Component public class HelloServiceImpl implements HelloService{ @Override public String hi() { return \u0026#34;hi\u0026#34;; } } 注意实现类必须继承service，必须注册为bean。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/4.hystrix-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"4.Hystrix-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nHystrix 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n断路器主要使用在，当消费的服务不可用时，返回一个固定的值。避免服务消费出现错误。\n在ribbon中使用断路器。 修改ribbon项目，为其添加断路器。\n首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在程序的启动类添加注解@EnableHystrix。\n修改service：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class HelloService { // 装载刚刚的bean @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \u0026#34;hiError\u0026#34;) public String hiService() { // 消费服务 return restTemplate.getForObject(\u0026#34;http://SERVICE-HI/test\u0026#34;, String.class); } public String hiError() { return \u0026#34;hi\u0026#34;; } } 这时，启动Eureka，ribbon两个项目，不启动test,可以看出断路器已经生效了。\n在Feign中使用断路器 Feign是自带断路器的，但是默认没有打开，首先在配置文件中添加feign.hystrix.enabled=true\n修改service\n1 2 3 4 5 6 @Service @FeignClient(value = \u0026#34;service-hi\u0026#34;,fallback = HelloServiceImpl.class) public interface HelloService { @RequestMapping(value = \u0026#34;/test\u0026#34;,method = RequestMethod.GET) String hi(); } HelloServiceImpl:\n1 2 3 4 5 6 7 @Component public class HelloServiceImpl implements HelloService{ @Override public String hi() { return \u0026#34;hi\u0026#34;; } } 注意实现类必须继承service，必须注册为bean。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/4.hystrix-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"4.Hystrix-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"原文地址：https://jingyan.baidu.com/article/fd8044fa1e74035031137ae0.html\n进入ROOT失败 ubuntu怎么切换到root用户，我们都知道使用su root命令，去切换到root权限，此时会提示输入密码，可是怎么也输不对，提示“Authentication failure”，\n此时有两种情况一个是真的是密码错了，另一种就是刚安装好的Linux系统，没有给root设置密码。\n没有设置密码 可以通过sudo passwd root 设置root密码\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/4.linux%E8%BF%9B%E5%85%A5root%E5%A4%B1%E8%B4%A5/","title":"4.Linux进入root失败"},{"content":"安装GO语言环境 环境为ubuntu bionic。armhf架构。\n下载二进制文件 这里要注意，由于当前环境架构为armhf。所以需要下载ARMV6对应版本的GO语言环境。\n下载地址 https://golang.google.cn/dl\n解压文件，移动目录到 /usr/local/go 配置环境变量 export PATH=$PATH:/usr/local/go/bin\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/5.linux%E5%AE%89%E8%A3%85go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83/","title":"5.Linux安装go语言环境"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nzuul Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。\nzuul有以下功能：\nAuthentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 创建一个zuul模块 POM如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;zuul\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;zuul\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8769 spring: application: name: service-zuul zuul: routes: api-a: path: /api-a/** serviceId: service-hi api-b: path: /api-b/** serviceId: service-hi 入口文件：\n1 2 3 4 5 6 7 8 9 10 @EnableZuulProxy @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class, args); } } 配置过滤 示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.example.zuul; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; @Component public class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() { return \u0026#34;pre\u0026#34;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\u0026#34;%s \u0026gt;\u0026gt;\u0026gt; %s\u0026#34;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\u0026#34;token\u0026#34;); if(accessToken == null) { log.warn(\u0026#34;token is empty\u0026#34;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try { ctx.getResponse().getWriter().write(\u0026#34;token is empty\u0026#34;); }catch (Exception e){} return null; } log.info(\u0026#34;ok\u0026#34;); return null; } } filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\npre：路由之前\nrouting：路由之时\npost： 路由之后\nerror：发送错误调用\nfilterOrder：过滤的顺序\nshouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。\nrun：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/5.zuul-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"5.Zuul-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html 大漠风\nhttps://www.imooc.com/article/37674 本文仅仅作为学习spring相关内容学习笔记使用。\nzuul Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。\nzuul有以下功能：\nAuthentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 创建一个zuul模块 POM如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;zuul\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;zuul\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 以下内容由父项目提供 --\u0026gt; \u0026lt;!--\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ server: port: 8769 spring: application: name: service-zuul zuul: routes: api-a: path: /api-a/** serviceId: service-hi api-b: path: /api-b/** serviceId: service-hi 入口文件：\n1 2 3 4 5 6 7 8 9 10 @EnableZuulProxy @EnableEurekaClient @EnableDiscoveryClient @SpringBootApplication public class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class, args); } } 配置过滤 示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.example.zuul; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; @Component public class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() { return \u0026#34;pre\u0026#34;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\u0026#34;%s \u0026gt;\u0026gt;\u0026gt; %s\u0026#34;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\u0026#34;token\u0026#34;); if(accessToken == null) { log.warn(\u0026#34;token is empty\u0026#34;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try { ctx.getResponse().getWriter().write(\u0026#34;token is empty\u0026#34;); }catch (Exception e){} return null; } log.info(\u0026#34;ok\u0026#34;); return null; } } filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\npre：路由之前\nrouting：路由之时\npost： 路由之后\nerror：发送错误调用\nfilterOrder：过滤的顺序\nshouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。\nrun：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/5.zuul-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"5.Zuul-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig config不需要依赖于Eureka。\n创建config模块。pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;config\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 spring.application.name=config-server server.port=8888 spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/ spring.cloud.config.server.git.searchPaths=respo spring.cloud.config.label=master spring.cloud.config.server.git.username= spring.cloud.config.server.git.password= 入口：\n1 2 3 4 5 6 7 8 @EnableConfigServer @SpringBootApplication public class ConfigApplication { public static void main(String[] args) { SpringApplication.run(ConfigApplication.class, args); } } 测试：访问http://127.0.0.1:8888/foo/dev 返回\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;profiles\u0026rdquo;:[\u0026ldquo;dev\u0026rdquo;],\u0026ldquo;label\u0026rdquo;:null,\u0026ldquo;version\u0026rdquo;:\u0026ldquo;0fc8081c507d694b27967e9074127b373d196431\u0026rdquo;,\u0026ldquo;state\u0026rdquo;:null,\u0026ldquo;propertySources\u0026rdquo;:[]}\n证明配置服务中心可以从远程程序获取配置信息。\nhttp请求地址和资源文件映射如下:\n/{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 这里有个误解，访问地址其实应该写为上面描述的格式，这里作者随便写了个foo。导致获取不到值。\n配置消费服务 修改test项目，首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置文件\n1 2 3 4 5 6 7 spring: cloud: config: name: microservicecloud-config-dept-client label: master profile: dev uri: http://localhost:8888/ spring.cloud.config.name 需要读取的配置文件名称 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 修改入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Value(\u0026#34;${foo}\u0026#34;) String foo; @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success-\u0026#34; + foo + \u0026#34;-end\u0026#34;; } } 特别注意 1：客户端的spring.application.name配置config-clent是和Git服务器上面的文件名相对应的，如果你的客户端是其他名字就报错找不到参数。作者的Git上面是有这个config-client-dev的配置文件的所以是config-clent，作者在这里没有说明，大家注意。\n注，如果名字不同时，可以通过指定spring.cloud.config.name\n2：客户端加载到的配置文件的配置项会覆盖本项目已有配置。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/6.config-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"6.Config-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig config不需要依赖于Eureka。\n创建config模块。pom文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 改为继承自己的父项目 --\u0026gt; \u0026lt;!--\u0026lt;parent\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;relativePath/\u0026gt; \u0026amp;lt;!\u0026amp;ndash; lookup parent from repository \u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/parent\u0026gt;--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!-- 注释掉groupId，使之与父项目保持一致 --\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;artifactId\u0026gt;config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 添加打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;config\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 暂时不考虑测试部分，先行注释。同时删除src/main/test --\u0026gt; \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusion\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/exclusions\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 配置文件：\n1 2 3 4 5 6 7 8 spring.application.name=config-server server.port=8888 spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/ spring.cloud.config.server.git.searchPaths=respo spring.cloud.config.label=master spring.cloud.config.server.git.username= spring.cloud.config.server.git.password= 入口：\n1 2 3 4 5 6 7 8 @EnableConfigServer @SpringBootApplication public class ConfigApplication { public static void main(String[] args) { SpringApplication.run(ConfigApplication.class, args); } } 测试：访问http://127.0.0.1:8888/foo/dev 返回\n{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;profiles\u0026rdquo;:[\u0026ldquo;dev\u0026rdquo;],\u0026ldquo;label\u0026rdquo;:null,\u0026ldquo;version\u0026rdquo;:\u0026ldquo;0fc8081c507d694b27967e9074127b373d196431\u0026rdquo;,\u0026ldquo;state\u0026rdquo;:null,\u0026ldquo;propertySources\u0026rdquo;:[]}\n证明配置服务中心可以从远程程序获取配置信息。\nhttp请求地址和资源文件映射如下:\n/{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 这里有个误解，访问地址其实应该写为上面描述的格式，这里作者随便写了个foo。导致获取不到值。\n配置消费服务 修改test项目，首先添加依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置文件\n1 2 3 4 5 6 7 spring: cloud: config: name: microservicecloud-config-dept-client label: master profile: dev uri: http://localhost:8888/ spring.cloud.config.name 需要读取的配置文件名称 spring.cloud.config.label 指明远程仓库的分支 spring.cloud.config.profile dev开发环境配置文件 test测试环境 pro正式环境 spring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。 修改入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 通过注解@EnableEurekaClient 表明自己是一个eurekaclient @EnableEurekaClient @SpringBootApplication // 写个简单的控制器测试接口 @RestController public class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class, args); } @Value(\u0026#34;${foo}\u0026#34;) String foo; @RequestMapping(\u0026#34;/test\u0026#34;) public String home() { return \u0026#34;success-\u0026#34; + foo + \u0026#34;-end\u0026#34;; } } 特别注意 1：客户端的spring.application.name配置config-clent是和Git服务器上面的文件名相对应的，如果你的客户端是其他名字就报错找不到参数。作者的Git上面是有这个config-client-dev的配置文件的所以是config-clent，作者在这里没有说明，大家注意。\n注，如果名字不同时，可以通过指定spring.cloud.config.name\n2：客户端加载到的配置文件的配置项会覆盖本项目已有配置。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/6.config-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"6.Config-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"修改环境变量 环境为ubuntu bionic。armhf架构。\n修改 /etc/profile 文件 在文件末尾添加\nexport PATH=$PATH:/usr/local/go/bin\n刷新环境变量\nsource /etc/profile\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/6.linux%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"6.Linux修改环境变量"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig高可用改造 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用\n为config项目添加依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/forezp/SpringcloudConfig/ search-paths: respo username: password: eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 入口添加@EnableEurekaServer\n改造config消费者：\n修改配置文件为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: service-hi cloud: config: name: config-client-dev label: master profile: dev # uri: http://localhost:8888/ discovery: enabled: true serviceId: config-server eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ config之后将从git读取配置文件\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/7.config%E9%AB%98%E5%8F%AF%E7%94%A8%E6%94%B9%E9%80%A0-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"7.Config高可用改造-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n方志朋\nhttps://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html 风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nConfig高可用改造 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用\n为config项目添加依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/forezp/SpringcloudConfig/ search-paths: respo username: password: eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 入口添加@EnableEurekaServer\n改造config消费者：\n修改配置文件为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server: port: 8762 spring: application: name: service-hi cloud: config: name: config-client-dev label: master profile: dev # uri: http://localhost:8888/ discovery: enabled: true serviceId: config-server eureka: instance: hostname: ${spring.cloud.client.ip-address} instance-id: ${spring.cloud.client.ip-address}:${server.port} client: serviceUrl: defaultZone: http://localhost:8761/eureka/ config之后将从git读取配置文件\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/7.config%E9%AB%98%E5%8F%AF%E7%94%A8%E6%94%B9%E9%80%A0-spring-boot2.1.8.release-spring-cloudgreenwich.sr3/","title":"7.Config高可用改造-spring-boot(2.1.8.RELEASE)+spring-cloud(Greenwich.SR3)"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n风的姿态\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 本文仅仅作为学习spring相关内容学习笔记使用。\nActuator Spring Cloud Config 在项目启动时加载配置内容这一机制，导致了它存在一个缺陷，修改配置文件内容后，不会自动刷新。例如我们上面的项目，当服务已经启动的时候，去修改 github 上的配置文件内容，这时候，再次刷新页面，对不起，还是旧的配置内容，新内容不会主动刷新过来。 但是，总不能每次修改了配置后重启服务吧。如果是那样的话，还是不要用它了为好，直接用本地配置文件岂不是更快。\n它提供了一个刷新机制，但是需要我们主动触发。那就是 @RefreshScope 注解并结合 actuator ，注意要引入 spring-boot-starter-actuator 包。\n添加配置文件配置：\n1 2 3 4 5 6 7 8 management: endpoint: shutdown: enabled: false endpoints: web: exposure: include: \u0026#34;*\u0026#34; 2、在需要读取配置的类上增加 @RefreshScope 注解\n未完成 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/8.actuator-spring-boot2.0.3.release-spring-cloudfinchley.release/","title":"8.Actuator-spring-boot(2.0.3.RELEASE)+spring-cloud(Finchley.RELEASE)"},{"content":"Cesium加载图层 1.协议介绍 tms 瓦片地图服务\n【大佬解释的】可以理解为一种特殊情况下的XYZ 【大佬解释的】可以直接以文件的形式进行发布，用 tilemapresource.xml 来描述图层信息 TMS是 Tile Map Service 的简写，是一种瓦片服务。由开源地理空间信息基金会（OSGEO）开发的平铺web地图规范。这个定义通常需要一个URL结构来尝试REST原则，TMS协议填补了OpenStreetMap使用的非常简单的标准和Web地图服务标准飞复杂性之间的空白，提供了简单的URL到分幅，同事还支持备用空间引用系统。 纯RESTFUL 以左下角为原点 瓦片是正方形的 xyz\n【大佬解释的】不同服务提供商的XYZ值可能不一样 x表示横坐标 y表示纵坐标 z表示地图层级\nwms 网络地图服务\n【大佬解释的】很少用，效率不高 由开发地理信息联盟（OGC）指定 wmts 网络地图瓦片服务\n【大佬解释的】必须用服务进行发布 由开发地理信息联盟（OGC）指定。采用缓存技术，能够缓解WebGis服务器端数据处理的压力（对比WMS） 可以有KVP、SOAP和RESTFUL三种 瓦片是矩形的 以左上角为原点 对应不同比例尺瓦片尺寸可以不同 flatgis\n【大佬解释的】恒歌的私有协议 【大佬解释的】如果Cesium需要加载的话，要用服务对协议进行转换解析 hgbump\n【大佬解释的】恒歌的私有协议 【大佬解释的】如果Cesium需要加载的话，要用服务对协议进行转换解析 1.加载以文件形式存在的影像数据（TMS） 1 2 3 4 5 6 7 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.TileMapServiceImageryProvider({ url: \u0026lt;图片的路径\u0026gt;, fileExtension: \u0026lt;图片的文件拓展名\u0026gt; }) ); 图片的路径指向到，包含 tilemapresource.xml 文件的文件夹，不需要指定到具体图层。\n指向的结构应该类似于\n1 2 3 4 0 1 2 tilemapresource.xml 2.加载以接口形式存在的影像数据（XYZ） 1 2 3 4 5 6 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.UrlTemplateImageryProvider({ url: \u0026#39;http://127.0.0.1:8080/Map?x={x}\u0026amp;y={y}\u0026amp;z={z}\u0026#39; }) ); 3.加载以接口形式存在的影像数据（WMS）未验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let layers = viewer.scene.imageryLayers; layers.addImageryProvider( new Cesium.WebMapServiceImageryProvider({ // 图层服务的地址 url: \u0026#39;http://127.0.0.1:8080/Map\u0026#39;, // 自定义图层名称 layers: \u0026lt;自定义图层名称\u0026gt;, parameters: { \u0026#34;service\u0026#34;: \u0026#34;WMS\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;transparent\u0026#34;: true } }) ); 4.加载以接口形式存在的影像数据（WMTS）Cesium 1.28 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var gevm = new Cesium.ProviderViewModel({ name : \u0026#39;VMap Earth\u0026#39;, iconUrl : Cesium.buildModuleUrl(\u0026#39;../images/earth.png\u0026#39;), tooltip : \u0026#39;VMap Earth Image offline\u0026#39;, creationFunction : function() { return new Cesium.WebMapTileServiceImageryProvider({ url : \u0026#39;http://\u0026#39; + document.domain + \u0026#39;:\u0026#39; + window.location.port + \u0026#39;/startlvlone/wmts\u0026#39;, layer : \u0026#39;geearth\u0026#39;, style : \u0026#39;default\u0026#39;, format : \u0026#39;image/jpeg\u0026#39;, tileMatrixSetID : \u0026#39;ge\u0026#39;, tileMatrixLabels : [ \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;16\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;24\u0026#39; ], minimumLevel : 1, maximumLevel : 24, tilingScheme : new Cesium.GeographicTilingScheme(), credit : new Cesium.Credit(\u0026#39;VMap Earth\u0026#39;) }); } }); var viewer = new Cesium.Viewer(\u0026#39;cesiumContainer\u0026#39;, { selectedImageryProviderViewModel : gevm }); 配置后，向外请求的接口地址应该类似于\n1 http://10.171.136.172:3500/startlvlone/wmts?service=WMTS\u0026amp;version=1.0.0\u0026amp;request=GetTile\u0026amp;tilematrix=3\u0026amp;layer=geearth\u0026amp;style=default\u0026amp;tilerow=3\u0026amp;tilecol=4\u0026amp;tilematrixset=ge\u0026amp;format=image%2Fjpeg 参数列表\n参数名称 示例参数值 描述 service WMTS 不知道哪来的 version 1.0.0 不知道哪来的 request GetTile 不知道哪来的 tilematrix 3 当前层级 layer geearth 配置参数里的 style default 配置参数里的 tilerow 3 当前所在的行 tilecol 4 当前所在的列 tilematrixset ge 配置参数里的 format image/jpeg 配置参数里的 5.加载以接口形式存在的影像数据（WMTS）Cesium 1.79 参数名称 参数描述 备注信息 {layer} 瓦片图层名称 {style} 瓦片风格 {format} 图像类别 {TileMatrixSetID} 瓦片矩阵集合名称 通常为 EPSG:4326 或 EPSG:3857 {TileMatrixLabels} 瓦片矩阵名称 一般为瓦片层级的名称 {TileRow} 瓦片行编号 {TileCol} 瓦片列编号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let imageryLayers = viewer.scene.imageryLayers; let wmtsImageryProvider = new Cesium.WebMapTileServiceImageryProvider({ url: \u0026#34;http://10.171.136.172:3500/wmts\u0026#34;, layer: \u0026#39;geearth\u0026#39;, style: \u0026#39;default\u0026#39;, format: \u0026#39;image/jpeg\u0026#39;, tileMatrixSetID: \u0026#39;ge\u0026#39;, tileMatrixLabels: [ \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;12\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;16\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;24\u0026#39; ], minimumLevel : 0, maximumLevel : 24, tilingScheme : new Cesium.GeographicTilingScheme(), credit : new Cesium.Credit(\u0026#39;VMap Earth\u0026#39;) }); imageryLayers.addImageryProvider(wmtsImageryProvider); minimumLevel 这里特意写成了 0， 写成 1 在使用 new Cesium.GeographicTilingScheme()时，会导致\n1 The imagery provider,s rectangle and minimumLevel indicate that there are 8 tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported. ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/cesium%E5%8A%A0%E8%BD%BD%E5%9B%BE%E5%B1%82/","title":"Cesium加载图层"},{"content":"多线程下载 在地址栏输入\n1 chrome://flags/#nable-parallel-downloading 找到\n1 Parallel downloading 选项，选择 Enable\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/chrome%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD/","title":"Chrome开启多线程下载"},{"content":"cmd常用命令 1.判断某个文件是否存在 1 IF NOT EXIST \u0026#34;%MAVEN_HOME%\\bin\\mvn.cmd\u0026#34; ECHO MAVEN_HOME is not defined 2.删除文件夹 1 rd /s /q maven-package 3.新建文件夹 1 md maven-package 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ECHO OFF ECHO ---------------- check maven env -------------------- IF NOT EXIST \u0026#34;%MAVEN_HOME%\\bin\\mvn.cmd\u0026#34; ECHO MAVEN_HOME is not defined \u0026amp; PAUSE IF NOT EXIST \u0026#34;%MAVEN_REPO_LOCAL%\\settings.xml\u0026#34; ECHO MAVEN_REPO_LOCAL is not defined \u0026amp; PAUSE :: 删除打包目录 RD /s /q maven-package :: 生成打包目录 MD maven-package :: 准备进入打包 ECHO ----------------- ready to package -------------------- :: 对 admin 项目进行打包 CD admin_2 ECHO ------------------ package for admin_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY admin_2\\target\\admin.jar maven-package :: 对 message_2 项目进行打包 CD message_2 ECHO ------------------ package for message_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY message_2\\target\\message.jar maven-package :: 对 model 项目进行打包 CD model_2 ECHO ------------------ package for model_2 --------------------------------------------------------- ECHO ------------------ maven clean --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% clean TIMEOUT /T 20 /NOBREAK ECHO ------------------ maven package --------------------------------------------------------- START %MAVEN_HOME%\\bin\\mvn.cmd -s %MAVEN_REPO_LOCAL%\\settings.xml -Dmaven.repo.local=%MAVEN_REPO_LOCAL% package timeout /T 20 /NOBREAK ECHO ------------------ COPY JAR FILE --------------------------------------------------------- CD .. COPY model_2\\target\\model.jar maven-package EXIT ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/cmd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"CMD常用命令"},{"content":"doc转docx 使用jacob.jar\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import com.jacob.activeX.ActiveXComponent; import com.jacob.com.ComThread; import com.jacob.com.Dispatch; import com.jacob.com.Variant; import java.io.File; public class Main { /** * doc格式 */ private static final int DOC_FMT = 0; /** * docx格式 */ private static final int DOCX_FMT = 12; public static void main(String[] args) { String srcDocPath = args[0]; String descDocPath = args[1]; try { new Main().convertDocFmt(srcDocPath, descDocPath, DOCX_FMT); } catch (Exception e) { e.printStackTrace(); } } /** * 根据格式类型转换doc文件 * * @param srcPath doc path 源文件 * @param descPath the docx path 目标文件 * @param fmt fmt 所转格式 * @return the file * @throws Exception the exception * @author Harley Hong * @created 2017 /08/09 16:14:07 Convert docx 2 doc file. */ public File convertDocFmt(String srcPath, String descPath, int fmt) throws Exception { // 实例化ComThread线程与ActiveXComponent ComThread.InitSTA(); ActiveXComponent app = new ActiveXComponent(\u0026#34;Word.Application\u0026#34;); try { // 文档隐藏时进行应用操作 app.setProperty(\u0026#34;Visible\u0026#34;, new Variant(false)); // 实例化模板Document对象 Dispatch document = app.getProperty(\u0026#34;Documents\u0026#34;).toDispatch(); // 打开Document进行另存为操作 Dispatch doc = Dispatch.invoke(document, \u0026#34;Open\u0026#34;, Dispatch.Method, new Object[] { srcPath, new Variant(false), new Variant(false) }, new int[1]).toDispatch(); Dispatch.invoke(doc, \u0026#34;SaveAs\u0026#34;, Dispatch.Method, new Object[] { descPath, new Variant(fmt) }, new int[1]); Dispatch.call(doc, \u0026#34;Close\u0026#34;, new Variant(false)); return new File(descPath); } catch (Exception e) { throw e; } finally { // 释放线程与ActiveXComponent app.invoke(\u0026#34;Quit\u0026#34;, new Variant[] {}); ComThread.Release(); } } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/doc2docx/","title":"doc2docx"},{"content":"docker仓库管理 1.登录远程仓库 1 docker login 2.退出远程仓库 1 docker logout 3.在仓库中搜索镜像 1 docker search ubuntu 4.拉取镜像 1 docker pull \u0026lt;镜像名\u0026gt; 5.推送镜像 1 docker push \u0026lt;镜像名\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/docker%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/","title":"docker仓库管理"},{"content":"docker常用命令 1.获取本地镜像列表 1 docker images 2.拉取镜像 1 docker pull ubuntu:15.10 3.容器相关操作 3.1使用镜像启动一个新的容器 1 docker run -i -t ubuntu:15.10 /bin/bash -i 交互式操作\n-t 终端\n-d 后台启动\n-p 指定端口映射\n\u0026ndash;name 指定容器名\n\u0026ndash;network 指定要连接的Docker网络\n只指定 -i 会导致能进行命令交互，但没有 [ root@lyoshur-PC:/home/lyoshur# ] 信息\n只指定 -t 貌似命令执行有些问题\n3.2在后台启动容器 1 docker run -d ubuntu:15.10 /bin/sh -c \u0026#34;while true; do echo hello world; sleep 1; done\u0026#34; -d 在后台启动容器\n3.3启动一个已停止的容器 1 docker start \u0026lt;容器ID\u0026gt; 3.4停止容器 1 docker stop \u0026lt;容器ID\u0026gt; 3.5查看全部容器 1 docker ps -a 3.6使用attach进入容器 1 docker attach \u0026lt;容器ID\u0026gt; 3.7使用exec进入容器 1 docker exec -it \u0026lt;容器ID\u0026gt; /bin/bash 3.8导出容器 1 docker export \u0026lt;容器ID\u0026gt; \u0026gt; ubuntu.tar 3.9导入容器快照 1 cat ubuntu.tar | docker import - ubuntu:bk 或者\n1 docker import http://example.com/exampleimage.tgz example/imagerepo 3.10删除容器 1 docker rm -f \u0026lt;容器ID\u0026gt; 4.端口映射 4.1指定端口映射 可以通过 -p 参数来设置不一样的端口\n1 docker run -d -p 5000:5000 training/webapp python app.py 可以通过 127.0.0.1:5000:5000 指定IP，默认绑定的都是TCP端口，如果需要绑定UDP端口，127.0.0.1:5000:5000/udp。\n4.2查看端口映射 1 docker port \u0026lt;容器ID\u0026gt; 5.获取容器状态 5.1查看应用程序日志 1 docker logs -f \u0026lt;容器ID\u0026gt; -f 可以让docker logs 像使用tail -f 一样来输出容器内部的标准输出\n5.2查看应用程序进程 1 docker top \u0026lt;容器ID\u0026gt; 5.3查看容器配置和状态信息\n1 docker inspect \u0026lt;容器ID\u0026gt; 6.查找镜像 1 docker search \u0026lt;镜像名\u0026gt; 7.删除镜像 1 docker rmi \u0026lt;镜像名\u0026gt; 8.提交更改后的镜像 1 docker commit -m=\u0026#34;has update\u0026#34; -a=\u0026#34;runoob\u0026#34; e218edb10161 runoob/ubuntu:v2 各个参数说明：\n-m: 提交的描述信息 -a: 指定镜像作者 **e218edb10161：**容器 ID runoob/ubuntu:v2: 指定要创建的目标镜像名 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"docker常用命令"},{"content":"Docker网络 1.新建Docker网络 1 docker network create -d bridge test-net 参数说明：\n-d：参数指定 Docker 网络类型，有 bridge、overlay。\n2.进行测试 运行两个容器，并加入到docker网络\n1 2 docker run -itd --name test1 --network test-net ubuntu /bin/bash docker run -itd --name test2 --network test-net ubuntu /bin/bash 下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。\n如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。\n1 2 apt-get update apt install iputils-ping 3.配置DNS 3.1配置全局DNS 我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：\n1 2 3 4 5 6 { \u0026#34;dns\u0026#34; : [ \u0026#34;114.114.114.114\u0026#34;, \u0026#34;8.8.8.8\u0026#34; ] } 配置完，需要重启 docker 才能生效。\n3.2在指定容器中设置DNS 1 docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu \u0026ndash;rm：容器退出时自动清理容器内部的文件系统。\n-h HOSTNAME 或者 \u0026ndash;hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。\n\u0026ndash;dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。\n\u0026ndash;dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。\n!! 如果在容器启动时没有指定 \u0026ndash;dns 和 \u0026ndash;dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/docker%E7%BD%91%E7%BB%9C/","title":"Docker网络"},{"content":"git分支管理 1.查看全部分支 1 git branch 2.创建分支命令 1 git branch [branchname] 如果觉得之前的分支名不合适，可以为新建的分支重命名 git branch -m [branchname] [branchname]\n3.切换分支命令 1 git checkout [branchname] 4.合并分支 1 git merge 5.删除分支 1 git branch -d [branchname] 6.查看全部标签 1 git tag 7.创建标签 1 git tag -a v1.0.0 8.为某个提交打标签 1 git tag -a v0.9.9 [85c7e7] 9.为某个标签添加描述信息 1 git tag -a [tagname] -m [描述信息] ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","title":"git分支管理"},{"content":"git基础命令 1.创建一个空仓库 1 git init 2.获取配置信息 1 git config --list 3.配置个人的用户名和电子邮件地址 1 2 git config --global user.name \u0026#34;lyoshur\u0026#34; git config --global user.email \u0026#34;1421333878@qq.com\u0026#34; 如果去掉 \u0026ndash;global 则只对当前仓库有效\n4.将文件加入到版本控制（添加文件到暂存区） 1 2 git add *.java git add README 5.将文件提交到仓库（提交暂存区到本地仓库） 1 git commit -m \u0026#34;提交的描述信息\u0026#34; 可以使用 -a 来提交暂存区的全部内容\n6.从现有仓库中拷贝项目 1 git clone \u0026lt;repo\u0026gt; 7.获取当前工作区状态 1 git status 可以使用 -s 参数，来获取简短的输出结果\n8.比较文件在暂存区和工作区的区别 1 2 3 4 git diff [file] git diff --cached git diff --staged git diff HEAD 9.回退版本 1 git reset --soft HEAD 10.查看历史记录 1 git log 可以使用 \u0026ndash;oneline 来查看历史记录的简洁的版本\n可以使用 \u0026ndash;graph 来查看历史记录什么时候出现了分支、合并等情况\n11.查看指定文件的修改情况 1 git blame \u0026lt;file\u0026gt; ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","title":"git基础命令"},{"content":"git远程命令 1.显示所有远程仓库 1 git remote -v 2.显示某个远程仓库的信息 1 git remote show [remote] 3.添加远程仓库 1 2 git remote add [shortname] [url] git remote add origin git@github.com:xxxxxxxxx 4.推送到远程仓库 1 git push -u origin master 5.将服务器上的最新代码拉取到本地 1 git pull origin master 6.删除远程仓库 1 git remote rm [name] 7.修改仓库名 1 git remote rename [old_name] [new_name] ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/git%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/","title":"git远程命令"},{"content":"0 概述\n使用golang开发tcp反向代理程序 实现ha(热备)/lb(负载均衡)的效果 console app即可，无需gui界面 提交go源码和可执行文件\n1 基本要求\n面向对象设计 代码规范 注释充分 逻辑清晰 可读性好 长时运行无内存泄露 不使用非开源或版权受限的第三方库代码 请在提交方案中充分说明为什么是你 无golang开发经验免谈\n2 系统配置\n使用json文件配置系统参数\n3 tcp端口转发\n根据配置文件监听tcp端口 当有client连接进来时 创建TCPProxySession对象 所有TCPProxySession使用ProxySessionService进行状态监测和生命周期管理 根据lb策略连接后台server 使用独立goroutine 读client连接并写入server连接 使用独立goroutine 读server连接并写入client client/server断开时 注销TCPProxySession并释放所有资源 长时间cleint/server无读无写时 注销TCPProxySession\n4 lb策略\n支持ha Round-Robin ip_hash 多种LB策略，可根据系统配置切换 ha - 热备，总是把所有请求转发到在线服务器列表的首台服务器，直至其掉线移除 round-robin - 循环，每一次把来自用户的请求轮流分配给所有在线服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。 ip_hash - 根据客户端ip计算hash code，然后取在线服务器数量的模得到N，然后转发到第N台服务器 抽象IBalancePolicy接口，并使用工厂模式创建实例\n5 http接口\nimport \u0026ldquo;net/http/pprof\u0026quot;以方便内存诊断 worker-keepalive.do?group=\u0026lt;监听端口\u0026gt;\u0026amp;server=: 接收服务器注册和心跳 更新在线服务器列表 worker-list.do?group=\u0026lt;监听端口\u0026gt; 查看在线服务器列表 group-open.do?group=\u0026lt;监听端口\u0026gt; 打开端口监听 group-close.do?group=\u0026lt;监听端口\u0026gt; 关闭端口监听 管理接口的输入使用get 返回使用json: { \u0026ldquo;ok\u0026rdquo; : true | false, \u0026ldquo;msg\u0026rdquo; : \u0026ldquo;错误提示\u0026rdquo;, \u0026hellip; } 所有管理接口的参数持久化到系统配置文件 下次重启直接生效\n6 日志\n所有client/server连接和断开事件写日志 所有http请求和输出有日志 每隔5秒定时打印日志：在线client，在线server\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/go%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A6%81%E6%B1%82/","title":"GO反向代理要求"},{"content":"go中的module和GOPATH 在GO 1.11 中，开始使用module组织项目依赖。\n首先是差别，GOPATH要求项目按照工程名-src。全部的依赖会放置到 GOPATH/src中。这里类似于java最开始lib的方式。\n新的module方式，会在项目下生成一个go.mod文件，来对当前项目的模块名和依赖进行描述。\n1.需要注意，使用命令go mod init \u0026lt;module_name\u0026gt; 对模块进行初始化时，虽然没有要求，但是在被其他模块 go get 时，仍要求模块名等同于路径名。\neg : gitee.com/lyoshur/golog\n2.在定义git标签时，应该尽量避免使用已经存在的标签，否则可能因为缓存问题，导致依赖下载出问题。\n3.一个常用的GOPROXY\n1 https://goproxy.cn,direct ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/go%E4%B8%AD%E7%9A%84module%E5%92%8Cgopath/","title":"go中的module和GOPATH"},{"content":"java9中的module 1.模块的声明文件module-info.java位于src目录下，对整个模块进行描述。否则会提示\n1 Module declaration should be located in a module\u0026#39;s source root 2.当存在module-info.java文件时，使用idea对项目进行打包。module-info.java 也会参与编译到 jar包中\n3.可以通过\n1 jmod create --class-path xxx.jar xxx.jmod 将一个jar包文件打包成 jmod 模块。\n如果尝试将一个不包含module-info.class 的jar包编译为jmod时。会提示 【错误: module-info.class not found】\n4.可以通过\n1 jmod list xxx.jmod 命令来查看jmod文件中包含的内容。\n5.直接打包为jmod模块\n1 2 3 4 5 6 7 8 javac -d mod/utils utils/module-info.java utils/org/example/utils/StringUtils.java jmod create --class-path \u0026lt;module-info.java所在路径\u0026gt; xxx.jmod javac -d mod/test test/module-info.java test/org/example/test/TestStringUtils.java --module-path mod/ jmod create --class-path \u0026lt;module-info.java所在路径\u0026gt; --main-class \u0026lt;main函数路径\u0026gt; xxx.jmod // 运行module java --module-path mod/ --add-modules utils,test org.example.test.TestStringUtils 需要使用命令，先对java文件进行编译，然后再对class文件进行打包。\n6.使用jlink生成一个包含制定模块的JRE环境\n1 jlink --module-path . --add-modules test,utils --output /jre 7.总结\njdk9提供了一个介于package和jar包中间的Module的概念。但是和jar包并不冲突。对于一个包含module-info.java的源码来说，可以打包为jar包或者jmod包。优势在于，可以通过jlink命令，对自己的module和依赖的必须module来构建一个运行时最小集合。减少文件和内存消耗大小。\n一般来说使用模块和不使用模块对用户来说基本上是感觉不到的，因为你可以将模块的jar包当成普通的jar包来使用，也可以将普通的jar包当成模块的jar包来使用。\n当使用普通的jar包时，JDK将会采用一种Automatic modules的策略将普通jar包当成module jar包来看待。\n这里做了一个测试，当定义了一个module test1,但不导出任何东西。如果是一个普通非模块java程序 test2 使用，则可以正常访问到test1中定义的方法。当给\ntest2 添加了module-info.java 文件。则会提示调用的方法未导出。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/java9%E4%B8%AD%E7%9A%84module/","title":"java9中的module"},{"content":"JAVA核心技术 卷1 jdk9 jshell\njdk10 var a = 12;\nprintf 格式化 58页\n基本类型\n类型 存储需求 取值范围 int 4字节 -2147483648~2147483647（刚刚超过20亿） short 2字节 -32768~32767 long 8字节 -9223372036854775808~9223372036854775807 byte 1字节 -128~127 float 4字节 +-3.40282347E+38F（有效位数为6~7位） double 8字节 +-1.79769313486231570E+308(有效位数为15位) char 长整型以后缀 L 或 l 结尾 十六进制使用前缀 0x 八进制使用前缀 0 二进制使用前缀 0b 或 0B 数字字面量可以加下划线如 1_000_000 float类型数值使用后缀 F 或 f double类型使用后缀 D 或 d 还有三个特殊值 正无穷、负无穷、非数字 Double.POSITIVE_INFINITY Double.NEGATIVE_INFINITY 和 Double.NaN 大数 BigInteger BigDecimal\n这本书好像是提供给C++程序员转java用的 = =\njavadoc\nInteger 和 int 包装类区别\nList 和 int[]\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B71%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"JAVA核心技术 卷1学习笔记"},{"content":"java日志基本知识 1.为什么要使用日志 可随时开闭日志记录，分级别筛选日志，并且保留日志代码开销很小\n日志可以简单地被定向到控制台显示、文件保存、网络传输\n日志可格式化其记录的格式\n日志可由配置文件控制\n日志利于日后错误的定位\n2.日志的发展史 Apache的 log4j 日志框架最早出现（可用配置文件管理日志并动态加载）\njava1.4 后面才添加的标准日志库 java.util.logging\nApache推出日志门面Apache Commons Logging (JCL 提供了一套日志接口，兼容上面两者)\nJCL的作者弄了个新的日志门面 SLF4J，并提供了其组件实现 logback\nApache重写log4j，推出log4j2\n因为slf4j门面后面才出现，所以推出了各种补丁使其兼容JCL的接口\n使用日志框架需要选择一个日志门面，然后再选择个门面的实现，不选择实现的话默认使用java的标准库\n3.java标准日志库 3.1关键概念 日志记录器（Logger） 面向操作的Api 提供了常用的 info warning 等接口\n日志管理器（Manager） 加载配置文件\n日志处理器（Handler）将日志输出到控制台或文件\n日志过滤器 （Filter） 过滤器定义规则对日志内容进行过滤\n日志格式化器（Format） 用来格式化日志记录\n3.2示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.company; import java.io.IOException; import java.util.logging.*; public class Main { public static void main(String[] args) throws IOException { Formatter formatter = new Formatter() { @Override public String format(LogRecord record) { return \u0026#34;hahahah\u0026#34; + record.getMessage() + \u0026#34;-\u0026#34;; } }; // 获取到一个全局的日志记录器，也可以指定参数获取一个关联到包的记录器 Logger logger = Logger.getGlobal(); // 准备为记录器添加一个处理器 ConsoleHandler consoleHandler = new ConsoleHandler(); // 为处理器添加格式化器 consoleHandler.setFormatter(formatter); // 设置不触发父记录器，否则日志会被打印两份 logger.setUseParentHandlers(false); // 为记录器添加一个处理器 logger.addHandler(consoleHandler); // 输出日志 logger.info(\u0026#34;ASD\u0026#34;); } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/java%E6%97%A5%E5%BF%97%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","title":"java日志基本知识"},{"content":"关于curl安装软件时报错 执行命令\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 报错\n1 curl: relocation error: /lib/x86_64-linux-gnu/libcurl.so.4: symbol GMTLSv1_1_client_method version OPENSSL_1_1_0 not defined in file libssl.so.1.1 with link time reference 排查后发现，需要更新 openssl。执行命令\n1 sudo apt install openssl 问题解决。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/linux%E5%85%B3%E4%BA%8Ecurl%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E6%8A%A5%E9%94%99/","title":"Linux关于curl安装软件时报错"},{"content":" 使用压缩包安装mysql 安装前置依赖\nshell\u0026gt; sudo apt-get install libaio-dev 添加用户以及用户组\nshell\u0026gt; sudo groupadd mysql shell\u0026gt; sudo useradd -r -g mysql mysql\n切换目录\nshell\u0026gt; sudo cd /usr/local\n解压压缩包，设置软链接\nshell\u0026gt; tar zxvf /home/niumd/mysql-5.5.13-linux2.6-i686.tar.gz\nshell\u0026gt; sudo ln -s /usr/local/mysql-5.5.13-linux2.6-i686 mysql 更改用户权限\nshell\u0026gt; sudo chown -R mysql .\nshell\u0026gt; sudo chgrp -R mysql .\n执行安装\nshell\u0026gt; cd mysql shell\u0026gt; sudo scripts/mysql_install_db \u0026ndash;user=mysql 修改用户权限\nshell\u0026gt; sudo chown -R root . shell\u0026gt; sudo chown -R mysql data\n放置service和配置文件 shell\u0026gt; sudo cp support-files/mysql.server /etc/init.d/mysql.server\nshell\u0026gt; sudo cp support-files/my-medium.cnf /etc/my.cnf\n这里回车后会停留，直接再按回车即可\nshell\u0026gt; sudo bin/mysqld_safe \u0026ndash;user=mysql \u0026amp; 设置密码\nshell\u0026gt; sudo pwd /usr/local/mysql shell\u0026gt; sudo bin/mysqladmin -u root password \u0026rsquo;new-password\u0026rsquo; 测试\nshell\u0026gt; sudo bin/mysql -u root -p\n其他命令 让mysql开机启动\n$ sudo update-rc.d -f mysql.server defaults\n取消开机启动\n$ sudo update-rc.d -f mysql.server remove\n将mysql加入软链接\n$ sudo ln -s /usr/local/mysql/bin/mysql /usr/local/bin/mysql\n设置外网访问\nuse mysql;\nGRANT ALL PRIVILEGES ON . TO \u0026lsquo;root\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED BY \u0026lsquo;you_password\u0026rsquo; WITH GRANT OPTION;\nflush privileges;\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/linux%E4%BD%BF%E7%94%A8tar.gz%E5%AE%89%E8%A3%85mysql/","title":"linux使用tar.gz安装mysql"},{"content":"mysql查询优化 为列选择合适的数据类型 将大的DELETE \\ UPDATE \\ INSERT查询变成多个小查询 为获得相同结果集的多次执行，请保持SQL语句的前后一致 WHERE 子句中的列尽量被索引 JOIN 子句中的列尽量被索引 ORDER BY 的列尽量被索引 使用 EXPLAIN 关键字去查看执行计划 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","title":"MySQL查询优化"},{"content":"mysql获取数据库结构 1.获取表信息 1 2 3 4 5 6 SELECT TABLE_NAME, ENGINE, TABLE_COLLATION, TABLE_COMMENT, IFNULL(AUTO_INCREMENT, -1) FROM information_schema.TABLES WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 字段名 字段描述 备注信息 TABLE_NAME 表名 ENGINE 使用的查询引擎 TABLE_COLLATION 表的排序规则 TABLE_COMMENT 表的注释 IFNULL(AUTO_INCREMENT, -1) 如果有自动递增的话，当前的自增值 这里其实有点问题，在某些情况下，会导致数据库设置的是自增。但是找不到自增值 2.获取列信息 1 2 3 4 5 6 7 8 9 10 11 SELECT ORDINAL_POSITION, COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, IFNULL(COLUMN_DEFAULT, \u0026#39;\u0026#39;), COLUMN_COMMENT FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_NAME = #{ table_name } 字段名 字段描述 备注信息 ORDINAL_POSITION 序号位置 从1开始的序号 COLUMN_NAME 栏位名称 TABLE_COLLATION 栏位数据类型 varchar(32) IS_NULLABLE 是否允许为空 IFNULL(COLUMN_DEFAULT, \u0026lsquo;\u0026rsquo;) 默认值 COLUMN_COMMENT 栏位的描述 3.获取索引信息 1 2 3 4 5 6 7 8 9 SELECT INDEX_NAME, COLUMN_NAME, NON_UNIQUE, INDEX_TYPE FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = #{ data_base_name } AND TABLE_NAME = #{ table_name } 字段名 字段描述 备注信息 INDEX_NAME 索引名称 主键是PRIMARY COLUMN_NAME 索引对应的栏位信息 NON_UNIQUE 是否唯一索引 INDEX_TYPE 索引类型 BTREE ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/mysql%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84/","title":"MySQL获取数据库结构"},{"content":"mysql语句优化 比较运算符能用 = 就不用 \u0026lt;\u0026gt; 明知只有一条查询结果，那么请使用 LIMIT 1 使用UNION ALL 代替 UNION 尽量避免使用selece * 尽量避免 IN 和 NOT IN 尽量避免在where子句中使用 or 来连接条件 使用 LIKE 尽量使用 XXX%，不要将%放在前面 最小查询原则 避免在索引列上使用mysql的内置函数 避免在WHERE表达式上使用表达式操作 避免在WHERE中使用 != 或 \u0026lt;\u0026gt; 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则 如果字段是字符串，WHERE子句一定要加引号 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/mysql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/","title":"MySQL语句优化"},{"content":".doc application/msword\n.xls application/vnd.ms-excel\n.ppt application/vnd.ms-powerpoint\n.xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n.docx application/vnd.openxmlformats-officedocument.wordprocessingml.document\n.pptx application/vnd.openxmlformats-officedocument.presentationml.presentation\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/officemime/","title":"officeMIME"},{"content":"Postman接口说明 1 请求头（Header） 1.1 HTTP 1 2 3 4 5 6 7 8 9 10 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN archOrAppId: 1479265924364341250 Authorization: bearer 19e541a3-2f78-4314-b0e4-6c56e9d57882 Connection: keep-alive Host: 10.171.136.89:9501 Origin: http://10.171.136.197:8080 Referer: http://10.171.136.197:8080/ User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36 在HTTP中，请求头是标准的 Key-Value 格式，常用来传递浏览器版本信息，主机Host信息等。\n也可以在请求头中，传递用户登录态信息（Authorization）或其他用户自定义的请求头内容（archOrAppId）。\n1.2 Postman 在Postman中，通常将自定义的请求头信息，放置在【Headers】页卡，Key-Value是必填项。Description是Postman提供的描述信息，并不属于HTTP中传递的内容，在发送请求时，也不会传递。\n1.3 Spring Boot 当服务需要接受一个特定的请求头时，可以使用【RequestHeader】注解。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(@RequestHeader Long archOrAppId){ return R.ok(); } 2 地址栏参数（Query Param） 2.1 HTTP 地址栏参数是最常见的参数传递方式，第一个参数使用？跟在地址最后，第二个参数开始使用\u0026amp;进行分割\n1 http://127.0.0.1/info?a=1\u0026amp;b=2 2.2 Postman 在Postman中，地址栏参数被放置在【Params】页卡，和请求头类型一致，Key-Value是必填项。Description是Postman提供的描述信息，并不属于HTTP中传递的内容，在发送请求时，也不会传递。\n2.3 Spring Boot 当接口中的参数，未使用任何注解时，则默认支持从地址栏参数中进行解析。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(String a, String b){ return R.ok(); } 3 路径参数（Path Param） 3.1 HTTP 从最初的设计上，路径参数并不是正统的参数传递方式。其格式为\n1 http://127.0.0.1/info/1/2 3.2 Postman Postman中并没有单独的页卡，用来传递路径参数。需要手动将参数整理复制到地址栏。需要注意，路径参数是唯一一个参数顺序会影响结果的传递方式。\n【/info/1/2】和【/info/2/1】是不同的。\n3.3 Spring Boot 当服务需要接受一个特定的路径参数时，可以使用【PathVariable】注解。\n1 2 3 4 5 // {id}表示要解析的参数名 :\\\\d+ 表示接收参数后 按照 \\\\d+ 的正则规则进行参数格式验证 @GetMapping(\u0026#34;/{id:\\\\d+}\u0026#34;) public R query(@PathVariable Long id) { return R.ok(); } 4 请求体（Body） 4.1 键值对请求体（Form Data） 4.1.1 HTTP 在Post请求中，HTTP请求包含一个请求体，根据类型不同，请求体支持不同的数据格式，键值对请求体（Form Data）是默认的支持格式。\n键值对请求体，是原生请求中，唯一支持文件上传的类型。\n4.1.2 Postman 在Postman中，键值对请求体放置在【Body】页卡且单选类型选择【form-data】。\n默认添加的键值对内容为普通键值对，可以选择Key栏位的下拉框，将值类型改成【File】用来模拟文件上传。\n4.1.3 Spring Boot 当需要接收来自Form Data请求中的参数时，可以不使用任何注解。\n1 2 3 4 @PutMapping(\u0026#34;/info\u0026#34;) public R\u0026lt;Boolean\u0026gt; info(String a, String b){ return R.ok(); } ！注！在Spring Boot中，当一个接口参数没有任何注解时，默认会从地址栏和Form Data两部分去解析请求中的参数，所以在设计接口时，如果是Get请求，则应使用地址栏参数；而Post请求时，应避免使用地址栏参数，仅使用请求体。避免参数冲突产生歧义。\n当前端上传文件时，后端可以使用【MultipartFile】参数类型，来接收一个前端传递的上传文件内容。\n1 2 3 4 @PutMapping(\u0026#34;update\u0026#34;) public R update(@RequestParam(value = \u0026#34;file\u0026#34;) MultipartFile file) { return R.ok(); } 如果前端设置了多文件上传，可以使用\n1 2 3 4 @PutMapping(\u0026#34;update\u0026#34;) public R update(@RequestParam(value = \u0026#34;files\u0026#34;) MultipartFile[] multipartFile) { return R.ok(); } 4.2 JSON请求体（Raw） 4.2.1 HTTP JSON请求体是指：通过在请求头中额外指定【Content-Type：application/json】，来设置请求体格式放弃使用键值对格式，转而使用纯文本请求体内容。\n4.2.2 Postman 在Postman中如果需要使用Json请求体，请求体放置在【Body】页卡且单选类型选择【raw】,并将最右侧下拉选择为【JSON(application/json)】。\n4.2.3 Spring Boot JSON请求体，通常被设计用来传递一个用键值对难以描述，或具备复杂类型的参数结构。\n在后端接口，可以使用【RequestBody】注解，来接收一个前端传递的JSON请求体。\n1 2 3 public R update(@RequestBody Info info) { return R.ok(); } 5 常见问题汇总 5.1 Get、Post、Put、Patch、Delete、Options等请求方式的区别 首先，请求大体分为两类，Get和Post。\nPut、Patch、Delete请求，可以当做按照业务规则更细分的Post请求看待。\nGet请求的特点是只有请求地址，没有请求体。默认浏览器会记录Get请求。常用于信息获取。\nPost请求的特点是具备丰富的请求体类型，浏览器不会记录、不会缓存，常用于信息提交。\n请求类型 请求头（Header） 地址栏参数（Query Param） 路径参数（Path Param） 键值对请求体（Form Data） JSON请求体（Raw） 文件上传 Get 支持 支持 支持 不支持 不支持 不支持 Post 支持 支持 支持 支持 支持 支持 Options请求比较特殊，是在正式请求之前进行预请求，用来确定请求的接口，能接受那些请求类型。\n5.2 请求头（Header）和请求参数的区别 通常情况下请求头中的内容，是对本次请求的整体信息进行描述，常用来保存，本次请求的发起位置，本次请求的请求方式，请求体的参数类型等。\n请求参数一般是和业务相关的请求参数，如某个数据表的字段值，要触发某些数据更新等。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/postman%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","title":"Postman使用说明"},{"content":"redis常见使用场景 1.缓存 对系统中的热点数据进行缓存，减轻数据库压力\n2.跨应用的数据共享 通过多个应用连接到同一个redis实例，实现多个应用的数据共享。eg：分布式Session\n3.分布式锁 通过共享redis中某个值，来判断能否获取到锁\n1 2 3 4 5 6 7 8 9 10 public static boolean getLock(String key) { Long flag = jedis.setnx(key, \u0026#34;1\u0026#34;); if (flag == 1) { jedis.expire(key, 10); } return flag == 1; } public static void releaseLock(String key) { jedis.del(key); } 4.全局ID 将一个全局的ID值，设置到redis。\nint 类型 incrby 利用原子性\neg: 分库分表的常见，一次性拿一段 incrby userid 1000\n5.计数器 文章的阅读量、点赞数之类的数据，写redis。再定时更新到数据库\n6.限流 int类型 incr方法\n以访问者的IP和其他信息做键。记录访问次数，超过访问次数则进行限制。\n7.位统计 String 类型的 bitcount （1.6.6的 bitmap 数据结构介绍）\n8.购物车 String 或 hash 。 所有String可以做的hash都可以做\n9.用户消息时间线 timeline list 双向链表，直接作为 timeline 就好了\n10.消息队列 11.获取随机值 12.点赞、签到、打卡 sadd srem sismember scard\n13.商品标签 14.商品筛选 15.用户关注、推荐模型 16.排行榜 ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/redis%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","title":"redis常见使用场景"},{"content":"Python在安装Scrapy框架时，使用常规的pip install Scrapy命令进行安装，失败。\n搜索教程，发现是需要在安装scrapy之前预先安装几个环境wheel、lxml、Twisted、pywin32。\n1.lxml ：lxml是python的一个解析库,支持HTML和XML的解析,支持XPath解析方式。\n直接使用pip install lxml安装。安装前升级pip。python -m pip install \u0026ndash;upgrade pip\n2.Twisted：Python实现的基于事件驱动的网络引擎框架。\n这个其实在安装Scrapy的时候会自动安装，但是他需要visual C++ Build Tools 2015。国内的网又下载不下来。所以需要手动安装。\n安装whl的话需要先安装wheel，所以先pip install wheel。\n然后去下载Twisted。\n地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/\n下载对应python版本、系统版本的Twisted。\npip install 文件名安装。\n3.pywin32 直接 pip install pywin32\n4.scrapy 直接 pip install scrapy\n总结来说：安装scrapy的问题，在于Twisted插件需要visual C++ Build Tools 2015。\n而国内的墙阻止了访问请求，导致直接安装的失败。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/scrapy%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","title":"scrapy环境安装"},{"content":"Typora使用教程 1.快捷键 Ctrl + 1 插入一级标题\nCtrl + 2 插入二级标题\nCtrl + 3 插入三级标题\nCtrl + 4 插入四级标题\nCtrl + 5 插入五级标题\nCtrl + 6 插入六级标题\nCtrl + Shinf + K 插入代码块\nCtrl + Shinf + Q 插入引用\nCtrl + Shinf + [ 有序列表\nCtrl + Shinf + ] 无序列表\nCtrl + T 插入表格\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Typora使用教程"},{"content":"关于端口被占用的解决办法 使用命令： netstat -aon|findstr \u0026ldquo;8080\u0026rdquo;\n这里的8080为模拟的端口号。记住返回结果集的PID值。\n使用命令： taskkill -F /pid \u0026ldquo;2323\u0026rdquo;\n这里的2323为模拟的PID。执行命令杀死进程。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/windows%E5%85%B3%E4%BA%8E%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"windows关于端口被占用的解决办法"},{"content":"本文非完全原创，仅仅是整理自网上博客加上一部分自己的理解。参考文章：\n徐小冠 https://blog.csdn.net/weixin_42114097/article/details/82354534 Hermione Granger https://blog.csdn.net/qq_29951485/article/details/88723065 本文仅仅作为学习spring相关内容学习笔记使用。\nspring spring的版本大致可以分为\nPRE\n预览版(内部测试版):主要用作开发研究或测试。生产环境不可用。 SNAPSHOT\n快照版:表示不稳定，仍在继续改进版本。 Mx\n里程碑构建:项目的重要节点，可能不完整，仍然有问题。x为序号按顺序编号。 RCx\n候选发布者:功能相对完整，应该非常稳定。存在的问题相对罕见和次要的，但值得报告，试图修复它们以便发布。x为序号按顺序编号。 GA\n一般可用性（发布）; 应该非常稳定，功能齐全 SR(RELEASE)\n服务版本(主要版本之后的后续维护版本-RELEASE)。 spring版本稳定顺序是递增的。在开发中应尽量选用相对稳定的版本。\nspring framework 截至当前2019年11月15日。官网显示最新版本为5.2.1[GA]\nspring boot 截至当前2019年11月15日。 官网显示最新版本为2.2.1[GA]\nspring cloud 截至当前2019年11月15日。 官网显示最新版本为Greenwich SR3[GA]\nspring cloud的版本并没有使用直接的数字形式，而是采用的伦敦地铁站的名字进行的命名。名称首字符按照A-Z进行排序，当进行了重大BUG修复或重点功能更新时，发布一个SRx版本，SR3即第三次。\n关联关系 springboot可以理解为spring framework的一个封装升级。spring cloud则是依赖于spring boot构建的。\n由于这种特殊的依存关系，springboot在结合spring cloud使用时，需要额外注意版本间的依存关系，在不断的更新中，旧版本与新版本可能存在不兼容。\n例如：\nFinchley 是基于 Spring Boot 2.0.x 构建的，不支持 Spring Boot 1.5.x\nDalston 和 Edgware 是基于 Spring Boot 1.5.x 构建的，不支持 Spring Boot 2.0.x\nCamden 构建于 Spring Boot 1.4.x，但依然能支持 Spring Boot 1.5.x\nspring-milestones Spring Milestone repo是一个标准的Maven repo-plugin。\nSpring的政策是向那些有兴趣测试它们的公众发布里程碑版本。为了明确这些里程碑版本不会在生产代码中使用，它们将发布到单独的仓库而不是Maven Central。\n所以当使用非GA以及GA以上版本时，可以在POM文件中添加配置。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-milestones\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Spring Milestones\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/milestone\u0026lt;/url\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; snapshots false 不使用快照版本。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/%E9%99%84spring%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8Amaven-spring-milestones%E4%BD%9C%E7%94%A8/","title":"附：Spring版本以及Maven spring-milestones作用"},{"content":"使用Dockerfile构建镜像 我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。\n1 2 3 4 5 6 7 8 9 10 FROM centos:6.7 MAINTAINER Fisher \u0026#34;fisher@sudops.com\u0026#34; RUN /bin/echo \u0026#39;root:123456\u0026#39; |chpasswd RUN useradd runoob RUN /bin/echo \u0026#39;runoob:123456\u0026#39; |chpasswd RUN /bin/echo -e \u0026#34;LANG=\\\u0026#34;en_US.UTF-8\\\u0026#34;\u0026#34; \u0026gt;/etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D 1.构建镜像 1 docker build -t lyoshur/ubuntu:test . 参数说明：\n-t ：指定要创建的目标镜像名 . ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径 2.设置镜像标签 1 docker tag 860c279d2fec lyoshur/ubuntu:test:dev docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。\n使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/%E4%BD%BF%E7%94%A8dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/","title":"使用Dockerfile构建镜像"},{"content":"创建websocket服务 依赖环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;dependencies\u0026gt; \u0026lt;!--netty的依赖集合，都整合在一个依赖里面了--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.6.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--这里使用jackson反序列字节码--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--加入log4j 便于深入学习整合运行过程的一些细节--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.首先创建管理线程和工作线程组 1 2 NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup work = new NioEventLoopGroup(); 2.创建服务启动器，并绑定管理线程和工作线程 1 2 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(boss,work); 3.将通道初始化为Nio 1 bootstrap.channel(NioServerSocketChannel.class); 4.配置通道初始化 1 bootstrap.childHandler(new NioWebSocketChannelInitializer()); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class NioWebSocketChannelInitializer extends ChannelInitializer\u0026lt;SocketChannel\u0026gt; { @Override protected void initChannel(SocketChannel ch) { // 设置log监听器，并且日志级别为debug，方便观察运行流程 ch.pipeline().addLast(\u0026#34;logging\u0026#34;, new LoggingHandler(\u0026#34;DEBUG\u0026#34;)); // 设置解码器 ch.pipeline().addLast(\u0026#34;http-codec\u0026#34;, new HttpServerCodec()); // 聚合器，使用websocket会用到 ch.pipeline().addLast(\u0026#34;aggregator\u0026#34;, new HttpObjectAggregator(65536)); // 用于大数据的分区传输 ch.pipeline().addLast(\u0026#34;http-chunked\u0026#34;, new ChunkedWriteHandler()); // 自定义的业务handler ch.pipeline().addLast(\u0026#34;handler\u0026#34;, new NioWebSocketHandler()); } } 5.自定义的业务handler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 public class NioWebSocketHandler extends SimpleChannelInboundHandler\u0026lt;Object\u0026gt; { private final Logger logger=Logger.getLogger(this.getClass()); private WebSocketServerHandshaker handshaker; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception { logger.debug(\u0026#34;收到消息：\u0026#34;+msg); if (msg instanceof FullHttpRequest){ //以http请求形式接入，但是走的是websocket handleHttpRequest(ctx, (FullHttpRequest) msg); }else if (msg instanceof WebSocketFrame){ //处理websocket客户端的消息 handlerWebSocketFrame(ctx, (WebSocketFrame) msg); } } @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { //添加连接 logger.debug(\u0026#34;客户端加入连接：\u0026#34;+ctx.channel()); ChannelSupervise.addChannel(ctx.channel()); } @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { //断开连接 logger.debug(\u0026#34;客户端断开连接：\u0026#34;+ctx.channel()); ChannelSupervise.removeChannel(ctx.channel()); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } private void handlerWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame){ // 判断是否关闭链路的指令 if (frame instanceof CloseWebSocketFrame) { handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); return; } // 判断是否ping消息 if (frame instanceof PingWebSocketFrame) { ctx.channel().write( new PongWebSocketFrame(frame.content().retain())); return; } // 本例程仅支持文本消息，不支持二进制消息 if (!(frame instanceof TextWebSocketFrame)) { logger.debug(\u0026#34;本例程仅支持文本消息，不支持二进制消息\u0026#34;); throw new UnsupportedOperationException(String.format( \u0026#34;%s frame types not supported\u0026#34;, frame.getClass().getName())); } // 返回应答消息 String request = ((TextWebSocketFrame) frame).text(); logger.debug(\u0026#34;服务端收到：\u0026#34; + request); TextWebSocketFrame tws = new TextWebSocketFrame(new Date().toString() + ctx.channel().id() + \u0026#34;：\u0026#34; + request); // 群发 ChannelSupervise.send2All(tws); // 返回【谁发的发给谁】 // ctx.channel().writeAndFlush(tws); } /** * 唯一的一次http请求，用于创建websocket * */ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) { //要求Upgrade为websocket，过滤掉get/Post if (!req.decoderResult().isSuccess() || (!\u0026#34;websocket\u0026#34;.equals(req.headers().get(\u0026#34;Upgrade\u0026#34;)))) { //若不是websocket方式，则创建BAD_REQUEST的req，返回给客户端 sendHttpResponse(ctx, req, new DefaultFullHttpResponse( HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return; } WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( \u0026#34;ws://localhost:8081/websocket\u0026#34;, null, false); handshaker = wsFactory.newHandshaker(req); if (handshaker == null) { WebSocketServerHandshakerFactory .sendUnsupportedVersionResponse(ctx.channel()); } else { handshaker.handshake(ctx.channel(), req); } } /** * 拒绝不合法的请求，并返回错误信息 * */ private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res) { // 返回应答给客户端 if (res.status().code() != 200) { ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); } ChannelFuture f = ctx.channel().writeAndFlush(res); // 如果是非Keep-Alive，关闭连接 if (!isKeepAlive(req) || res.status().code() != 200) { f.addListener(ChannelFutureListener.CLOSE); } } } ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/%E4%BD%BF%E7%94%A8netty%E5%88%9B%E5%BB%BAwebsocket%E6%9C%8D%E5%8A%A1/","title":"使用Netty创建websocket服务"},{"content":"黑苹果安装 下载镜像以及破解补丁\n1.复制破解补丁到VM安装目录 执行安装，成功后会在 tools目录生成\n1 2 darwin.iso darwinPre15.iso 2.安装镜像，版本选择10.8 3.修改macOS.vmx 在配置文件最后，加入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 smc.version = \u0026#34;0\u0026#34; cpuid.0.eax = \u0026#34;0000:0000:0000:0000:0000:0000:0000:1011\u0026#34; cpuid.0.ebx = \u0026#34;0111:0101:0110:1110:0110:0101:0100:0111\u0026#34; cpuid.0.ecx = \u0026#34;0110:1100:0110:0101:0111:0100:0110:1110\u0026#34; cpuid.0.edx = \u0026#34;0100:1001:0110:0101:0110:1110:0110:1001\u0026#34; cpuid.1.eax = \u0026#34;0000:0000:0000:0001:0000:0110:0111:0001\u0026#34; cpuid.1.ebx = \u0026#34;0000:0010:0000:0001:0000:1000:0000:0000\u0026#34; cpuid.1.ecx = \u0026#34;1000:0010:1001:1000:0010:0010:0000:0011\u0026#34; cpuid.1.edx = \u0026#34;0000:0111:1000:1011:1111:1011:1111:1111\u0026#34; smbios.reflectHost = \u0026#34;TRUE\u0026#34; hw.model = \u0026#34;MacBookPro14,3\u0026#34; board-id = \u0026#34;Mac-551B86E5744E2388\u0026#34; usb_xhci:1.speed = \u0026#34;2\u0026#34; usb_xhci:1.present = \u0026#34;TRUE\u0026#34; usb_xhci:1.deviceType = \u0026#34;hub\u0026#34; usb_xhci:1.port = \u0026#34;1\u0026#34; usb_xhci:1.parent = \u0026#34;-1\u0026#34; usb_xhci:3.speed = \u0026#34;4\u0026#34; usb_xhci:3.present = \u0026#34;TRUE\u0026#34; usb_xhci:3.deviceType = \u0026#34;hub\u0026#34; usb_xhci:3.port = \u0026#34;3\u0026#34; usb_xhci:3.parent = \u0026#34;-1\u0026#34; keyboard.vusb.enable = \u0026#34;TRUE\u0026#34; mouse.vusb.enable = \u0026#34;TRUE\u0026#34; usb:0.present = \u0026#34;TRUE\u0026#34; usb:0.deviceType = \u0026#34;hid\u0026#34; usb:0.port = \u0026#34;0\u0026#34; usb:0.parent = \u0026#34;-1\u0026#34; 同时需要将 virtualHW.version = \u0026ldquo;16\u0026rdquo; 改成 virtualHW.version = \u0026ldquo;10\u0026rdquo;\n4.USB兼容性配置，切换成USB2.0 5.抹除虚拟磁盘 点击磁盘工具，找到VM虚拟磁盘，点击抹除。然后开始安装系统\n6.安装VMtools 使用CD驱动器加载 破解补丁中的 darwin.iso 进行安装。\n1 2 3 sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES sudo defaults delete /Library/Preferences/com.apple.windowserver DisplayResolutionDisabled /Library/Application\\ Support/VMware\\ Tools/vmware-resolutionSet 3416 1920 参考某一个教程，执行了这三条命令，前两条执行正常，最后一个执行报错 unable to find the server\n最后在 系统 安全和隐私 启用了 VMTools 重启就正常了，怀疑命令是没啥用\n","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/%E4%BD%BF%E7%94%A8vm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%95%99%E7%A8%8B/","title":"使用VM虚拟机安装黑苹果教程"},{"content":"golang手把手实现tcp内网穿透代理\nhttps://www.jianshu.com/p/0c3f8323b43c https://www.jianshu.com/p/dd90fc516ecc https://www.jianshu.com/p/e79fe205f3e0 从字节码层面看“HelloWorld”\nhttps://www.cnblogs.com/paddix/p/5282004.html JVM调优总结\nhttps://www.cnblogs.com/andy-zhou/p/5327288.html 用Java实现JVM\nhttps://www.jianshu.com/p/4d81465c2fb8 用GO实现JVM\nhttps://github.com/zxh0/jvm.go Spring Cloud Config 实现配置中心，看这一篇就够了\nhttps://www.cnblogs.com/fengzheng/p/11242128.html 汇编语言入门教程\nhttp://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html 开源一个用 go 写的内网穿透反向代理软件 lunnel\nhttps://github.com/longXboy/lunnel go库中自带的反向代理功能和内网代理\nhttps://blog.csdn.net/idwtwt/article/details/52588762 如何做Go的性能优化？（转）\nhttps://www.cnblogs.com/wangbin/p/10209882.html CPU处理器架构和工作原理浅析\nhttp://c.biancheng.net/view/3456.html ","date":"2022-03-06T00:00:00Z","permalink":"https://lyoshur.gitee.io/p/%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F/","title":"网页收藏"}]