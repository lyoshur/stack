---
title: 第五章 Object Monitor管程实现
description: Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰）- 第五章 Object Monitor管程实现
slug: Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰）- 第五章 Object Monitor管程实现
date: 2022-08-22 14:48:00+0000
categories:
    - Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰）
tags:
    - Java
---

# 第五章 Object Monitor管程实现

为了在不同场景中保证多线程工作的安全性，Java主要基于两种思想进行线程安全性的设计：悲观锁思想和乐观锁思想。

- 悲观锁
  - 在任何时候都会有其他操作者同时要求操作资源，从而产生操作冲突。
  - 如果没有绝对安全的资源独占前提，那么对资源的操作一定会出现问题。
- 乐观锁
  - 并不是任何时候都有两个或多个操作者同时操作相同的资源，从而产生操作冲突。
  - 即使操作结果存在错误也没有关系。可以通过对比预期值和实际值来确认操作的正误，如果出现错误，则放弃本次操作，重新操作即可。

悲观锁在Java中有两种典型的实现方式，一种是基于Object Monitor模式的资源操作方式，另一种是基于AQS技术的资源操作方式。

Java中的乐观锁思想通常基于CAS（Compare and Swap，比较与交换）技术实现，但CAS进行比较的判定依据及比较后是否要进行重试，往往由操作者自行决定。所以在Java中，基于乐观锁工作的工具类都存在类似于for(;;)或while(true)的源码结构，这并不是BUG，而是为了匹配乐观锁的实现思想。

## 1 Object Monitor

Object Monitor模式是一种典型的悲观锁实现，使用Java对象模型中的特定区域对线程状态、对象状态的描述进行线程操作。

所以Object Monitor模式并没有禁止指令重排，虽然有内存屏障控制synchronized代码块的重排特征（内存屏障的知识点会在后续讲解volatile修饰符时讲解），但synchronized代码块中的代码并没有禁止指令重排操作。

虽然synchronized修饰符没有禁止源码在编译时的指令重排操作，但由于Object Monitor模式已经实现了在获取对象独占操作权的情况下，最多存在一个线程能够顺序执行，因此无论如何设计基于happens-before规则的JMM工作过程，单线程下的as-if-serial语义原则都可以得到保证。也就是说，Object Monitor模式将有序性问题的解决过程，简化成了在保证原子性的前提下，单线程遵循as-if-serial语义规则的执行过程，从而实现禁止与指令重排操作相似的效果。

## 2 和同步块控制有关的对象结构

在HotSpot JVM的工作区中将对象结构分为3个区域

- 对象头（Header）：实现Object Monitor管程控制模式的关键

  - Markword：运行时数据

    在64位JVM中，该区域在未压缩时占据对象头区域中的8字节，共64位，主要用于存储对象在运行时的数据，并且记录对象当前锁机制的相关信息。

  - Klass：元数据指针

    是一个指针区域，这个指针区域指向元数据区中（JDK 1.8+）该对象所代表的类，这样JVM才知道这个对象是哪个类的实例，在未压缩时为8字节，共64位。

  - Length：数组对象的数组长度

    （只有数组形式的对象会有这个区域）：如果一个对象是数组，那么这个区域表示数组长度，在未压缩时为8字节，共64位。

- 对象实际数据（Instance Data）

  - Data：对象/数组对象的实际数据

- 对齐区（可能存在）

  - Padding：对象填充区域

详细解释：

- 对象头（Header）：对象头是本节重点讨论的部分，在不同操作系统中、不同JVM配置（如是否开启指针压缩）下，对象头的结构不完全一致。为了便于讲解，本书讨论64位JDK在64位操作系统中的内部结构（不考虑对象压缩）。

- 对象实际数据：这个区域主要用于描述真实的对象数据，包括对象中的所有成员的属性信息，如其他对象的地址引用、基础数据类型的数据值。

- 对齐区（Padding）：对齐区并不是必须存在的，它最大的作用是占位，因为HotSpot JVM要求被管理的对象的大小是8字节的整数倍，在某些情况下，需要对不足的对象区域进行填充。

这里我们重点讨论和synchronized代码块加锁过程有关的Markword区域，首先说明以下两点。

- 对象的锁状态不同，Markword区域的存储结构不同。例如，在对象处于轻量级锁状态的情况下，Markword区域的存储结构是一种；在对象处于偏向锁状态的情况下，Markword区域的存储结构是另一种。

- Markword区域在64位JVM中和在32位JVM中的结构长度不同。

程序员在Object Monitor模式下协调多个线程抢占同一个对象的独占操作权，就是通过改变该对象Markword区域中的数据实现的。线程在Object Monitor模式下的执行过程中，为了尽可能保证操作性能，对象的Markword区域还涉及一个锁机制的升级过程（又称为锁膨胀过程），升级顺序为偏向锁→轻量级锁→重量级锁。需要注意的是，偏向锁在JDK 15中已经确认被去掉。

偏向锁实际上是在没有多个线程抢占指定对象独占操作权的情况下，完全取消对这个对象独占操作权的抢占工作。当前唯一请求对象独占操作权的线程，其线程ID会被对象记录到对象头的Markword区域中（使用CAS技术更新记录）。如果一直没有出现其他线程抢占对象独占操作权的情况，那么在当前synchronized代码块中基本不会出现针对独占权抢占工作的额外处理。

## 3 锁粗化和锁消除

## 4 Object Monitor模式的控制结构

- Entry Set

  第一个控制象限为待进入synchronized代码块的区域（Entry Set），停留在这个区域内的线程还没有获得对象的独占操作权，因此仍然停留在synchronized代码块外，即代码“synchronized(Object)”的位置。处于Entry Set区域内的线程，其线程状态被标识为BLOCKED

- Owner

  第二个控制象限为对象独占操作权持有区域（Owner），在对象的Object Monitor模式下，在同一时间最多有一个线程处于这个区域内，所以Object Monitor模式就会出现同一时间只能有一个线程在synchronize代码块内执行的效果。当前持有对象独占操作权的线程互斥量会被记录到该对象的对象头中。

- Wait Set

  第三个象限为待授权区域（Wait Set），没有退出synchronized代码块，并且暂时没有对象独占操作权的线程会被放置到该区域内。注意对象独占操作权和抢占权之间的关系：如果某个线程使用wait()等方法释放了对象的独占操作权，那么只要这个线程没有退出synchronized代码块，在未来就有权被通知重新参与对象独占操作权的抢占工作。并不是处于待授权区域（Wait Set）的线程都可以重新参与对象独占操作权的抢占工作，只有使用notify()方法或类似方法被通知转移的线程才可以参与。需要注意的是，每个对象的Object Monitor模式检查过程相对独立，但是一个线程可以同时拥有一个或多个对象的独占操作权。

## 5 as-if-serial语义原则与happens-before规则

- as-if-seriaI语义原则

  如果进行重排，则会使单线程内的执行结果发生错误。这样的执行原则称为as-if-serial语义原则

- happens-before规则

  线程安全的三性要求

  



