---
title: 第六章 JUC的必要组成部分
description: Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰）- 第六章 JUC的必要组成部分
slug: Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰）- 第六章 JUC的必要组成部分
date: 2022-08-22 14:48:00+0000
categories:
    - Java高并发与集合框架：JCF和JUC源码分析与实现（银文杰）
tags:
    - Java
---

# 第六章 JUC的必要组成部分

JUC的体系结构分为多层，底层Native JNI外的上层分别由多个关键技术模块构成：AQS、CAS、LockSupport和句柄（JDK 9开始提供变量句柄）等。

- 基于park的线程控制 juc.locks.LockSupport

  LockSupport工具类属于AQS框架的底层支持部分，主要用于进行线程元语级别的执行/阻塞控制。LockSupport工具类的主要方法有两个，分别为park()方法和unpark()方法。park()方法主要用于使当前线程进入阻塞状态，unpark()方法（及其重载方法）主要用于使指定线程退出阻塞状态。

- AQS

  需要LockSupport和CAS支撑

- 由unsafe直接提供的CAS操作

- VarHandle和MethodHandle

- 基于Object Monitor的线程控制

变量句柄VarHandle是从JDK 9开始引入的较新技术，它具有Unsafe工具类的部分功能特性，为程序员进行变量的原子性操作、可见性操作（内存屏障方式）提供了一种新的途径。变量句柄VarHandle可以与任意字段、数组变量、静态变量进行关联，支持在不同访问模型中对这些变量的访问（包括但不限于简单的read/write访问、使用volatile修饰的read/write访问等。变量句柄VarHandle是Java官方推荐的，可以由程序员直接使用的编程工具，不用担心它像Unsafe工具类一样突破Java的安全性限制。

在这些关键技术模块的上层，JUC提供了多种可以在高并发场景中直接使用的工具类，这些工具类主要分为如下五个维度。

- 信号：这些工具类主要基于AQS技术，用于解决线程间的同步和互斥问题，即解决多个线程的执行顺序控制问题。j.u.c.Semaphore类、j.u.c.CyclicBarrier类、j.u.c.CountDownLatch类都属于这方面的工具类

- 高并发场景中的JCF：这些工具类是Java官方建议在高并发场景中优先考虑使用的工具类，如j.u.c.ConcurrentHashMap类、j.u.c.ConcurrentSkipListMap类、j.u.c.ArrayBlockingQueue类等

- 线程管理/执行：这些工具类主要用于帮助应用程序控制线程规模，保证应用程序在高并发场景中不会开启过多线程，从而导致线程切换占用过多CPU资源，即帮助应用程序在线程规模和系统性能之间保持平衡。这些工具类包括我们经常使用的各类线程池线程管理工具类，如j.u.c.ThreadPoolExecutor类

- 线程/数据控制：这些工具类主要用于完成数据在各线程间的传递工作，或者帮助调用者完成线程间的异步调用工作，并且跟踪处理的状态和数据。这些工具类和信号工具类最大的区别是，前者着眼于一个线程，如果获得其他线程中的数据，并且对这些线程的执行顺序没有过多的要求，那么无论线程的运行先后顺序如何，数据都应该被正确传递。j.u.c.LinkedTransferQueue、j.u.c.Exchanger、j.u.c.Callable等类或接口都属于这个类型的工具类

- 原子性操作（无锁）：高并发场景中的操作原子性是编程过程中需要关注的另一个问题。JUC中有一个子工具箱java.util.concurrent.atomic，主要用于解决原子性操作问题，基本设计思想是CAS。

## 1 volatile修饰符

JUC主要依靠volatile修饰符解决内存可见性问题，更确切地说是依靠volatile修饰符背后隐含的各种形式的内存屏障来解决内存可见性问题。volatile修饰符主要用于以下场景中。

- 在多线程场景中，需要保证共享数据内存可见性的场景。

- 需要避免指令重排的场景（实际用于应对有序性问题）。

## 2 MESI协议（CPU缓存一致性协议）

## 3 内存屏障（Memory Barrier）

- LoadLoad Barrier（Load Memory Barrier）：该内存屏障主要用于保证高速缓存行在进行本地读操作时的内存可见性，即保证屏障后的本地读操作结果一定是最新的数据结果。具体做法如下。一旦本地CPU内核发现执行了LoadLoad Barrier，则本地CPU内核将强制等待，直到失效队列（Invalid Queue）中所有应更新为I状态的操作全部执行完毕，才会继续执行后续读操作指令。这样，本地高速缓存行中后续读取的数据和内存中最新的数据就可以保持一致了。

- StoreStore Barrier（Store Memory Barrier）：该内存屏障主要用于保证高速缓存行在进行本地写操作时的数据可见性，即保证屏障后的本地写操作对其他高速缓存行可见。

- StoreLoad Barrier（Full Barrier）：该内存屏障的性能不高，但是可以保证数据一致性，是操作系统提供的通用屏障。

- LoadStore Barrier：在对存储缓存和失效队列的操作层面上，LoadStore Barrier和LoadLoad Barrier（Load Memory Barrier）没有太大的区别，但是LS对指令重排做出了不同的限制

## 4 指令重排

- StoreStore Barrier（Store Memory Barrier）：该内存屏障可以保证，在内存屏障前的任意写操作不会被重排到该内存屏障后的任意写操作的后面；在内存屏障后的任意写操作不会被重排到该内存屏障前的任意写操作的前面。

- LoadLoad Barrier（Load Memory Barrier）：该内存屏障可以保证，在内存屏障前的任意读操作不会被重排到该内存屏障后的任意读操作的后面；在内存屏障后的任意读操作不会被重排到该内存屏障前的任意读操作的前面。

- LoadStore Barrier：该内存屏障对存储缓存和失效队列的操作效果和LoadLoad Barrier的效果类似，但对指令重排层面上的效果是不一样的。该内存屏障可以保证，在内存屏障前的任意读操作不会被重排到该内存屏障后的任意写操作的后面；保证在内存屏障后的任意写操作不会被重排到该内存屏障前的任意读操作的前面。

- StoreLoad Barrier（Full Barrier）：该内存屏障又称为通用屏障，其禁止重排的效果是，可以保证在内存屏障前的任意写操作不会被重排到该内存屏障后的任意读操作的后面；该内存屏障后的任意读操作不会被重排到该内存屏障前的任意写操作的前面。

## 5 Java提供的内存栅栏

- 存储栅栏（storeStore Fence，VarHandle.storeStoreFence()）：存储栅栏在编译器中的禁止重排效果和Store Memory Barrier基本内存屏障的禁止重排效果一致，即对内存屏障前的任意写操作和当前内存屏障后的任意写操作禁止重排。
- 加载栅栏（loadLoad Fence，VarHandle.loadLoadFence()）：加载栅栏在编译器中的禁止重排效果和Load Memory Barrier基本内存屏障的禁止重排效果一致，即对内存屏障前的任意读操作和当前内存屏障后的任意读操作禁止重排。
- 获取栅栏（acquire Fence，VarHandle.acquireFence()）：该栅栏的禁止重排效果是LoadLoad Barrier+LoadStore Barrier的禁止重排效果的组合。它可以对内存屏障后的任意读/写操作和当前内存屏障前的任意读操作禁止重排。
- 释放栅栏（release Fence，VarHandle.releaseFence()）：该栅栏的禁止重排效果是StoreStore Barrier+LoadStore Barrier的禁止重排效果组合。它可以对内存屏障前的任意读/写操作和当前内存屏障后的任意写操作禁止重排。
- 全栅栏（full Fence，VarHandle.fullFence()）：该栅栏是存储栅栏（storeStore Fence）+加载栅栏（loadLoad Fence）+通用屏障（StoreLoad Barrier）的禁止重排效果组合，它可以对内存屏障前的任意读/写操作和当前内存屏障后的任意读/写操作禁止重排。



