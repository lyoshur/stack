---
title: 3.单例模式
description: 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
slug: 3.单例模式
date: 2022-03-06 00:00:00+0000
categories:
    - Java
tags:
    - 设计模式
---

## 单例模式学习笔记（JAVA）

关于文章声明部分，上章博客写了，不再赘述。

ps:本文中的代码，仅仅是为了说明问题，并不保证生产中可用，大家看看就好。

### 单例模式
>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

国际惯例，定义看看就好。

单例模式呢，也是一种创建型的模式。就像名字一样，主要使用在保持对象的唯一性上。

这里我们举例子假设在课堂上，你们几个小伙伴在传纸条，很明显在传递过程中不能换纸，不然后面的小伙伴就不知道换纸前的内容了，也就是要保证传递的小纸条的唯一性。

ps:别说换了纸也记得，这里大家都是鱼七秒。

### 步骤1
首先我们来创建这张纸,这里要十分注意static关键字的用法

```
package pattern.singleton;

/**
 * 这是纸的一个类
 */
public class Paper {

    /**
     * 这里我们使用私有化构造避免外面新建对象
     * 也就是避免外面的熊孩子换纸
     */
    private Paper(){}

    /**
     * 然后我们提供了一张纸作为写纸条的道具
     */
    private static Paper paper = new Paper();

    /**
     * 这里呢 用一个变量 模拟保存纸条上的内容
     */
    private String content = "";

    /**
     * 使外面的熊孩子能拿到一张纸写纸条
     * 注意，我们这里返回的一直是上面新建的那张纸，所以保证了唯一性
     * @return 一张纸
     */
    public static Paper getPaper() {
        return paper;
    }

    /**
     * 这里模拟在纸上写字的过程
     * @param content 这是新写上去的内容
     */
    public void write(String content) {
        this.content = this.content + ">" + content;
    }

    /**
     * 这里模拟读纸条的过程
     */
    public void read() {
        System.out.println(content);
    }
}
```

### 步骤2
接下来就是简单的小测试了
```
package pattern.singleton;

public class Main {

    public static void main(String[] args) {
        // 首先是熊孩子A拿到纸，并写下 你好啊熊二
        Paper paperA = Paper.getPaper();
        paperA.write("你好啊熊二");

        // 然后是熊孩子B拿到了纸，先看了看纸，然后写了你也好啊
        Paper paperB = Paper.getPaper();
        paperB.read();
        paperB.write("你也好啊");

        // 最后再来看一下纸上的内容
        Paper paperC = Paper.getPaper();
        paperC.read();
    }
}
```
输出结果：
```
>你好啊熊二
>你好啊熊二>你也好啊
```

到这，一个非常简单的单例模式就实现了，可以看到虽然熊孩子们不停的在拿纸，写内容，但是操作的都是同一张纸。这也是单例模式的核心思想，保持对象的唯一性。

单例模式相对于前面的工厂模式、建造者模式，步骤要少的多。但是并不代表单例模式就相对简单。

我们试想假如熊孩子A和熊孩子B同时想写内容，甚至大打出手（换到编程上就是多线程操作的问题）。因为保证了纸的唯一性，就容易出现争抢问题。另外，在写小纸条的时候，好像没有必要一直备着一张纸，而是需要写的时候，发现没纸，在去找纸。

这也是单例模式中经常提到的，多线程安全和延迟初始化的问题。

像文中使用了

```
private static Paper paper = new Paper();
```
这里直接在定义变量时就已经创建了对象，很明显不是等到需要使用的时候才去创建，所以称之为 不是 Lazy 初始化，也可以叫饿汉式。
而这种
```
/**
 * 然后我们提供了一张纸作为写纸条的道具
 */
private static Paper paper;

/**
 * 使外面的熊孩子能拿到一张纸写纸条
 * 注意，我们这里返回的一直是上面的那张纸，所以保证了唯一性
 * @return 一张纸
 */
public static Paper getPaper() {
    if (paper == null) {
        paper = new Paper();
    }
    return paper;
}
```
等到需要使用纸的时候，才去检查是否要创建纸的写法，被称为Lazy 初始化，也可以叫做懒汉式。
饿汉式与懒汉式主要区别在，饿汉式因为不需要使用的时候就已经创建了对象，可能导致资源浪费。

当然这种简单的懒汉式写法，就有可能导致前面所说的多线程安全问题。

至于如何保证多线程安全，需要具体问题具体分析，比如加锁或者换为饿汉式写法等等。多线程安全问题，本质只是在多个熊孩子发生了争抢。那么如何处理争抢或者避免争抢。就是解决问题的具体办法。

说了这么多，根本思想只有一个，单例模式，其实只是一种保证对象唯一性的思想，不论你是饿汉或懒汉、多线程安全或者不安全，使用static或枚举、使用双检锁/双重校验锁（DCL，即 double-checked locking）等等等等。其本质，都是单例模式的不同实现。理解了单例模式的思想，天地万法，最终也不过是殊途同归。

以上

本文over
