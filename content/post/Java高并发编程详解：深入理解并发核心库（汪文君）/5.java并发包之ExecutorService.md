---
title: 第五章 java并发包之ExecutorService
description: Java高并发编程详解：深入理解并发核心库（汪文君）- 第五章 java并发包之ExecutorService
slug: Java高并发编程详解：深入理解并发核心库（汪文君）- 第五章 java并发包之ExecutorService
date: 2022-08-17 10:14:00+0000
categories:
    - Java高并发编程详解：深入理解并发核心库（汪文君）
tags:
    - Java
---

# 第五章 java并发包之ExecutorService

## 1 Executor&ExecutorService详解

### 1.1 ThreadPoolExecutor详解

构造ThreadPoolExecutor所需要的参数是比较多的

- corePoolSize：用于指定在线程池中维护的核心线程数量，即使当前线程池中的核心线程不工作，核心线程的数量也不会减少（在JDK1.6版本及以后可以通过设置允许核心线程超时的方法allowCoreThreadTimeOut来改变这种情况）

- maximumPoolSize：用于设置线程池中允许的线程数量的最大值

- keepAliveTime：当线程池中的线程数量超过核心线程数并且处于空闲时，线程池将回收一部分线程让出系统资源，该参数可用于设置超过corePoolSize数量的线程在多长时间后被回收，与unit配合使用

- TimeUnit：用于设定keepAliveTime的时间单位

- workQueue：用于存放已提交至线程池但未被执行的任务

- ThreadFactory：用于创建线程的工厂，开发者可以通过自定义ThreadFactory来创建线程，比如，根据业务名为线程命名、设置线程优先级、设置线程是否为守护线程等、设置线程所属的线程组等

- RejectedExecutionHandler：当任务数量超过阻塞队列边界时，这个时候线程池就会拒绝新增的任务，该参数主要用于设置拒绝策略

ExecutorService允许一次性提交一批任务invokeAny，但是其只关心第一个完成的任务和结果

invokeAll方法同样可用于异步处理批量的任务，但是该方法关心所有异步任务的运行

### 1.2 ScheduledExecutorService

ScheduledExecutorService既具有ThreadPoolExecutor的所有方法，同时又具备定时执行任务的方法，在ScheduledExecutorService中定义了4个与schedule相关的方法，用于定时执行任务

- <V> ScheduledFuture<V> schedule(Callable<V> callable,long delay,TimeUnit unit)：该方法是一个one-shot方法（只执行一次），任务（callable）会在单位（unit）时间（delay）后被执行，并且立即返回ScheduledFuture，在稍后的程序中可以通过Future获取异步任务的执行结果。

- ScheduledFuture<?> schedule(Runnable command,long delay, TimeUnit unit)：该方法同样是一个one-shot方法（只执行一次），任务（runnable）会在单位（unit）时间（delay）后被执行，虽然也会返回ScheduledFuture，但是并不会包含任何执行结果，因为Runnable接口的run方法本身就是无返回值类型的接口方法，不过可以通过该Future判断任务是否执行结束。

- ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay, long period, TimeUnit unit)：任务（command）会根据固定的速率（period，时间单位为unit）在时间（initialDelay，时间单位为unit）后不断地被执行。

- ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,long delay,TimeUnit unit)：该方法与前一个方法比较类似，只不过该方法将以固定延迟单位时间的方式执行任务

### 1.3 Executors详解

- FixedThreadPool

  线程池的核心线程数和最大线程数是相等的，因此该线程池中的工作线程数将始终是固定的。任务队列为LinkedBlockingQueue（无边界），所以理论上提交至线程池的任务始终都会被执行，只有显式地执行线程池的关闭方法才能关闭线程池

- SingleThreadPool

  SingleThreadPool是只有一个核心线程的线程池，但是Finalizable代理了该线程池，因此当线程池引用可被垃圾回收器回收时，线程池的shutdown方法会被执行，当然我们还是建议显式地调用线程池的关闭方法

- CachedThreadPool

  CachedThreadPool根据需要创建新线程，但会重用以前构造的可用线程。该线程池通常会用于提高执行量大的、耗时较短的、异步任务程序的运行性能，在该线程池中，如果有可用的线程将被直接重用。如果没有可用的线程，则会创建一个新线程并将其添加到池中。未被使用且空闲时间超过60秒的线程将被终止并从线程池中移除，因此长时间空闲的线程不会消耗任何资源

- ScheduledThreadPool

  创建指定核心线程数量的ScheduledExecutorService

- WorkStealingPool

  与其他线程池不同的是，WorkStealingPool中的工作线程会处理任务队列中与之对应的任务分片（Divide and conquer：分而治之），如果某个线程处理的任务执行比较耗时，那么它所负责的任务将会被其他线程“窃取”执行，进而提高并发处理的效率。

## 2 Future和Callback

Future代表着一个异步任务在未来的执行结果，这个结果可以在最终的某个时间节点通过Future的get方法来获得

获取异步执行任务的结果：当异步任务被正常执行完毕，可以通过get方法或者其重载方法（指定超时单位时间）获取最终的结果。

- Callable接口：该接口与Runnable接口非常相似，但是Runnable作为任务接口最大的问题就是无法返回最终的计算结果，因此在JDK1.5版本中引入了Callable泛型接口，它允许任务执行结束后返回结果

- 任务执行错误：Runnable类型的任务中，run（）方法抛出的异常（运行时异常）只能被运行它的线程捕获（有可能会导致运行线程死亡），但是启动运行线程的主线程却很难获得Runnable任务运行时出现的异常信息。在《Java高并发编程详解：多线程与架构设计》一书的第7章“Hook线程以及捕获线程执行异常”中有讲到，我们可以通过设置UncaughtExceptionHandler的方式来捕获异常，但是这种方式的确不够优雅，并且也无法精确地知道是执行哪个任务时出现的错误，Future则是通过捕获get方法异常的方式来获取异步任务执行的错误信息的，如下面的示例代码所示。

Future的不足之处

- 无法被动接收异步任务的计算结果：虽然我们可以主动将异步任务提交给线程池中的线程来执行，但是待异步任务结束后，主（当前）线程无法得到任务完成与否的通知（关于这一点，5.2.4节中将会给出解决方案），它需要通过get方法主动获取计算结果
- Future间彼此孤立：有时某一个耗时很长的异步任务执行结束以后，你还想利用它返回的结果再做进一步的运算，该运算也会是一个异步任务，两者之间的关系需要程序开发人员手动进行绑定赋予，Future并不能将其形成一个任务流（pipeline），每一个Future彼此之间都是孤立的，但5.5节将要介绍的CompletableFuture就可以将多个Future串联起来形成任务流（pipeline）
- Future没有很好的错误处理机制：截至目前，如果某个异步任务在执行的过程中发生了异常错误，调用者无法被动获知，必须通过捕获get方法的异常才能知道异步任务是否出现了错误，从而再做进一步的处理

### 2.1 Google Guava的Future

Future虽然为我们提供了一个凭据，但是在未来某个时间节点进行get()操作时仍然会使当前线程进入阻塞，显然这种操作方式并不是十分完美，因此在Google Guava并发包中提供了对异步任务执行的回调支持，它允许你注册回调函数而不用再通过get()方法苦苦等待异步任务的最终计算结果（Don't Call Us, We'll Call You!）

#### 2.1.1 ListenableFuture

Guava提供了ListneningExecutorService，使用该ExecutorService提交执行异步任务时将返回ListenableFuture，通过该Future，我们可以注册回调接口

#### 2.1.2 FutureCallback

除了ListenableFuture之外，还可以注册FutureCallback，相比前者用Runnable接口作为回调接口，FutureCallback提供的回调方式则更为直观。

## 3 ForkJoinPool详解

Fork/Join框架是在JDK1.7版本中被Doug Lea引入的，Fork/Join计算模型旨在充分利用多核CPU的并行运算能力，将一个复杂的任务拆分（fork）成若干个并行计算，然后将结果合并（join）

- RecursiveTask

  RecursiveTask任务类型除了进行子任务的运算之外，还会将最终子任务的计算结果返回，下面通过一个简单的实例来认识一下RecursiveTask。

- RecursiveAction

  RecursiveAction类型的任务与RecursiveTask比较类似，只不过它更关注于子任务是否运行结束，下面来看一个将数组中的每一个元素并行增加10倍

## 4 CompletionService详解

CompletionService并不是ExecutorService的子类，因此它并不具备执行异步任务的能力（异步任务的执行是由CompletionService内部的ExecutorService来完成的），它只是对Executor-Service的一个封装，在其内部提供了阻塞队列用于Future的消费

CompletionService很好地解决了异步任务的问题，在CompletionService中提供了提交异步任务的方法（真正的异步任务执行还是由其内部的ExecutorService完成的），任务提交之后调用者不再关注Future，而是从BlockingQueue中获取已经执行完成的Future，在异步任务完成之后Future才会被插入阻塞队列，也就是说调用者从阻塞队列中获取的Future是已经完成了的异步执行任务，所以再次通过Future的get方法获取结果时，调用者所在的当前线程将不会被阻塞。

## 5 CompletableFuture详解

CompletableFuture是自JDK1.8版本中引入的新的Future，常用于异步编程之中，所谓异步编程，简单来说就是：“程序运算与应用程序的主线程在不同的线程上完成，并且程序运算的线程能够向主线程通知其进度，以及成功失败与否的非阻塞式编码方式”，这句话听起来与前文中学习的ExecutorService提交异步执行任务并没有多大的区别，但是别忘了，无论是ExecutorService还是CompletionService，都需要主线程主动地获取异步任务执行的最终计算结果，如此看来，Google Guava所提供的ListenableFuture更符合这段话的描述，但是ListenableFuture无法将计算的结果进行异步任务的级联并行运算，甚至构成一个异步任务并行运算的pipeline，但是这一切在CompletableFuture中都得到了很好的支持。

CompletableFuture实现自CompletionStage接口，可以简单地认为，该接口是同步或者异步任务完成的某个阶段，它可以是整个任务管道中的最后一个阶段，甚至可以是管道中的某一个阶段，这就意味着可以将多个CompletionStage链接在一起形成一个异步任务链，前置任务执行结束之后会自动触发下一个阶段任务的执行。另外，CompletableFuture还实现了Future接口，所以你可以像使用Future一样使用它。

- thenApply：以同步的方式继续处理上一个异步任务的结果。
- thenApplyAsync：以异步的方式继续处理上一个异步任务的结果。
- thenAccept：以同步的方式消费上一个异步任务的结果。
- thenAcceptAsync：以异步的方式消费上一个异步任务的结果。
- thenRun：以同步的方式执行Runnable任务。
- thenRunAsync：以异步的方式执行Runnable任务。
