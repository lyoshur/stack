---
title: 第二章 Java并发包之原子类型详解
description: Java高并发编程详解：深入理解并发核心库（汪文君）- 第二章 Java并发包之原子类型详解
slug: Java高并发编程详解：深入理解并发核心库（汪文君）- 第二章 Java并发包之原子类型详解
date: 2022-08-17 10:14:00+0000
categories:
    - Java高并发编程详解：深入理解并发核心库（汪文君）
tags:
    - Java
---

# 第二章 Java并发包之原子类型详解

## 1 AtomicInteger详解

AtomicInteger有两个构造，无参构造，初始值为0；以及带初始值的构造。

方法：

- void set(int newValue)：为AtomicInteger的value设置一个新值，通过对前面内容的学习，我们知道在AtomicInteger中有一个被volatile关键字修饰的value成员属性，因此调用set方法为value设置新值后其他线程就会立即看见

- void lazySet(int newValue)：set方法修改被volatile关键字修饰的value值会被强制刷新到主内存中，从而立即被其他线程看到，这一切都应该归功于volatile关键字底层的内存屏障。内存屏障虽然足够轻量，但是毕竟还是会带来性能上的开销，比如，在单线程中对AtomicInteger的value进行修改时没有必要保留内存屏障，而value又是被volatile关键字修饰的，这似乎是无法调和的矛盾。幸好追求性能极致的JVM开发者们早就考虑到了这一点，lazySet方法的作用正在于此

- int getAndIncrement()  i++

- int incrementAndGet() ++i

- int getAndDecrement() i--

- int decrementAndGet() --i

- boolean compareAndSet(int expect, int update)

  其中expect代表当前的AtomicInteger数值，update则是需要设置的新值，该方法会返回一个boolean的结果：当expect和AtomicInteger的当前值不相等时，修改会失败，返回值为false；若修改成功则会返回true

- int getAndAdd(int delta)

  原子性地更新AtomicInteger 的value值，更新后的value为value和delta之和

- int addAndGet(int delta)

  类似 i++和++i的区别

自JDK1.8增加了函数式接口之后，AtomicInteger也提供了对函数式接口的支持。

- int getAndUpdate(IntUnaryOperator updateFunction)：原子性地更新AtomicInteger的值，方法入参为IntUnaryOperator接口，返回值为value更新之前的值。
- int updateAndGet(IntUnaryOperator updateFunction)：原子性地更新AtomicInteger的值，方法入参为IntUnaryOperator接口，该方法会立即返回更新后的value值
- int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)：原子性地更新AtomicInteger的值，方法入参为IntBinaryOperator接口和delta值x，返回值为value更新之前的值
- int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)：该方法与getAndAccumulate类似，只不过会立即返回AtomicInteger的更新值

## 2 AtomicInteger内幕

Unsafe是由C++实现的，其内部存在着大量的汇编 CPU指令等代码，JDK实现的 Lock Free几乎完全依赖于该类

【note】openjdk-jdk8u/hotspot/src/share/vm/prims/unsafe.cpp / openjdk-jdk8u/hotspot/src/os_cpu/bsd_x86/vm/atomic_bsd_x86.inline.hpp

文件我们会找到相关的C++代码文件。java通过调用unsafe.cpp定义的方法，来完成cas操作，根本实现在和CPU相关的atomic_bsd_x86.inline.hpp中，里面会调用不同CPU架构下的汇编代码。

## 3 AtomicBoolean详解

- get()：获取AtomicBoolean的当前布尔值

- set(boolean newValue)：设置AtomicBoolean最新的value值，该新值的更新对其他线程立即可见

- lazySet(boolean newValue)：设置AtomicBoolean的布尔值

- getAndSet(boolean newValue)：返回AtomicBoolean的前一个布尔值，并且设置新的值

- compareAndSet(boolean expect, boolean update)

- weakCompareAndSet(boolean expect, boolean update)

## 4TryLock显式锁的实现

类保存两个变量，一个AtomicBoolean，一个ThreadLocal<Boolean>。使用AtomicBoolean来进行cas，判断当前线程能否拿到锁。ThreadLocal用来存储当前线程是否拿到锁。

两个方法 tryLock 和 release。

## 5 AtomicLong详解

相对于compareAndSwapInt方法，在unsafe.cpp中，compareAndSwapLong方法多了条件编译SUPPORTS_NATIVE_CX8。SUPPORTS_NATIVE_CX8主要用于判断机器硬件是否支持8字节数字的cmpxchg CPU指令，如果机器硬件不支持，比如32位的CPU肯定不支持8字节64位数字的cmpxchg CPU指令，那么此时就需要判断当前JVM版本是否支持8字节数字的cmpxchg操作；如果机器硬件与当前JVM的版本都不支持，那么实际上针对long型数据的原子性操作将不会是Lock Free的，而是需要采用加锁的方式确保原子性。

## 6 AtomicReference详解

AtomicReference类提供了对象引用的非阻塞原子性读写操作，并且提供了其他一些高级的用法。众所周知，对象的引用其实是一个4字节的数字，代表着在JVM堆内存中的引用地址。

我们使用AtomicReference封装对象引用，每一次对AtomicReference的更新操作，我们都采用CAS这一乐观非阻塞的方式进行，因此也会存在对DebitCard对象引用更改失败的问题。CAS算法在此处就是要确保接下来要修改的对象引用是基于当前线程刚才获取的对象引用，否则更新将直接失败。

- get()：获取AtomicReference的当前对象引用值
- set(V newValue)：设置AtomicReference最新的对象引用值，该新值的更新对其他线程立即可见
- lazySet(V newValue)：设置AtomicReference的对象引用值
- getAndSet(V newValue)：原子性地更新AtomicReference内部的value值，并且返回AtomicReference的旧值
- compareAndSet(V expect, V update)：原子性地更新AtomicReference内部的value值，其中expect代表当前AtomicReference的value值，update则是需要设置的新引用值。该方法会返回一个boolean的结果，当expect和AtomicReference的当前值不相等时，修改会失败，返回值为false，若修改成功则会返回true
- getAndUpdate(UnaryOperator<V> updateFunction)：原子性地更新value值，并且返回AtomicReference的旧值，该方法需要传入一个Function接口
- updateAndGet(UnaryOperator<V> updateFunction)：原子性地更新value值，并且返回AtomicReference更新后的新值，该方法需要传入一个Function接口
- getAndAccumulate(V x, BinaryOperator<V> accumulatorFunction)：原子性地更新value值，并且返回AtomicReference更新前的旧值。该方法需要传入两个参数，第一个是更新后的新值，第二个是BinaryOperator接口
- accumulateAndGet(V x, BinaryOperator<V> accumulatorFunction)：原子性地更新value值，并且返回AtomicReference更新后的值。该方法需要传入两个参数，第一个是更新的新值，第二个是BinaryOperator接口

## 7 AtomicStampedReference详解

截至目前我们已经学习了AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference这些原子类型，它们无一例外都采用了基于volatile关键字+CAS算法无锁的操作方式来确保共享数据在多线程操作下的线程安全性。

- volatile关键字保证了线程间的可见性，当某线程操作了被volatile关键字修饰的变量，其他线程可以立即看到该共享变量的变化

- CAS算法，即对比交换算法，是由UNSAFE提供的，实质上是通过操作CPU指令来得到保证的。CAS算法提供了一种快速失败的方式，当某线程修改已经被改变的数据时会快速失败

如何避免CAS算法带来的ABA问题呢？针对乐观锁在并发情况下的操作，我们通常会增加版本号，比如数据库中关于乐观锁的实现方式，以此来解决并发操作带来的ABA问题。在Java原子包中也提供了这样的实现AtomicStampedReference<E>。

AtomicStampedReference在构建的时候需要一个类似于版本号的int类型变量stamped，每一次针对共享数据的变化都会导致该stamped的增加（stamped的自增维护需要应用程序自身去负责，AtomicStampedReference并不提供），因此就可以避免ABA问题的出现，AtomicStampedReference的使用也是极其简单的，创建时我们不仅需要指定初始值，还需要设定stamped的初始值，在AtomicStampedReference的内部会将这两个变量封装成Pair对象。

- getReference()：获取当前引用值，等同于其他原子类型的get方法
- getStamp()：获取当前引用值的stamp数值
- V get(int[] stampHolder)：这个方法的意图是获取当前值以及stamp值，但是Java不支持多值的返回，并且在AtomicStampedReference内部Pair被定义为私有的，因此这里就采用了传参的方式来解决（个人觉得这样的方法设计不算优雅，作者如果不想暴露Pair，完全可以再定义一个专门用于返回value和stamp对的public对象）
- compareAndSet(V expectedReference, V newReference,int expectedStamp, int newStamp)：对比并且设置当前的引用值，这与其他的原子类型CAS算法类似，只不过多了expectedStamp和newStamp，只有当expectedReference与当前的Reference相等，且expectedStamp与当前引用值的stamp相等时才会发生设置，否则set动作将会直接失败
- weakCompareAndSet (V expectedReference, V newReference, int expectedStamp, int newStamp)：同上
- set(V newReference, int newStamp)：设置新的引用值以及stamp
- attemptStamp(V expectedReference, int newStamp)：该方法的主要作用是为当前的引用值设置一个新的stamp，该方法为原子性方法

熟悉数据库开发的朋友肯定知道在多线程或者多系统中，同时对数据库的某条记录进行更改的时候，我们一般是采用乐观锁的方式，即为该记录增加版本号字段，比如如下的更新操作，其实AtomicStampedReference的实现原理也是这样的

```sql
UPDATE TABLE TAB SET X=newValue, VERSION=VERSION+1 WHERE X=oldValue AND VERSION=expectedVersion
```

## 8 AtomicArray详解

在Java原子包中提供了相应的原子性操作数组元素相关的类

- AtomicIntegerArray：提供了原子性操作int数据类型数组元素的操作

- AtomicLongArray：提供了原子性操作long数据类型数组元素的操作

- AtomicReferenceArray：提供了原子性操作对象引用数组元素的操作

## 9 AtomicFieldUpdater详解

在Java的原子包中提供了三种原子性更新对象属性的类

- AtomicIntegerFieldUpdater：原子性地更新对象的int类型属性，该属性无须被声明成AtomicInteger

- AtomicLongFieldUpdater：原子性地更新对象的long类型属性，该属性无须被声明成AtomicLong

- AtomicReferenceFieldUpdater：原子性地更新对象的引用类型属性，该属性无须被声明成AtomicReference<T>

```java
AtomicIntegerFieldUpdater<Alex> updater = AtomicIntegerFieldUpdater.newUpdater(Alex.class, "salary");
int result = updater.addAndGet(alex, 1);
```

注意事项：AtomicFieldUpdater在使用上非常简单，其内部实现原理也是很容易理解的，但是并不是所有的成员属性都适合被原子性地更新

- 未被volatile关键字修饰的成员属性无法被原子性地更新
- 类变量无法被原子性地更新
- 无法直接访问的成员属性不支持原子性地更新
- final修饰的成员属性无法被原子性地更新
- 父类的成员属性无法被原子性地更新

## 10 sun.misc.Unsafe详解

Java是一种安全的开发语言，Java的设计者在设计之初就想将一些危险的操作屏蔽掉。比如对内存的手动管理，但是本章所学习的原子类型，甚至在接下来的章节中将要学习到的并发工具、并发容器等在其底层都依赖于一个特殊的类sun.misc.Unsafe，该类是可以直接对内存进行相关操作的，甚至还可以通过汇编指令直接进行CPU的操作。

sun.misc.Unsafe提供了非常多的底层操作方法，这些方法更加接近机器硬件（CPU/内存），因此效率会更高。不仅Java本身提供的很多API都对其有严重依赖，而且很多优秀的第三方库/框架都对它有着严重的依赖，比如LMAX Disruptor，不熟悉系统底层，不熟悉C/C++汇编等的开发者没有必要对它进行深究，但是这并不妨碍我们直接使用它。在使用的过程中，如果使用不得当，那么代价将是非常高昂的，因此该类被命名为Unsafe也就在情理之中了，总之一句话，你可以用，但请慎用！

- 绕过类构造函数完成对象创建
- 直接修改内存数据
- 类的加载

## 11 本章总结

本章非常详细地讲解了Java原子类型包中的所有原子类型的原理以及用法，原子类型包为我们提供了一种无锁的原子性操作共享数据的方式，无锁的操作方式可以减少线程的阻塞，减少CPU上下文的切换，提高程序的运行效率，但是这并不是一条放之四海皆准的规律，比如，同样被synchronized关键字同步的共享数据和原子类型的数据在单线程运行的情况下，synchronized关键字的效率却要高很多，究其原因是synchronized关键字是由JVM提供的相关指令所保证的，因此在Java程序运行期优化时可以将同步擦除，而原子类是由本地方法和汇编指令来提供保障的，在Java程序运行期间是没有办法被优化的。

