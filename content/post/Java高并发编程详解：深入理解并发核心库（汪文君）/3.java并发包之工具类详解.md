---
title: 第三章 java并发包之工具类详解
description: Java高并发编程详解：深入理解并发核心库（汪文君）- 第三章 java并发包之工具类详解
slug: Java高并发编程详解：深入理解并发核心库（汪文君）- 第三章 java并发包之工具类详解
date: 2022-08-17 10:14:00+0000
categories:
    - Java高并发编程详解：深入理解并发核心库（汪文君）
tags:
    - Java
---

# 第三章 java并发包之工具类详解

## 1 CountDownLatch工具详解

CountDownLatch使用起来非常简单，但是就是这个简单的工具类，可以帮助我们很优雅地解决主任务等待所有子任务都执行结束之后再进行下一步工作的场景。

- CountDownLatch的构造非常简单，需要给定一个不能小于0的int数字

- countDown()方法，该方法的主要作用是使得构造CountDownLatch指定的count计数器减一。如果此时CountDownLatch中的计数器已经是0，这种情况下如果再次调用countDown()方法，则会被忽略，也就是说count的值最小只能为0

- await()方法会使得当前的调用线程进入阻塞状态，直到count为0，当然其他线程可以将当前线程中断。同样，当count的值为0的时候，调用await方法将会立即返回，当前线程将不再被阻塞

- await（long timeout, TimeUnit unit）是一个具备超时能力的阻塞方法，当时间达到给定的值以后，计数器count的值若还大于0，则当前线程会退出阻塞

- getCount()方法，该方法将返回CountDownLatch当前的计数器数值，该返回值的最小值为0

## 2 CyclicBarrier工具详解

CyclicBarrier（循环屏障），它也是一个同步助手工具，它允许多个线程在执行完相应的操作之后彼此等待共同到达一个障点（barrier point）。CyclicBarrier也非常适合用于某个串行化任务被分拆成若干个并行执行的子任务，当所有的子任务都执行结束之后再继续接下来的工作。从这一点来看，Cyclic Barrier与CountDownLatch非常类似，但是它们之间的运行方式以及原理还是存在着比较大的差异的，并且CyclicBarrier所能支持的功能CountDownLatch是不具备的。比如，CyclicBarrier可以被重复使用，而CountDownLatch当计数器为0的时候就无法再次利用。

【note】在构造CyclicBarrier的时候，如果给定一个Runnable作为回调，那么待所有的任务线程都到达barrier point之后，该Runnable接口的run方法将会被调用。

- int getParties()方法：获取CyclicBarrier在构造时的parties，该值一经CyclicBarrier创建将不会被改变

- await()方法：我们使用最多的一个方法，调用该方法之后，当前线程将会进入阻塞状态，等待其他线程执行await()方法进入barrier point，进而全部退出阻塞状态

- await(long timeout, TimeUnit unit)方法：该方法与无参的await方法类似，只不过增加了超时的功能，当其他线程在设定的时间内没有到达barrier point时，当前线程也会退出阻塞状态

- isBroken()：返回barrier的broken状态，某个线程由于执行await方法而进入阻塞状态，如果该线程被执行了中断操作，那么isBroken()方法将会返回true

- getNumberWaiting()方法： 该方法返回当前barrier有多少个线程执行了await方法而不是还有多少个线程未到达barrier point，这一点需要注意

- reset()方法：前面已经详细地介绍过这个方法，其主要作用是中断当前barrier，并且重新生成一个generation，还有将barrier内部的计数器count设置为parties值，但是需要注意的是，如果还有未到达barrier point的线程，则所有的线程将会被中断并且退出阻塞，此时isBroken()方法将返回false而不是true

CyclicBarrier会被broken这一点我们已经通过上面的代码证明过了，但是需要注意如下几点（非常重要）

- 当一个线程由于在执行CyclicBarrier的await方法而进入阻塞状态时，这个时候对该线程执行中断操作会导致CyclicBarrier被broken

- 被broken的CyclicBarrier此时已经不能再直接使用了，如果想要使用就必须使用reset方法对其重置

- 如果有其他线程此时也由于执行了await方法而进入阻塞状态，那么该线程会被唤醒并且抛出BrokenBarrierException异常

### CyclicBarrier VS. CountDownLatch

- CoundDownLatch的await方法会等待计数器被count down到0，而执行CyclicBarrier的await方法的线程将会等待其他线程到达barrier point

- CyclicBarrier内部的计数器count是可被重置的，进而使得CyclicBarrier也可被重复使用，而CoundDownLatch则不能

- CyclicBarrier是由Lock和Condition实现的，而CountDownLatch则是由同步控制器AQS（AbstractQueuedSynchronizer）来实现的

- 在构造CyclicBarrier时不允许parties为0，而CountDownLatch则允许count为0

## 3 Exchanger工具详解

Exchanger（交换器），Exchanger简化了两个线程之间的数据交互，并且提供了两个线程之间的数据交换点，Exchanger等待两个线程调用其exchange()方法。调用此方法时，交换机会交换两个线程提供给对方的数据。

- public V exchange(V x) throws InterruptedException：数据交换方法，该方法的作用是将数据x交换至搭档线程，执行该方法后，当前线程会进入阻塞状态，只有当搭档线程也执行了exchange方法之后，该当前线程才会退出阻塞状态进行下一步的工作，与此同时，该方法的返回值代表着搭档线程所传递过来的交换数据
- public V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException：该方法的作用与前者类似，只不过增加了超时的功能，也就是说在指定的时间内搭档线程没有执行exchange方法，当前线程会退出阻塞，并且返回值为null

## 4 Semaphore工具详解

Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。

- Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。

- Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。

- Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证的过程，下面是Semaphore的内部处理逻辑。

### tryAcquire方法

- tryAcquire()：尝试获取Semaphore的许可证，该方法只会向Semaphore申请一个许可证，在Semaphore内部的可用许可证数量大于等于1的情况下，许可证将会获取成功，反之获取许可证则会失败，并且返回结果为false。

- boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException：该方法与tryAcquire无参方法类似，同样也是尝试获取一个许可证，但是增加了超时参数。如果在超时时间内还是没有可用的许可证，那么线程就会进入阻塞状态，直到到达超时时间或者在超时时间内有可用的证书（被其他线程释放的证书），或者阻塞中的线程被其他线程执行了中断

- boolean tryAcquire(int permits)：在使用无参的tryAcquire时只会向Semaphore尝试获取一个许可证，但是该方法会向Semaphore尝试获取指定数目的许可证

- boolean tryAcquire(int permits, long timeout, TimeUnit unit)：该方法与第二个方法类似，只不过其可以指定尝试获取许可证数量的参数

- void acquire()：该方法会向Semaphore获取一个许可证，如果获取不到就会一直等待，直到Semaphore有可用的许可证为止，或者被其他线程中断。当然，如果有可用的许可证则会立即返回

- void acquire(int permits)：该方法会向Semaphore获取指定数量的许可证，如果获取不到就会一直等待，直到Semaphore有可用的相应数量的许可证为止，或者被其他线程中断。同样，如果有可用的permits个许可证则会立即返回

- void acquireUninterruptibly()：该方法会向Semaphore获取一个许可证，如果获取不到就会一直等待，与此同时对该线程的任何中断操作都会被无视，直到Semaphore有可用的许可证为止。当然，如果有可用的许可证则会立即返回

- void acquireUninterruptibly(int permits)：该方法会向Semaphore获取指定数量的许可证，如果获取不到就会一直等待，与此同时对该线程的任何中断操作都会被无视，直到Semaphore有可用的许可证为止，或者被其他线程中断。同样，如果有可用的permits个许可证则会立即返回

- void release()：释放一个许可证，并且在Semaphore的内部，可用许可证的计数器会随之加一，表明当前有一个新的许可证可被使用

- void release(int permits)：释放指定数量（permits）的许可证，并且在Semaphore内部，可用许可证的计数器会随之增加permits个，表明当前又有permits个许可证可被使用

- boolean isFair()：对Semaphore许可证的争抢采用公平还是非公平的方式，对应到内部的实现类为FairSync（公平）和NonfairSync（非公平）

- int availablePermits()：当前的Semaphore还有多少个可用的许可证

-  int drainPermits()：排干Semaphore的所有许可证，以后的线程将无法获取到许可证，已经获取到许可证的线程将不受影响

- boolean hasQueuedThreads()：当前是否有线程由于要获取Semaphore许可证而进入阻塞？（该值为预估值。）

- int getQueueLength()：如果有线程由于获取Semaphore许可证而进入阻塞，那么它们的个数是多少呢？（该值为预估值。）

## 5 Phaser的基本用法

CountDownLatch可以很好地控制等待多个线程执行完子任务，但是它有一个缺点，那就是内部的计数器无法重置，也就是说CountDownLatch属于一次性的，使用结束后就不能再次使用。CyclicBarrier倒是可以重复使用，但是一旦parties在创建的时候被指定，就无法再改变。Phaser则取百（两）家之所长于一身引入了两者的特性。

在Phaser中可以有多个Phase（阶段），为了更好地对每一个Phase进行管理和监控，Phaser为每一个Phase都提供了对应的编号，这一点与CyclicBarrier是不一样的，后者更加注重的是循环。CyclicBarrier在所有的线程都到达barrier point之后，它才会重新开始，而Phaser则不然，只要某一个Phase的所有关联parties都arrive（到达）了，它就会从下一个Phase继续开始，除非Phaser本身已经被终止或者销毁。

## 6 Lock接口方法

- lock()方法：尝试获取锁，如果此刻该锁未被其他线程持有，则会立即返回，并且设置锁的hold计数为1；如果当前线程已经持有该锁则会再次尝试申请，hold计数将会增加一个，并且立即返回；如果该锁当前被另外一个线程持有，那么当前线程会进入阻塞，直到获取该锁，由于调用lock方法而进入阻塞状态的线程同样不会被中断，这一点与进入synchronized同步方法或者代码块被阻塞类似

- lockInterruptibly()方法：该方法的作用与前者类似，但是使用该方法试图获取锁而进入阻塞操作的线程则是可被中断的，也就说线程可以获得中断信号

- tryLock()方法：调用该方法获取锁，无论成功与否都会立即返回，线程不会进入阻塞状态，若成功获取锁则返回true，若获取锁失败则返回false。使用该方法时请务必注意进行结果的判断，否则会出现获取锁失败却仍旧操作共享资源而导致数据不一致等问题的出现

- tryLock(long time, TimeUnit unit)方法：该方法与tryLock()方法类似，只不过多了单位时间设置，如果在单位时间内未获取到锁，则返回结果为false，如果在单位时间内获取到了锁，则返回结果为true，同样hold计数也会被设置为1

- unlock()方法：当某个线程对锁的使用结束之后，应该确保对锁资源的释放，以便其他线程能够继续争抢，unlock()方法的作用正在于此

- newCondition()方法：创建一个与该lock相关联的Condition对象

## 7 ReentrantLock扩展方法

- getHoldCount()方法：查询当前线程在某个Lock上的数量，如果当前线程成功获取了Lock，那么该值大于等于1；如果没有获取到Lock的线程调用该方法，则返回值为0
- isHeldByCurrentThread()方法：判断当前线程是否持有某个Lock，由于Lock的排他性，因此在某个时刻只有一个线程调用该方法返回true
- isLocked()方法：判断Lock是否已经被线程持有
- isFair()方法：创建的ReentrantLock是否为公平锁
- hasQueuedThreads()方法：在多个线程试图获取Lock的时候，只有一个线程能够正常获得，其他线程可能（如果使用tryLock()方法失败则不会进入阻塞）会进入阻塞，该方法的作用就是查询是否有线程正在等待获取锁
- hasQueuedThread(Thread thread)方法：在等待获取锁的线程中是否包含某个指定的线程
- getQueueLength()方法：返回当前有多少个线程正在等待获取锁

## 8 ReadWriteLock&ReentrantReadWriteLock详解

```java
// 定义ReadWriteLock锁
private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
// 创建读锁
private final Lock readLock = readWriteLock.readLock();
// 创建写锁
private final Lock writeLock = readWriteLock.writeLock();
```

在没有任何写操作的情况下，读锁的效率反倒是最差的，这的确令人感到失望和惊讶，实际上，ReadWriteLock的性能表现确实不尽如人意，这也是在JDK1.8版本中引入StampedLock的原因之一

## 9 Condition详解

如果说显式锁Lock可以用来替代synchronized关键字，那么Condition接口将会很好地替代传统的、通过对象监视器调用wait()、notify()、notifyAll()线程间的通信方式。Condition对象是由某个显式锁Lock创建的，一个显式锁Lock可以创建多个Condition对象与之关联，Condition的作用在于控制锁并且判断某个条件（临界值）是否满足，如果不满足，那么使用该锁的线程将会被挂起等待另外的线程将其唤醒，与此同时被挂起的线程将会进入阻塞队列中并且释放对显式锁Lock的持有，这一点与对象监视器的wait()方法非常类似。

- void await() throws InterruptedException：当前线程调用该方法会进入阻塞状态直到有其他线程对其进行唤醒，或者对当前线程执行中断操作。当线程执行了await()方法进入阻塞时；当前线程会被加入到阻塞队列中，并且释放对显式锁的持有，object monitor的wait()方法被执行后同样会加入一个虚拟的容器waitset（线程休息室）中，waitset是一个虚拟的概念，JVM（虚拟机）规范并未强制要求其采用什么样的数据结构，Condition的wait队列则是由Java程序实现的FiFO队列

- void awaitUninterruptibly()：该方法与await()方法类似，只不过该方法比较固执，它会忽略对它的中断操作，一直等待有其他线程将它唤醒

- long awaitNanos(long nanosTimeout) throws InterruptedException：调用该方法同样会使得当前线程进入阻塞状态，但是可以设定阻塞的最大等待时间，如果在设定的时间内没有其他线程将它唤醒或者被执行中断操作，那么当前线程将会等到设定的纳秒时间后退出阻塞状态

- boolean await(long time, TimeUnit unit) throws InterruptedException：执行方法awaitNanos(),如果到达设定的纳秒数则当前线程会退出阻塞，并且返回实际等待的纳秒数，但是程序很难判断线程是否被正常唤醒，因此该方法的作用除了可以指定等待的最大的单位时间，另外，还可以返回在单位时间内被正常唤醒而且还是由于超时而退出的阻塞

- boolean awaitUntil(Date deadline) throws InterruptedException：调用该方法同样会导致当前线程进入阻塞状态直到被唤醒、被中断或者到达指定的Date

- void signal()：唤醒Condition阻塞队列中的一个线程，Condition的wait队列采用FiFO的方式，因此在wait队列中，第一个进入阻塞队列的线程将会被首先唤醒，下面我们来设计一个case对其进行测试

- void signalAll()：唤醒Condition wait队列中的所有线程

## 10 StampedLock详解

StampedLock被JDK1.8版本引入之后，成为了Lock家族的新宠，它几乎具备了ReentrantLock、ReentrantReadWriteLock这两种类型锁的所有功能

与ReentrantReadWriteLock锁一样，StampedLock也提供了读锁和写锁这两种模式，因此StampedLock天生就支持读写分离锁的使用方式

StampedLock还提供了一个模式，即乐观读模式，使用tryOptimisticRead()方法获取一个非排他锁并且不会进入阻塞状态，与此同时该模式依然会返回一个long型的数据戳用于接下来的验证（该验证主要用来判断共享资源是否有写操作发生 lock.validate）

## 11 Guava之Monitor详解

Monitor以及Monitor Guard则很好地将类似的一系列动作进行了抽象，隐藏了锁的获取、临界值判断、线程挂起、阻塞线程唤醒、锁的释放等操作。

- 对x进行操作之前先调用monitor.enterWhen()方法，该方法除了具备锁的功能之外还具备临界值判断的操作，因此只有当x满足临界值判断时当前线程才会对x进行自增运算，否则当前线程将会进入阻塞队列（其实在Guard内部使用的也是Condition）

- 调用leave()方法，注释③处，该方法除了释放当前的锁之外，还会通知唤醒与Guard关联的Condition阻塞队列中的某个阻塞线程

- enter()：该方法完全等价于Lock的lock()方法

- enterIf(Guard guard)：该方法主要用于判断当前的Guard是否满足临界值的判断，也是使用比较多的一个操作，调用该方法，当前线程并不会进入阻塞之中

- tryEnter()：等价于Lock的tryLock()方法

- waitFor(Guard guard)：当前线程将会阻塞等待，直到Guard的条件满足当前线程才会退出阻塞状态

## 12 Guava之RateLimiter详解

RateLimiter，顾名思义就是速率（Rate）限流器（Limiter），事实上它的作用正如名字描述的那样，经常用于进行流量、访问等的限制，这一点与3.4节中介绍过的Semaphore非常类似，但是它们的关注点却完全不同，RateLimiter关注的是在单位时间里对资源的操作速率（在RateLimiter内部也存在许可证（permits）的概念，因此可以理解为在单位时间内允许颁发的许可证数量），而Semaphore则关注的是在同一时间内最多允许多少个许可证可被使用，它不关心速率而只关心个数

虽然说RateLimiter主要是用于控制速率的，但是在其内部也有许可证（permits）的概念，你甚至可以将其理解为单位时间内颁发的许可证数量，RateLimiter不仅允许每次获取一个许可证的操作，还允许获取超出剩余许可证数量的行为，只不过后者的操作将使得下一次请求为提前的透支付出代价。
