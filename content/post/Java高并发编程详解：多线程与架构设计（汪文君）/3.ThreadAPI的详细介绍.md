---
title: 第三章 ThreadAPI的详细介绍
description: Java高并发编程详解：多线程与架构设计（汪文君）- 第三章 ThreadAPI的详细介绍
slug: Java高并发编程详解：多线程与架构设计（汪文君）- 第三章 ThreadAPI的详细介绍
date: 2022-08-15 14:00:00+0000
categories:
    - Java高并发编程详解：多线程与架构设计（汪文君）
tags:
    - Java
---

# 第三章 ThreadAPI的详细介绍

## 1 线程sleep

sleep是一个静态方法，并有两个重载方法，其中一个需要传入毫秒数，另一个既需要毫秒数也需要纳秒数。

sleep方法会使当前线程进入指定毫秒数的休眠，暂停执行，虽然给定了一个休眠的时间，但是最终还是要以系统的定时器以及调度器的精度为准，休眠有一个重要的特性就是不会放弃monitor锁的所有权。

JDK1.5以后JDK引入了一个枚举TimeUtil，其对sleep提供了很好的封装。使用它可以省去很多时间单位的换算步骤。

## 2 线程yield

yieId方法属于一种启发式的方法，其会提醒调度器我愿意放弃当前CPU资源，如果CPU资源不紧张，则会忽略这种提醒。

2.1 JDK1.5之前的版本中 yieId的方法事实上是调用了sleep(0)，但是他们之间存在本质的区别

2.2 yield只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，他会导致线程上下文的切换。

2.3 sleep会使线程短暂block，会在给定时间内释放CPU资源。

2.4 yield会使RUNNING状态的Thread进入RUNNABLE状态（如果CPU调度器没有忽略这个提示的话）

2.5 sleep几乎百分之百的完成了给定时间的休眠，而yield的提示不一定能担保

2.6 一个线程sleep另一个线程调用interrupt会捕获到中断信号，而yield不会

## 3 线程优先级（setPriority）

理论上优先级比较高的线程会获取优先被CPU调度的机会。如果CPU比较忙，优先级高的可能会获得更多的CPU时间片。但是闲事优先级的高低几乎不会有任何作用。

线程的优先级不能小于1，也不会大于10。如果指定的线程优先级大于线程所在Group的优先级，那么指定的优先级将会失效。取而代之的是group的最大优先级。一般都是5。

## 4 获取线程ID

public long getId() 获取线程的唯一ID，线程ID在整个JVM进程中都会是唯一的。

## 5 获取当前线程

public static Thread currentThread() 用于返回当前线程的引用。

## 6 设置线程上下文类加载器

public ClassLoader getContextClassLoader

public void setContextClassLoader

设置该线程的类加载器，这个方法可以打破JAVA类加载器的父类委托机制，有时候该方法也成为JAVA类加载器的后门。

## 7 线程interrrupt

wait、sleep、join等方法会使当前线程进入阻塞状态，若另一个线程调用被阻塞线程的interrrupt方法，则会打断这种阻塞。

所以是用来打断阻塞继续运行的？不过打断会导致抛出一个异常InterruptedException

## 8 线程join

线程A join线程B，会使线程A进入等待，直到线程B结束生命周期或者到达给定时间，在此期间线程A是处于BLOCKED的

## 9 如何关闭一个线程

JDK有一个被弃用的方法，stop用来关闭线程，但这个方法在关闭线程时可能不会释放掉monitor锁，所以强烈建议不要使用该方法结束线程

### 9.1 使用中断信号退出线程

### 9.2 使用volatile开关

