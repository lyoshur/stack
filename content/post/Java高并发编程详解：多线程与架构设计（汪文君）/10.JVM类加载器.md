---
title: 第十章 JVM类加载器
description: Java高并发编程详解：多线程与架构设计（汪文君）- 第十章 JVM类加载器
slug: Java高并发编程详解：多线程与架构设计（汪文君）- 第十章 JVM类加载器
date: 2022-08-16 14:00:00+0000
categories:
    - Java高并发编程详解：多线程与架构设计（汪文君）
tags:
    - Java
---

# 第十章 JVM类加载器

类的加载器负责类的加载职责，对于任意一个class都需要由加载它的类加载器和这个类本身确定其在JVM中的唯一性，这也就是运行时包。

## 1 JVM内置三大类加载器

- Bootstrap ClassLoader

  根加载器又称为Bootstrap类加载器，是最为顶层的加载器，其没有任何父加载器，是由C++编写的，主要负责核心类库的加载。

- Ext ClassLoader

  拓展类加载器的父加载器是根加载器，主要用于加载 JAVA_HOME下的 jre/lib/ext 目录里面的类库，拓展类加载器是由纯Java语言实现的，它是java.lang.URLClassLoader的子类。

- Application ClassLoader

  系统类加载器是一种常见的加载器，其负责加载classpath下的类库资源，我们在进行项目开发的时候引入的第三方jar包，系统类加载器的父加载器是拓展类加载器，同时他也是自定义类加载器的默认父加载器。

不同的类加载器负责将不同的类加载到JVM内存之中，并且他们之间严格遵守着父委托的机制。

## 2 自定义类加载器

自定义类加载器必须是ClassLoader的直接或间接子类，然后重写findClass方法。

【note】这里注意，自定义类加载器需要重写findClass方法，但是破坏双亲委托机制需要重写loadClass方法。

## 3 双亲委托机制详细介绍

双亲委托机制，有时候也称父委托机制。当一个类加载器被调用loadClass后，他并不会直接进行加载，而是交给当前类加载器的父加载器尝试加载，直到最顶层的加载器，然后再依次向下进行加载。

loadClass的执行流程

- 从当前类的已加载类缓存中根据类的全路径名查询是否存在该类，如果存在则直接返回。

- 如果当前类存在父类，则调用父类加载器的loadClass方法对其进行加载。

- 如果当前类不存在父类，则直接调用根加载器对其进行加载。

- 如果当前类的父类没有加载成功，则调用当前类加载器的findClass方法对其进行加载。

- 如果类最后被成功加载，则做一些性能数据的统计。

- 由于loadClass指定了resolve，所以不会进行连接阶段的继续执行，这也解释了为什么类加载器不会导致类的初始化。

4 破坏双亲委托机制

重写loadClass，改为如下流程

- 根据类的全路径名称进行加锁，确保每一个类在多线程的情况下只被加载一次。

- 从当前类的已加载类缓存中根据类的全路径名查询是否存在该类，如果存在则直接返回。

- 若缓存中没有被加载的类，则需要对其进行首次加载，如果类的全路径名称以 java/javax 开头，则直接委托给系统类加载器进行加载。

- 如果不是以 java/javax开头，则尝试使用自己的类加载器对其进行加载。

- 若自定义的加载器没有完成对类的加载，则委托给其父类加载器或系统加载器进行加载。

- 若干次尝试后，仍没有对类进行加载，则抛出无法找到类的异常。

## 4 类加载器命名空间、运行时包、类的卸载

- 每个类加载器实例都有各自的命名空间，命名空间是由该加载器以及其所有的父加载器所构成的。因此在每个类加载器中同一个class都是独一无二的。

  在类加载器进行类加载的时候，首先会到加载记录表也就是缓存中，查看该类是否已经加载过了，如果已经加载过了就不会重复加载。否则会认为其是第一次加载

- 运行时包

  我们在编写代码时，通常会给一个类指定一个包名，包的作用是为了组织类，防止不同包下的同样名称的class起冲突。包名和类名构成了类的全限定名称。

  比如

  ```
  BootstrapClassLoader.ExtClassLoader.ApplicationClassLoader.MyClassLoader.com.xxzzz.Demo	
  ```

  这样做的好处是处于安全和封装的考虑，这样自定义的类和系统类拥有不同的运行时包。

- 初始类加载器

  由于运行时包的存在，JVM规定了不同的运行时包下的类彼此之间是不可以互相访问的。

  根据JVM规范的规定，在类的加载过程中，所有参与的类加载器，即使没有亲自加载过该类，也会标识为该类的初始类加载器。

- 类的卸载
  - 该类的所有实例都已经被GC
  - 该类对应的类加载器被GC
  - 该类的class实例没有在其他地方被引用
