---
title: 第五章 线程间通信
description: Java高并发编程详解：多线程与架构设计（汪文君）- 第五章 线程间通信
slug: Java高并发编程详解：多线程与架构设计（汪文君）- 第五章 线程间通信
date: 2022-08-15 15:10:00+0000
categories:
    - Java高并发编程详解：多线程与架构设计（汪文君）
tags:
    - Java
---

# 第五章 线程间通信

与网络通信等进程间通信方式不一样,线程间通信又称为进程内通信,多个线程实现互斥访问共享资源时会互相发送信号和等待信号。比如线程等待数据到来的信号。线程收到变量改变的信号。

## 1 初始wait和notify

wait()  导致当前线程等待，直到其他线程调用此对象的 [notify](https://so.csdn.net/so/search?q=notify&spm=1001.2101.3001.7020)()方法或 notifyAll()方法前，导致当前线程等待。

notify() 唤醒在此同步监视器上等待的单个线程，如果有多个线程在此同步监视器上等待，则会唤醒其中的一个，

```java
package lyoshur;

import java.util.LinkedList;

public class EventQueue {

    private final int max;

    static class Event{}

    private final LinkedList<Event> eventQueue = new LinkedList<>();

    private final static int DEFAULT_MAX_EVENT = 10;

    public EventQueue() {
        this(DEFAULT_MAX_EVENT);
    }

    public EventQueue(int max) {
        this.max = max;
    }

    public void offer(Event event) {
        synchronized (eventQueue) {
            if (eventQueue.size() >= max) {
                try {
                    eventQueue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            eventQueue.addLast(event);
            eventQueue.notify();
        }
    }

    public Event take() {
        synchronized (eventQueue) {
            if (eventQueue.isEmpty()) {
                try {
                    eventQueue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Event event = eventQueue.removeFirst();
            this.eventQueue.notify();
            return event;
        }
    }
}

```

当eventQueue满时，会调用eventQueue.wait。这时offer会释放掉锁资源，并将当前线程添加到 wait set。

当消费掉数据后，this.eventQueue.notify(); 会通知某个wait set的线程启动，但不会立即执行，需要当前take释放掉锁。而offer会重新获取锁，并从上次wait的地方继续运行。

## 2 多线程间通信

多线程间通信需要用到Object的notifyAll方法。

这个队列在多线程同时并发的情况下会出现数据不一致的问题，大致可以被分为两部分，一个是超过了最大数量仍在执行add，另一个是没有元素了仍调用remove。

改进：需要将临界值的判断if更改为while，将notify更改为notifyAll

## 3 线程休息室

在虚拟机规范中存在一个wait set的概念，但没有定义具体的数据结构。不同的厂商有着不同的实现方式。线程调用某个对象的wait方法后，都会被加入到与该对象monitor关联的wait set中，至于是先入先出还是随机弹出，虚拟机规范也没有规定。

## 4 显示锁

可以使用BooleanLock显示锁来控制。sync不能被打断，但是显示锁可以。

