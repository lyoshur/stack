---
title: 第一章 快速认识线程
description: Java高并发编程详解：多线程与架构设计（汪文君）- 第一章 快速认识线程
slug: Java高并发编程详解：多线程与架构设计（汪文君）- 第一章 快速认识线程
date: 2022-08-15 10:50:00+0000
categories:
    - Java高并发编程详解：多线程与架构设计（汪文君）
tags:
    - Java
---

# 第一章 快速认识线程



对计算机来说每一个任务就是一个进程（Process）,在每一个进程内部至少要有一个线程（Thread）是在运行中，有时线程也称为轻量级的进程。

每一个线程都有自己的程序计数器、局部变量表、生命周期。

线程生命周期大体可以分为如下5个主要的阶段。NEW、RUNNABLE、RUNNING、BLOCKED、TERMINATED。

## 1 模板设计模式在Thread中的应用

我们可以通过 new Thread().start(); 的方式启动一个线程，start方法的源码如下

```java
public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
```

最核心的是start0这个本地方法。而start0会调用run方法。

通过分析，线程的真正执行逻辑是在run方法中，通常我们会将run方法称为线程的执行单元。

默认的Thread代码如下

```java
public class Thread implements Runnable {
    private Runnable target;
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
}
```

所以我们可以有两种方式来实现Thread的执行单元，一种是直接重写现成的run方法。另一种是使用构造传递一个Runnable给Thread。

【NOTE】这里插入一下，这里作者将这种Thread和Runnable之间的关系归类为模板设计模式，然后举了一个数据库查询Handler的例子。但是感觉没有解释清楚模板设计模式和策略模式的区别。个人感觉模板设计模式更侧重于，将模板类的一部分功能，延迟到接口类来进行实现。而策略模式侧重于为了完成某个功能，提供不同的接口类，切换使用。
