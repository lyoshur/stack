---
title: 第十二章 volatile关键字介绍
description: Java高并发编程详解：多线程与架构设计（汪文君）- 第十二章 volatile关键字介绍
slug: Java高并发编程详解：多线程与架构设计（汪文君）- 第十二章 volatile关键字介绍
date: 2022-08-16 14:30:00+0000
categories:
    - Java高并发编程详解：多线程与架构设计（汪文君）
tags:
    - Java
---

# 第十二章 volatile关键字介绍

## 1 机器硬件CPU

在计算机，所有的运算操作都是由CPU的寄存器来完成的，CPU指令的执行过程需要涉及到数据的读取和写入操作。Cpu访问的数据只能是计算机的主存。

由于两边数据的严重不对等，通过传统FSB直连内存的访问方式很明显会导致CPU资源收到大量限制，降低CPU整体的吞吐量。于是就有了在CPU和主存之间做缓存的限制。最靠近CPU的缓存称之为L1，然后依次是L2,L3和主内存。

由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache又被划分为了 L1i （instrucgtion）和 L1d (data)

CPU Cache又是由很多 Cache Line构成的，Cache Line是CPU Cache的最小组成单位。目前主流的Cache Line都是64字节。

Cache的出现是为了解决CPU直接访问内存效率低下的问题，所以程序在运行时，会将运算所需的一部分数据从主存复制到Cache，当运算结束后再将数据刷回到主存。

## 2 CPU缓存一致性问题

每个线程都有自己的工作内存，变量会在多个线程的本地内存都存一份副本。

为了解决缓存一致性问题，通常主流的解决办法有两种：

- 通过总线加锁的方式

  常见于早期的CPU，而且是一种悲观的实现方式，CPU和其他组件通信，都是通过总线来进行的，通过对总线进行加锁，会阻塞其他CPU的访问，从而使得只有一个CPU能够访问这个变量的内存。

- 通过缓存一致性协议

  最为出名的是Intel的MESI协议，它保证了每个缓存中使用的变量副本都是一致的。

  - 读取操作，将缓存中的数据读取到寄存器

  - 写入操作，发出信号通知其他CPU将变量的Cache Line置为无效的状态，其他的CPU在进行变量读取时，不得不去主内存再次读取。

## 3 Java内存模型（JMM）

Java内存模型定义了线程和主内存之间的抽象关系：

- 共享变量储存于主内存之中，每个线程都可以访问。
- 每个线程都有私有的工作内存或者称为本地内存。
- 工作内存只储存该线程对共享变量的副本。
- 线程不能直接操作主内存，只有操作工作内存，再写入主内存。
- 工作内存和JMM一样，是一个抽象的概念，它其实并不存在。它涵盖了缓存、编译器优化、寄存器、和硬件。

