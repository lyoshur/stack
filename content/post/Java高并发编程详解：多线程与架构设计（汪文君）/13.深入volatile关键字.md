---
title: 第十三章 深入volatile关键字
description: Java高并发编程详解：多线程与架构设计（汪文君）- 第十三章 深入volatile关键字
slug: Java高并发编程详解：多线程与架构设计（汪文君）- 第十三章 深入volatile关键字
date: 2022-08-16 15:22:00+0000
categories:
    - Java高并发编程详解：多线程与架构设计（汪文君）
tags:
    - Java
---

# 第十三章 深入volatile关键字

## 1 并发编程的三个重要特性

- 原子性

  原子性指在一个操纵或多次操作中，要么所有操作得到执行，要么所有操作都不执行

- 可见性

  当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值

- 有序性

  所谓有序性，是指程序代码在执行过程中的先后顺序
  
  【note】这里其实是说，在多线程情况下，并不能保证像单线程一样严格的顺序执行，因为有可能线程1在执行过判断后，放弃了CPU时间片，线程2开始执行。

JVM采用内存模型的机制，来屏蔽各个平台和操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果。（比如java中的Int固定为4字节，这就是所谓的一致内存访问效果）

## 2 JMM与原子性

- 多个原子性操作在一起就不再是原子性操作了

- 简单的读取和赋值是原子性的，但将一个变量赋值给另一个变量不是原子性的

- JMM只保证了基本读取和赋值的原子性，其他不再保证了。如果想使某些代码片段具备原子性，需要使用关键子synchronized或者JUC的lock。如果想使int等类型自增操作具备原子性，可以使用JUC.atomic

volatile不具备原子性

## 3 JMM与可见性

- 使用关键字volatile来保证可见性
- 使用synchronized保证可见性
- 使用JUC的lock保证可见性

volatile具备可见性

## 4 JMM与有序性

- 使用关键字volatile来保证有序性
- 使用synchronized保证有序性
- 使用JUC的lock保证有序性

volatile具备有序性

此外JMM具备一些天生的有序性规则，不需要任何同步手段就能保持有序性。（Happens-before原则）

- 程序次序规则

- 锁定规则

- volatile变量规则

- 传递规则

- 线程启动规则

- 线程中断规则

- 线程的终结规则

- 对象的终结规则

## 5 volatile关键字深入解析

### 5.1 volatile关键字的语义

被volatile修饰的实例变量或者类变量具备如下两层语义

- 保证了不同线程之间对共享变量操作时的可见性

- 禁止对指令进行重排序（直接禁止JVM和处理器对volailte关键字修饰的指令进行重排序）

### 5.2 volatile的原理和实现机制

通过对unsafe.cpp源码的阅读，会发现被volatile修饰的变量存在与一个“lock;”前缀

lock;前缀实际上相当于一个内存屏障，该内存屏障会为指令的执行提供如下几个保障。

- 确保指令重排序时不会将后面的代码排到内存屏障之前。
- 确保指令重排序时不会将前面的代码排到内存屏障之后。
- 确保执行到内存屏障修饰的指令时，前面的代码全部执行完成。
- 强制将工作线程中的值，修改刷新到主内存
- 如果是写操作，则会强制其他线程的工作内存中的缓存数据全部失效





